## Page 1

# ND-5000 Hardware Description

ND-05.020.1 EN

ND  
Norsk Data

---

## Page 2

# ND-5000 Hardware Description

*ND-05.020.1 EN*

---

## Page 3

# Important Notice

The information in this manual is subject to change without notice. Norsk Data A.S assumes no responsibility for any errors that may appear in this manual, or for the use or reliability of its software on equipment that is not furnished or supported by Norsk Data A.S.

Copyright © 1988 by Norsk Data A.S

Version 1 | April 1988

## Documentation Requests

Send all documentation requests to:

Norsk Data A.S  
Graphic Centre  
P.O. Box 25 — Bogerud  
N-0621 Oslo 6  
NORWAY

---

## Page 4

# Preface

## The Product
This manual describes the ND-5000 computer systems from a hardware point of view.

## The Reader
The manual is written for personnel wanting a general introduction to the ND-5000 hardware.

## Prerequisite Knowledge
Familiarity with the ND-120 architecture.

## The Manual
Special subjects related to system programming are found in

- Chapter 3 The Cache System
- Chapter 6 Memory Management System

## Related Manuals

- ND-5000 Hardware Maintenance (05.017.1)
- ND-5000 Series User Guide (30.071.1)
- ND-5000 Microprogram Guide (05.022.1)
- ND-500 Reference Manual (05.009.4)
  (also valid for the ND-5000)

Norsk Data ND-05.020.1 EN

---

## Page 5

# Table of Contents

| Chapter | Title                                  | Page |
|---------|----------------------------------------|------|
| 1       | Introduction                           | 1    |
| 2       | System Overview                        | 2    |
| 3       | Installation                           | 5    |
| 4       | Configuration                          | 10   |
| 5       | Operation                              | 15   |
| 6       | Maintenance                            | 20   |
| 7       | Troubleshooting                        | 25   |
| A       | Appendices                             | 30   |

# Norsk Data

**Document Number**: ND-05.020.1 EN

---

## Page 6

# INTRODUCTION TO THE ND-5000

| Section | Title                                          | Page |
|---------|------------------------------------------------|------|
| 1.1     | System Overview                                | 3    |
| 1.2     | Models                                         | 4    |
| 1.3     | ND-5000 Cabinet Versions                       | 5    |
| 1.4     | ND-5000 Large Cabinet                          | 5    |
| 1.5     | ND-5000 Compact                                | 7    |
| 1.6     | New Multifunction Bus System                   | 9    |
| 1.7     | ND-5000 CPU                                    | 9    |
| 1.7.1   | CPU Types                                      | 10   |
|         | ND-5000 Basic CPU Type 1                       | 10   |
|         | ND-5000 Basic CPU Type 2                       | 11   |
|         | ND-5000 Basic CPU Type 3                       | 12   |
|         | Difference Between the CPU Types               | 13   |
| 1.7.2   | CPU Functional Overview                        | 14   |
|         | Mother Board                                   | 17   |
|         | Interface Between the ND-5000 and its Surroundings | 17   |
|         | Access Module                                  | 17   |
|         | Memory Interface                               | 18   |
|         | Macroinstruction Decoding and the Instruction Cache | 19   |
|         | Data Address Generation and the Data Cache     | 21   |
|         | Arithmetic Logic Unit and Working Register File | 21   |
|         | Microprogram and Microinstruction Controller   | 22   |
|         | Additional Arithmetic Processor                | 23   |
|         | Microprogrammed Floating Point                 | 23   |
| 1.8     | I/O Processor (ND-120)                         | 24   |
|         | ND-120 Processor                               | 24   |
|         | Harddisk Controller                            | 24   |
|         | Floppy and Streamer                            | 24   |
|         | Multifunction Bus Line Driver                  | 25   |
| 1.9     | Communication with the ND-121                  | 26   |
| 1.10    | Memory                                         | 26   |
| 1.11    | Mass Storage                                   | 27   |
| 1.12    | Input/Output (I/O)                             | 28   |
| 1.13    | ND-5000 Highlights                             | 29   |

# THE MICROINSTRUCTION PIPELINE SYSTEM

| Section | Title                           | Page |
|---------|---------------------------------|------|
| 2.1     | Execution Hierarchy             | 33   |
| 2.2     | Pipeline Levels                 | 35   |
| 2.2.1   | Instruction Level (I-level)     | 36   |
| 2.2.2   | Data Level (M-level)            | 37   |
| 2.2.3   | ALU Level (A-level)             | 39   |
| 2.2.4   | Result Level (F-level)          | 40   |
| 2.3     | Pipeline Situation Example      | 41   |  

Norsk Data ND-05.020.1 EN

---

## Page 7

# 3 THE CACHE SYSTEM

| Section                                       | Page |
|-----------------------------------------------|------|
| 3.1 General                                   | 47   |
| 3.2 Data Cache                                | 48   |
| 3.2.1 Read from Memory                        | 50   |
| 3.2.2 Write to Memory                         | 50   |
| 3.2.3 Addressing the Data Cache               | 52   |
| 3.2.4 Write-Once Strategy                     | 52   |
| 3.2.5 Data Cache Operating Modes              | 54   |
| 3.3 Instruction Cache                         | 55   |
| Instruction Cache Directory                   | 56   |
| The Cached Instruction                        | 56   |
| Control Word Cache                            | 57   |
| 3.3.1 Operand Map and Instruction Map         | 57   |
| 3.3.2 Hashing Mechanism                       | 58   |
| 3.3.3 Microprogram Control of the Instruction Cache | 59  |
| 3.3.4 Instruction Cache Sequencing            | 60   |
| 3.3.5 Instruction Cache HIT                   | 62   |
| 3.3.6 Instruction Cache MISS                  | 62   |
| 3.3.7 Macroinstruction Sequence Break         | 63   |
| 3.3.8 Instruction Cache Operating Modes       | 64   |
| 3.4 Microprogrammed Access for Test Purposes  | 65   |
| Data Cache Write Destination                  | 65   |
| Data Cache A-operand Sources                  | 65   |
| Instruction Cache Write Destinations          | 66   |
| Instruction Cache A-operand Sources           | 66   |

# 4 THE TRAP SYSTEM

| Section                                                 | Page |
|---------------------------------------------------------|------|
| 4.1 General                                             | 69   |
| 4.2 Cooperation Between the Hardware and the Microprogram | 70   |
| 4.3 ND-5000 Macrostatus Register                         | 72   |

# 5 THE ACCESS MODULE

| Section                                                                 | Page |
|-------------------------------------------------------------------------|------|
| 5.1 FUNCTIONAL DESCRIPTION                                              | 83   |
| 5.1.1 Access Module Tasks                                               | 84   |
| 5.1.2 Interface Between the ND-5000 and the ND-120                      | 85   |
| Octobus                                                                | 85   |
| Shared Memory                                                          | 86   |
| 5.1.3 Interface Between the Access Module and the ND-5000              | 87   |
| 5.2 HARDWARE IMPLEMENTATION                                             | 89   |
| Interrupt                                                              | 91   |
| Speed Considerations                                                   | 91   |
| 5.2.1 Device Descriptions                                              | 92   |
| ROM/RAM                                                                | 92   |
| Octobus Controller (OCTC)                                              | 92   |
| First-in-first-out Buffer (FIFO)                                       | 94   |
| Access Module Input/Output Buffers (AIB/AOB)                           | 94   |
| Access Module Parallel/Serial Registers (APR/ASR)                      | 95   |

Norsk Data ND-05.020.1 EN

---

## Page 8

# ACCP SOFTWARE

| Section | Description                                     | Page |
|---------|-------------------------------------------------|------|
| 5.3.1   | Octobus Messages                                | 102  |
| 5.3.2   | Console Monitor                                 | 104  |
| 5.3.3   | Interrupts                                      | 105  |
| 5.3.4   | AIB Flag Operation                               | 105  |
| 5.3.5   | AOB Flag operation                               | 105  |
| 5.3.6   | ACCP Messages to Microprogram                    | 106  |
| 5.3.7   | Microprogram Messages to ACCP                    | 106  |
| 5.3.8   | Memory Error                                     | 107  |
| 5.3.9   | ACCP Timeout                                     | 108  |
| 5.3.10  | ACCP Command Structure                           | 109  |
| 5.3.11  | ACCP Command Specifications                      | 110  |
| 5.3.12  | Echo Test (ECHO)                                 | 112  |
| 5.3.13  | Load System Parameters (LSYSPAR)                 | 112  |
| 5.3.14  | ACCP Microtrap (AMICTRAP)                        | 113  |
| 5.3.15  | Load Parameter Pointer (LPARP)                   | 114  |
| 5.3.16  | Verify Parameter Pointer (VPARP)                 | 114  |
| 5.3.17  | Load Control Store Directly (LOCSD)              | 114  |
| 5.3.18  | Load Control Store Via Memory (LOCSM)            | 115  |
| 5.3.19  | Dump Control Store Directly (DCSD)               | 116  |
| 5.3.20  | Dump Control Store Via Memory (DUCS)             | 117  |
| 5.3.21  | Dump Control Cache Directly (DCCD)               | 118  |
| 5.3.22  | Dump Control Cache Via Memory (DUCC)             | 119  |
| 5.3.23  | Start Microprogram (STARTMIC)                    | 120  |
| 5.3.24  | Stop Microprogram (STOPMIC)                      | 120  |
| 5.3.25  | Continue Microprogram (CONTMIC)                  | 121  |
| 5.3.26  | Alive Check (ALIVE)                              | 121  |
| 5.3.27  | Load MAR (LMAR)                                  | 122  |
| 5.3.28  | Load MIR (LMIR)                                  | 122  |
| 5.3.29  | Read MIR (RMIR)                                  | 122  |
| 5.3.30  | Test Buffer (TBUF)                               | 123  |
| 5.3.31  | Test Bus (TBUS)                                  | 123  |
| 5.3.32  | Read AIB16 (RAIB16)                              | 123  |
| 5.3.33  | Read AIB32 Directly (RAIB32D)                    | 124  |
| 5.3.34  | Read AIB32 Via Memory (RAIB32M)                  | 124  |
| 5.3.35  | Load AOB16 (LAOB16)                              | 125  |
| 5.3.36  | Load AOB32 Directly (LAOB32D)                    | 125  |
| 5.3.37  | Load AOB32 Via Memory (LAOB32M)                  | 126  |
| 5.3.38  | Read ASTS (RASTS)                                | 126  |
| 5.3.39  | Load MODE (LMODE)                                | 126  |
| 5.3.40  | Load CON (LCON)                                  | 127  |
| 5.3.41  | Write Multiport (WMPM)                           | 127  |
| 5.3.42  | Read Multiport (RMPM)                            | 127  |
| 5.3.43  | Test Multiport (TESTMPM)                         | 128  |
| 5.3.44  | Set Trace Selector (SETTRAC)                     | 128  |
| 5.3.45  | Loop (LOOP)                                      | 129  |
| 5.3.46  | Restart Microprogram (RESTMIC)                   | 129  |
| 5.3.47  | Enable Kicks (ENKICK)                            | 130  |
| 5.3.48  | Disable Kicks (DISKICK)                          | 130  |
| 5.3.49  | Reset CPU (CPURES)                               | 130  |

Norsk Data ND-05.020.1 EN

---

## Page 9

# 6 THE MEMORY MANAGEMENT SYSTEM (MMS) 137

## 6.1 Tasks
- 139

## 6.2 ND-5000 MMS Compared to ND-500/2 MMS
- 139

## 6.3 Memory Management Baby Card Overview
- 140

## 6.4 MMS Functional Description
- 141

### 6.4.1 Address Translation Using Logical Segment Number
- Program Segment Capability
  - 143
- Data Segment Capability
  - 143
- Physical Memory
  - 143
- Physical Segment Table
  - 144
- Process Registers
  - 147
- Translation Speed-up Buffer
  - 149
- TSB Addressing
  - 149

### 6.4.2 Address Translation Using Physical Segment Number
- 152

### 6.4.3 Special Mechanisms for Database Recovery Procedures
- 155

## 6.5 MMS Implemented on the ND-5000
- Memory References - (MEMR and MEMW)
  - 157
- Memory Management References - (MMSRA and MMSRW)
  - 157
- TSB Operations and Trap Clear (TSBC, TSBL, RPHYS and TRAPC)
  - 158
- Restrictions in Use of MMS
  - 159

## 6.6 Registers on the MMS Chip
- 160

# 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA) 165

## 7.1 General
- 167

## 7.2 The Instruction Address Controller (IAC)
- 169

### 7.2.1 Control of IAC from Microprogram
- 172

## 7.3 The Instruction Decode Unit (IDU)
- 173

### 7.3.1 Aligning
- 174

### 7.3.2 IDU Handling of ND-500 Instructions
- The Instruction Codes (INC)
  - 175
- The Address Codes (ADC)
  - 175
- The PREFIX
  - 176
- The Data Part (DPA)
  - 176

### 7.3.3 Microprogrammed READ/WRITE Registers in the IDU
- 177

### 7.3.4 Traps Residing in the IDU
- Illegal Codes
  - 179
- List Over Illegal Code Conditions
  - 179

## 7.4 The Data Address Controller (DAC)
- 181

### 7.4.1 DAC Function
- 184

### 7.4.2 DAC Pipeline Connection
- 185

### 7.4.3 Interpretation of the DAC Control Fields
- 186

Norsk Data ND-05.020.1 EN

---

## Page 10

# 7.4.4 Arithmetic Operations 187

# 7.4.5 Microprogram Controlled Addition 188

# 7.4.6 OCA Controlled Addition 189

# 7.4.7 The EASAVE Microfield 191

# 7.4.8 The Source and Destination Microfields 192

# 7.4.9 The IDUCA Bit 192

# 8 THE MICROINSTRUCTION CONTROLLER (MIC) 193

## 8.1 MIC Overview 195

## 8.2 Tasks of the Microinstruction Controller 196

## 8.3 Data Flow Inside the Sequencer 199

## 8.4 Sequence Control, General 202

## 8.5 Unconditional Sequence 205

### 8.5.1 Sequence Control, Unconditional Sequence 205

### 8.5.2 Stack Control, Unconditional Sequence 205

### 8.5.3 Example of Unconditional Sequence 206

## 8.6 Conditional Sequence 207

### 8.6.1 Sequence Control, Conditional Sequence 207

### 8.6.2 Stack Control, Conditional Sequence 208

### 8.6.3 Restrictions in Calling One-Instruction Subroutines 209

### 8.6.4 Conditional Branch in the Last Microcycle of a  
Macroinstruction 209

## 8.7 MIC and the EXUC Facility 210

### 8.7.1 Conditional Sequence and the EXUC 210

## 8.8 Exception Processing 211

### 8.8.1 MIC Behaviour During an Exception 211
- Descriptor Branch 212
- Constant Mismatch Branch 213
- Trap and Enable NOOP 213

## 8.9 X-bus Part of MIC 214

### 8.9.1 Description of the X-bus Part 215

### 8.9.2 I/O Commands 216

### 8.9.3 The MIC Status Register 217

### 8.9.4 Solo-mode Cycle Counter (SMCC) 217

### 8.9.5 Vector Register 218

### 8.9.6 Register File Address Register no. 1 (RFA1) 218

### 8.9.7 Register File Address Register no. 2 (RFA2) 218

### 8.9.8 Macrostatus Register (STS) 218

### 8.9.9 Trap Enable Register (TE) 219

### 8.9.10 Reading the Current Microaddress (CUR) 220

### 8.9.11 Micro-breakpoint Register (BRK) 220

### 8.9.12 Microsecond Counter (CNT32) 220

## 8.10 Addressing the Scratch Register File 221

### 8.10.1 Direct Addressing of the SRF 221

### 8.10.2 Indirect Addressing of the SRF 221

### 8.10.3 Loading the RFA Registers 221

### 8.10.4 Presetting the RFA Registers 222

### 8.10.5 The Signals RF1M8/RF2M8 222

### 8.10.6 Example of Read from the SRF 223

### 8.10.7 Example of Write to SRF 223

Norsk Data ND-05.020.1 EN

---

## Page 11

# Arithmetic Logic Unit and Working Register File

| Section | Title                                                         | Page |
|---------|---------------------------------------------------------------|------|
| 9       | Arithmetic Logic Unit and Working Register File               | 227  |
| 9.1     | Introduction                                                  | 229  |
| 9.2     | The ALU and Pipelining                                        | 232  |
| 9.3     | Selection of A-operand to ALU and X-register to DAC           | 233  |
| 9.4     | ALU Operations                                                | 234  |
| 9.5     | ALU Internal Status Bits                                      | 237  |
| 9.6     | Trap Enable Register                                          | 237  |
| 9.7     | Selection of Test Object                                      | 237  |
| 9.8     | The Q-Register                                                | 238  |
| 9.9     | The Working Register File (WRF)                               | 239  |
| 9.10    | WRF Position Bit                                              | 240  |
| 9.11    | Scaling of X-register                                         | 240  |
| 9.12    | Scaling Error Bit                                             | 241  |
| 9.13    | Bit Mask Generator                                            | 241  |
| 9.14    | Loop Counter                                                  | 242  |
| 9.15    | The Index Counters                                            | 243  |

# Additional Arithmetic Processor (AAP)

| Section | Title                            | Page |
|---------|----------------------------------|------|
| 10      | Additional Arithmetic Processor (AAP) | 245  |
| 10.1    | The ND-5000 AAP Concept          | 247  |
| 10.2    | AAP Control Fields               | 248  |

# ND-5000 Nanostates Descriptions

| Section | Title                                        | Page |
|---------|----------------------------------------------|------|
| 11      | ND-5000 Nanostates Descriptions              | 249  |
| 11.1    | The MIC Nanostates                           | 252  |
| 11.2    | The IDU Nanostates                           | 255  |
| 11.3    | DAC Nanostates                               | 261  |
| 11.4    | The DCC (Data Cache Controller) Nanostates   | 265  |
| 11.5    | MM (Memory Management) Nanostates            | 278  |
| 11.6    | MFBus Channel Controller (MFBCC) Nanostates  | 285  |

# Data Address Booster (IDAC)

| Section | Title                                        | Page |
|---------|----------------------------------------------|------|
| 12      | Data Address Booster (IDAC)                  | 289  |
| 12.1    | General                                      | 291  |
| 12.2    | Need for Improved Speed on Address Calculation | 293  |
| 12.3    | Penalty for Exceptions on Load/Store one Operand | 294  |
| 12.4    | Improvements by the IDAC Hardware            | 295  |
| 12.5    | Some Examples from Programs                  | 296  |
| 12.6    | IDAC Principal Operation                     | 297  |
| 12.7    | Address Calculations Done by the IDAC        | 298  |
| 12.8    | Microprogram implications                    | 298  |
| 12.8.1  | R-register and EXR-register                  | 298  |
| 12.8.2  | Use of B-register                            | 299  |

---

## Page 12

# Hardware Trace Module

## 13.1 Trace Module Memory
13.1.1 MIB Trace (ITACE) .................................. 303  
13.1.2 DB Trace (DTRACE) .................................. 304  
13.1.3 AOP Trace (ATHRACE) ................................  
13.1.4 Microprogram Address and Control Signals (CTRACE) .... 304  
13.1.5 Nanosequence State Trace (STRACE) ................... 305  

## 13.2 The Operational Control of the Trace Module
13.2.1 TRACMO: Trace Cycle Qualify ......................... 306  
13.2.2 TRACM(2,1): Trace Mode .............................. 306  
13.2.3 TRACM(4,3): Trigger Select .......................... 307  
13.2.4 Direct commands ..................................... 307  
13.2.5 Co-tracing with External Tracer ..................... 308  

Norsk Data ND-05.020.1 EN

---

## Page 13

# Description

This page contains an overview of the various ND Products introduced at Norsk Data.

## ND Products

| Product Name  | Description                                       |
|---------------|---------------------------------------------------|
| ND-05.020.1 EN| A technical manual describing ND Product functions|

---

## Page 14

# Table of Appendices

## Appendix 1: Multifunction Bus Hardware Units

309

## Appendix 2: Octobus Protocol Version 5

313

| Section | Title                                           | Page |
|---------|-------------------------------------------------|------|
| 2.1     | Octobus Overview                                | 315  |
| 2.2     | Introduction to Octobus hardware                | 315  |
| 2.3     | Octobus Frame Format                            | 317  |
| 2.4     | Introduction to the Protocol                    | 318  |
| 2.5     | Message Format                                  | 319  |
| 2.6     | Emergency Message                               | 321  |
| 2.7     | Kick Message                                    | 322  |
| 2.8     | Ident Message                                   | 322  |
| 2.9     | Multibyte Message                               | 323  |
| 2.10    | Octobus Hardware on the ND-5000 CPU             | 324  |
| 2.11    | Initiating the Octobus Device                   | 325  |

## Appendix 3: The ND-5000 Microinstruction Format

327

## Appendix 4: Modus Register

331

## Index

335

Norsk Data ND-05.020.1 EN

---

## Page 15

xv

| Section   | Page |
|-----------|------|
| 6 PROCESS SYNCHRONIZATION/COMMUNICATION | 9 |
| 6.1 Process Synchronization | 9 |
| 6.2 Event Variables | 9 |
| 6.3 Semaphores | 10 |
| 6.4 Monitor Calls | 11 |
| 6.5 Messages | 11 |
| 6.6 Shared Memory | 13 |

| 7 DISK FILES AND FILE SYSTEM | 15 |
| 7.1 Files and File Types | 15 |
| 7.2 The File Structure of SINTRAN III | 15 |
| 7.3 File Handling in SINTRAN III | 16 |
| 7.4 Directory System | 17 |

| 8 SYSTEM CONTROL AND ERROR HANDLING | 19 |
| 8.1 System Control | 19 |
| 8.2 Error Handling | 21 |

Norsk Data ND-05.020.1 EN

---

## Page 16

# Chapter 1 Introduction to the ND-5000

Norsk Data ND-05.020.1 EN

---

## Page 17

I'm sorry, the image you provided does not contain any text. Could you provide another image?

---

## Page 18

# Chapter 1 Introduction to the ND-5000

## 1.1 System Overview

The ND-5000 is a 32-bit general purpose supermini computer, and it is the high end of the range of Norsk Data computer systems.

![Figure 1. ND-5000 Computer System](image.png)

| Terminals |         | Modem               |
|-----------|---------|---------------------|
|           | ND-5000 |                     |
|           | computer|                     |
| Printers  |         | Mass storage devices|

*Figure 1. ND-5000 Computer System*

The standard ND-5000 system is delivered in a single cabinet version. An I/O expansion cabinet can be added if more interfaces or memory are required.

Norsk Data ND-05.020.1 EN

---

## Page 19

# Chapter 1 INTRODUCTION TO THE ND-5000

## 1.2 MODELS

The ND-5000 systems are available in the following types:

| System  | CPU type | CPU model | ND no. | Mic. prog. version ** | I/O processor | Disk size Internal | External | Streamer |
|---------|----------|-----------|--------|----------------------|---------------|--------|----------|----------|
| **COMPACT SERIES:** | | | | | | | | |
| ND-5200 | 1 | 2 | 110249 | 110(xxx) | ND-110 | Model A: | Model B: | Model A |
| ND-5400 | 2 | 4 | 110248 | 111(xxx) | ND-110/CX | 125Mb | Up to | only: |
| ND-5500 | 2 | 5 | 110247 | 112(xxx) | ND-110/CX | to | 1.8 Mb | |
| ND-5700 | 2 | 7 | 110218 | 113(xxx) | ND-120/CX | 4x125Mb | | 125 Mb |
| | | | | | | w/2 Mb | | |
| **LARGE SYSTEMS:** | | | | | | | | |
| ND-5200 | 1 | 2 | 110249 | 110(xxx) | ND-110 | | | |
| ND-5400 | 2 | 4 | 110248 | 111(xxx) | ND-110/CX | | | |
| ND-5500 | 2 | 5 | 110247 | 112(xxx) | ND-110/CX | | | |
| ND-5700 | 2 | 7 | 110218 | 113(xxx) | ND-120/CX | Max. 29 Gb of total internal/external disks | | |
| | | | | | | w/2 Mb | | |
| ND-5800 | 3 | 8 | 110171 | 114(xxx) | ND-120/CX | | | |
| | | | | | | w/4 Mb | | |
| ND-5900* | 3 | 8 | 110171 | 114(xxx) | ND-120/CX | | | |
| | | | | | | w/4 Mb | | |

* Model 5900 contains 2, 3 or 4 CPUs

*Table 1. ND-5000 Models*

**Valid for SINTRAN K, WM 406.**

Norsk Data ND-05.020.1 EN

---

## Page 20

# Chapter 1 INTRODUCTION TO THE ND-5000

## 1.3 ND-5000 CABINET VERSIONS

The ND-5000 is delivered in either a large or a compact cabinet. This section gives a short description of the two cabinets, the card crates etc.

## 1.4 ND-5000 LARGE CABINET

The large ND-5000 cabinet is illustrated in figure 2.

| Component                          |
|------------------------------------|
| Top fan units                      |
| Power units                        |
| Fan unit                           |
| Plug panel devices and terminals (8-terminal cards) |
| Bus bar with ground, 5V, 12V and 5V standby |
| Slimline streamer 40 or 60 Mbyte   |
| 5 1/4" floppy disk 1.2 Mbyte       |
| Operator panel with telefix adaptor Display panel |
| MFbus card rack with SAMSON CPU    |
| ND-110 card rack                   |
| Fan unit                           |
| AC distribution                    |

*Figure 2. ND-5000 Cabinet*

Norsk Data ND-05.020.1 EN

---

## Page 21

# Chapter 1 INTRODUCTION TO THE ND-5000

| Card Position | Card Type                | Comments                                                                                                                                       |
|---------------|--------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|
| 1             | MFbus Controller (5465 or 5454) |                                                                                                                                                |
| 2             | MFbus Port (5155)        |                                                                                                                                                |
| 3             | Ports or Memory by Choice |                                                                                                                                                |
| 4             |                          |                                                                                                                                                |
| 5             | ND-5000 CPU 4            | Pos. 5 - 8                                                                                                                                      |
| 6             |                          |                                                                                                                                                |
| 7             |                          |                                                                                                                                                |
| 8             |                          |                                                                                                                                                |
| 9             |                          | CPUs 2 - 4 are optional, and these positions can be occupied by memory or ports.                                                               |
| 10            | ND-5000 CPU 3            | Pos. 10 - 13                                                                                                                                   |
| 11            |                          |                                                                                                                                                |
| 12            |                          |                                                                                                                                                |
| 13            |                          |                                                                                                                                                |
| 14            |                          |                                                                                                                                                |
| 15            | ND-5000 CPU 2            | Pos. 15 - 18                                                                                                                                   |
| 16            |                          |                                                                                                                                                |
| 17            |                          |                                                                                                                                                |
| 18            |                          |                                                                                                                                                |
| 19            |                          |                                                                                                                                                |
| 20            | ND-5000 CPU 1            |                                                                                                                                                |
| 21            |                          | └── CPU type 1: pos. 20 and 21                                                                                                                 |
| 22            |                          | ├── CPU type 2: pos. 20 - 22                                                                                                                   |
| 23            |                          | └── CPU type 3: pos. 20 - 23                                                                                                                   |
| 24            |                          |                                                                                                                                                |

Table 2. ND-5000 Large Cabinet Card Rack

Norsk Data ND-05.020.1 EN

---

## Page 22

# Chapter 1 INTRODUCTION TO THE ND-5000

## 1.5 ND-5000 COMPACT

Figure 3 shows the ND-5000 Compact cabinet with its main modules.

- Power and signal distribution
- Extra plug panel for 3 free positions
- Siniline streamer 40 or 60 Mbyte
- 5 1/4" floppy disk 1.2 Mbyte
- Display panel
- Power supply and battery backup
- Operator panel with telefax adaptor
- Up to four fixed disks of 74 or 150 Mbyte each
- Fan unit (10 fans)
- Bus bar with ground, 5V, 12V and 5V standby
- Backwiring
- 3 or 4 positions for ND-500 size cards including SAMSON CPU
- Strain relief
- 12 positions for ND-110 size cards

*Figure 3. ND-5000 Compact Cabinet*

Norsk Data ND-05.020.1 EN

---

## Page 23

# Chapter 1 INTRODUCTION TO THE ND-5000

Table 3 shows the ND-5000 in a double-bus backwiring used in a Compact cabinet version B.

## THE ND-5000 COMPACT CARD RACK

| Card Pos. | Card Type                                 | Comments                            |
|-----------|-------------------------------------------|-------------------------------------|
| 1         | ND-5000 CPU card                          |                                     |
| 2         |                                           | CPU type 1: pos. 1 and 2            |
| 3         | (MFbus Dynamic RAM)                       | CPU type 2: pos. 1 - 3              |
| 4         | MFbus Dynamic RAM                         | 4, 8 or 16 Mbyte Dynamic RAM        |
| 5         | Double Bus Controller                     |                                     |
| 6         | ND-110 CPU                                |                                     |
| 7         | Tracer/Memory/Ethernet/(Token ring)       |                                     |
| 8         | HDLC/Megalink/Memory/Ethernet/(Token ring)|                                     |
| 9         |                                           |                                     |
| 10        | 8 term./PIOC/Memory                       |                                     |
| 11        |                                           |                                     |
| 12        |                                           |                                     |
| 13        | Floppy & SCSI Controller                  |                                     |
| 14        | Free                                      |                                     |
| 15        | Free                                      |                                     |
| 16        | Free                                      |                                     |
| 17        | Free                                      |                                     |
| 18        | Plug board 1                              |                                     |
| 19        | Plug board 2                              |                                     |
| 20        | Plug board 3                              |                                     |

*Table 3. The ND-5000 Compact Card Rack — new type*

Norsk Data ND-05.020.1 EN

---

## Page 24

# Chapter 1 INTRODUCTION TO THE ND-5000

## 1.6 New Multifunction Bus System

The ND-5000 CPU is placed directly in the Multifunction bus (MFbus) card rack. See tables 2 and 3 for the positioning of the CPU(s).

The multifunction bus (MFbus) system is the follow-up to the MPM-5 system. It has several new features, in addition to all the functional features of the MPM-5 system. The most important new feature is the Octobus, a serial message bus for communication and test purposes (see page 26).

Appendix 1 on page 311 contains more information on the MFbus hardware.

## 1.7 ND-5000 CPU

The main tasks of the ND-5000 CPU are:

- Fetch macroinstructions from the MFbus memory
- Decode the macroinstructions to executable microinstructions
- Execute the microinstructions
- Return the computed results to memory

The CPU has a four-level pipelined instruction flow. This means that the CPU can handle four microinstructions at the same time. This is possible by splitting each microinstruction into four parts and letting each part be handled by specialized hardware. Chapter 2 starting on page 33 describes this in detail.

Norsk Data ND-05.020.1 EN

---

## Page 25

# 1.7.1 CPU Types

The ND-5000 CPU consists physically of:

- A mother board
- One to three layers of baby cards

The baby cards are placed on the mother card in a sandwich construction. The first layer of baby cards contains hardware to increase the CPU performance.

---

## ND-5000 Basic CPU Type 1

The CPU type 1 module covers the CPU model 2 (ND-5200 system). The CPU type 1 consists of two layers of cards:

- 1st layer: Mother board
- 2nd layer: ALU, IDA, MMS, CS, MIC, ACCP

| Part no. | Module |
|----------|--------|
| 324602   | MB - Mother board |
| 324701   | MM - Instruction/data memory-management controller |
| 324702   | ACCP - Access processor |
| 324704   | ALU - Arithmetic logical unit |
| 324707   | CS - Control store - 16K |
| 324708   | IDA - Instruction/data address controller |
| 324709   | MIC - Microinstruction controller |

Norsk Data ND-05.020.1 EN

---

## Page 26

# Chapter 1 INTRODUCTION TO THE ND-5000

---

## ND-5000 BASIC CPU TYPE 2

CPU type 2 covers the CPU models 4, 5 and 7 (ND-5400, ND-5500 and ND-5700 systems). CPU type 2 consists of three layers:

- 1st layer: Mother board
- 2nd layer: CACHE, ALU
- 3rd layer: AAP, IDA, MMS, CS, MIC, ACCP

Mother board —> Mother board with 1st layer of baby modules —> Mother board with 2nd layer of baby modules

*Figure 5. Layout CPU type 2*

| Part no. | Module                                                  |
|----------|---------------------------------------------------------|
| 324602   | MB - Mother board                                       |
| 324701   | MMS - Instruction/data memory-management controller     |
| 324702   | ACCP - Access processor                                 |
| 324704   | ALU - Arithmetic logical unit                           |
| 324707   | CS - Control store                                      |
| 324708   | IDA - Instruction/data address controller               |
| 324709   | MIC - Microinstruction controller                       |
| 324710   | CACHE - Instruction/data cache module                   |
| 324715   | AAP - Additional arithmetic processor                   |

Norsk Data ND-05.020.1 EN

---

## Page 27

# ND-5000 BASIC CPU TYPE 3

CPU type 3 covers the CPU model 8 (ND-5800 and ND-5900 systems). CPU type 3 consist of four layers:

1st layer: MB  
2nd layer: CACHE, ALU  
3rd layer: AAP, IDA, MMS, CS, MIC, ACCP  
4th layer: IDAC  

| Part no. | Module                                |
|----------|---------------------------------------|
| 324603   | MB - Mother board                     |
| 324701   | MMS - Memory management controller    |
| 324702   | ACCP - Access processor               |
| 324704   | ALU - Arithmetic logical unit         |
| 324707   | CS - Control store - 16K              |
| 324718   | IDA - Instruction/data address contr. |
| 324709   | MIC - Microinstruction controller     |
| 324717   | CACHE - Instruction/data cache module |
| 324714   | IDAC - I-level data address controller|
| 324715   | AAP - Additional arithmetic processor |

*Figure 6. Layout CPU type 3*

Norsk Data ND-05.020.1 EN

---

## Page 28

# Chapter 1 INTRODUCTION TO THE ND-5000

## DIFFERENCE BETWEEN THE CPU TYPES

CPU types 1 and 2 use the same mother board and baby modules. On CPU type 1, the cache and AAP baby modules are removed. On the ND-5200 CPU, floating-point operations are performed by the microprogram.

On CPU type 3, the mother board and the cache and IDA baby module are unique to this CPU type. The rest of the baby modules are the same as used on CPU types 1 and 2. In addition, the IDAC 'booster' module is special for this CPU type which is used in ND-5800 and ND-5900 systems.

The following table shows the parameters that identify the different models.

| ND-5000 system: | CPU type: | Enabled function: | Disabled function: | Master clock speed: |
|-----------------|-----------|-------------------|--------------------|---------------------|
| ND-5200         | 1         |                   |                    | Normal (70 ns)      |
| ND-5400         | 2         | Instr.cache       | Data cache         | Slow (156 ns)       |
|                 |           | SIFGOC            | Addr.cache         |                     |
| ND-5500         | 2         | Data cache        | Addr.cache         | Slow (156 ns)       |
|                 |           | Instr.cache       | WICO               |                     |
|                 |           | SIFGOC            |                    |                     |
| ND-5700         | 2         | Data cache        | WICO               | Normal (70 ns)      |
|                 |           | Instr.cache       |                    |                     |
|                 |           | Addr.cache        |                    |                     |
|                 |           | SIFGOC            |                    |                     |
| ND-5800         | 3         | Data cache        |                    | Normal (70 ns)      |
|                 |           | WICO              |                    |                     |
|                 |           | Instr.cache       |                    |                     |
|                 |           | Addr.cache        |                    |                     |
|                 |           | SIFGOC            |                    |                     |

*Table 4. Differences Between CPU models*

SIFGOC : Smart IFGO Control (Smart IFGO strategy enabled)  
WICO : Write In Cache Only (*Write once* strategy *(dirty)*)

Norsk Data ND-05.020.1 EN

---

## Page 29

# 1.7.2 CPU Functional Overview

The CPU colour block diagram on the next page shows the logical structure of the ND-5000 CPU. It also shows where the logical parts belong physically. The sections from page 17 to page 23 describes the CPU colour diagram.

Using different colours on the buses, you can see which buses are active at the different pipeline levels. Buses that are uncoloured are not pipeline related. Chapter 2 on page 33 explains the pipeline concept in detail.

---

![ND-5000 CPU Diagram](https://example.com/cpu-diagram)

- **ND-100 Bus**
  - ND-120 CPU
  - I/O controllers
  - Disk
  - Printers/terminals
  - MFbus driver + OCTOBUS
  - Private memory
  - Shared memory

- **OCTOBUS**

- **MFbus Port**

- **Access Module**
  - Instruction decode unit
  - Instruction address controller
  - Instruction memory management
  - Instruction cache
  - Control store
  - Data address controller
  - Data memory management
  - Data cache
  - Register block
  - Arithmetic logic unit
  - Additional arithmetic processor

- **ND-5000 CPU**

Norsk Data ND-05.020.1 EN

---

## Page 30

# CPU Block Diagram Data Flow

## Symbol Guide

| Symbol                                  | Description                           |
|-----------------------------------------|---------------------------------------|
| ![Baby Card, 1st layer](#)               | Baby Card, 1st Layer                  |
| ![Baby Card, 2nd layer](#)              | Baby Card, 2nd Layer                  |
| Unmarked                                | Mother Card                           |
| ![Optional](#)                          | Optional                              |
| ![Gate Array](#)                        | Gate Array                            |
| ![Bidirectional Tri-State Bus](#)       | Bidirectional Tri-State Bus           |
| ![Input Only](#)                        | Input Only                            |
| !["Totem Pole" (Tri-State) Output](#)   | "Totem Pole" (Tri-State) Output       |
| ![Tri-State Output](#)                  | Tri-State Output                      |
| ![Clocked Pre-Line Reg.](#)             | Clocked Pre-Line Reg.                 |

## Pipeline Levels

| Level                                   | Description                           |
|-----------------------------------------|---------------------------------------|
| ![Instruction Cycle](#)                 | Instruction Cycle                     |
| ![Data Cycle](#)                        | Data Cycle                            |
| ![ALU Cycle](#)                         | ALU Cycle                             |
| ![Result Cycle](#)                      | Result Cycle                          |
| Unmarked                                | Not Pipeline Related                  |

## Abbreviations

| Abbreviation  | Description                                  |
|---------------|----------------------------------------------|
| AAP           | Additional Architectural Processor           |
| AAPA          | Additional Architectural Processor A-Operand |
| AAPB          | Additional Architectural Processor B-Operand |
| AAC           | Additional Architectural Processor ACCU      |
| ACC           | Address Code                                 |
| ACCP          | Access Module Processor                      |
| ACM           | Address Code                                 |
| ACT           | Access Module Code Test                      |
| AD-BUS        | Access Module Data Bus Memory                |
| AST           | Access Module Shadow Register                |
| ARG           | Access Module Address Buffer                 |
| ASR           | Access Module Address Register               |
| BADAP         | BAD Function Transceiver                     |
| BA            | BAD Function Address Buffer                  |
| CAC           | Cache                                        |
| CSA           | Control Store Address                        |
| CS            | Control Store                                |
| CT            | Control Store Transceiver                    |
| CW            | Control Word                                 |
| DCT           | Data Cache Transceiver                       |
| DCC           | Data Cache Control                           |
| DLA           | Data Load Address                            |
| DLC           | Data Load Cache                              |
| DLAD          | Data Load Address Driver                     |
| DRL           | Data Ready Register                          |
| IDC           | Instruction Decoder                          |
| IFC           | Interface Control                            |
| IMM           | Instruction Memory Management                |
| IRL           | Instruction Release Latch                    |
| ISA           | Interface SELECT Address Driver              |
| M1BT          | Monitor Integrity Buffer Test                |
| MF-BUS        | Master Function Bus                          |
| MIB           | Monitor Integrity Buffer                     |
| MIC           | Micro Instruction Controller                 |
| MPR           | Monitor Program Register                     |
| OCTC          | Output Control Transceiver                   |
| RAM           | RAM Memory                                   |
| REG           | Regular                                      |
| ROM           | ROM Memory                                   |
| TAT           | Test Address & Transfer                      |
| TSB           | Transfer Stack Buffer                        |

This diagram shows the flow and organization of a CPU's data processing, with various modules and interconnections described above.

---

## Page 31

# Mother Board

All the uncoloured blocks on the diagram are physically placed on the mother board. The mother board is an ND-500 size card, and is the physical base for the ND-5000 CPU. It contains connectors for the baby cards, the interface to the multifunction bus and some control logic. The interface to the multifunction bus consists of the Bus Adapter (BADAP) gate array, buffers and transceivers.

# Interface Between the ND-5000 and Its Surroundings

The leftmost part of the colour diagram outlines the hardware parts that communicate with the world outside of the ND-5000 CPU. The main parts are:

- Access module (ACCP)
- Memory interface (MFbus channel controller)

# Access Module

The access module (ACCP) is a baby card which consists of the octobus controller (gate array) and the access processor (MC68000). This baby card is the interface, via the octobus, to the outside world. The octobus is used as a message bus between the ND-5000, the ND-120, and DMA devices in the multifunction bus environment. Compared to former ND-100/ND-500 systems, the octobus replaces two hardware units:

- ND-500 interface card in the ND-100
- ND-100 interface on the Control II card in the ND-500

The access module also has an RS232 line for test and maintenance purposes.

The ND-5000 microprogram communicates with the access module through the following:

- Access module input buffer (AIB)
- Access module output buffer (AOB)
- Access module parallel/serial registers (APR/ASR)

Norsk Data ND-05.020.1 EN

---

## Page 32

# Memory Interface

The multifunction bus (MFB) memory interface consists of the bus adapter (BADAP) gate array, and a number of 32-bit registers:

- The Instruction Address Buffer (IAB) holds one 32-bit physical instruction memory address.

- The Data Address Buffer (DAB) holds one 32-bit physical data memory address.

- The Instruction Transmit Latch (ITL) holds up to 32 bits that are to be written to the instruction memory.

- The Instruction Receive Latch (IRL) holds one 32-bit word read from the instruction memory.

- The Data Transmit Latch (DTL) holds up to 32 bits that are to be written to the data memory.

- The Data Receive Latch (DRL) holds one 32-bit word read from the data memory.

---

## Page 33

# Macroinstruction Decoding and the Instruction Cache

When 32-bit data from the instruction memory enters the MIB-bus, it is handled by the instruction address controller (IAC), the instruction decode unit (IDU) and the instruction memory management (IMM).

The instruction address controller (IAC) contains:

- The Program Counter (PC, or the P-register) that points to the start of the macroinstruction currently executed by the A-level of the execution pipeline.

- The Saved P-register (SP) that points to the start of the macroinstruction currently executed by the F-level of the execution pipeline.

- The New Program Counter (NPC) that points to the start of the macroinstruction currently executed by the M-level of the execution pipeline. NPC points to each operand in turn, when multioperand macroinstructions are executed. PC or SP only point to beginnings of macroinstructions.

- The Link register (L) that keeps subroutine return addresses.

- A few scratch registers (S and Y) to keep intermediate data produced by the adder inside the instruction address controller.

- A 32-bit adder to calculate instruction addresses.

The instruction decode unit (IDU) contains:

- The High Limit (HL) and Low Limit (LL) registers, to allow address trap mechanisms.

- Two 32-bit buffer registers, to hold two words from instruction memory.

- The Trap Enable register (TE), for the status register bits residing inside the IDU.

The IMM translates the 32-bit logical instruction addresses to physical addresses. This requires a translation speedup buffer (TSB).

To assist the IDU and IAC during the unpacking of the instruction stream, the instruction map (IMAP) and the operand map (OMAP) are used. Both these maps are PROM memory. They are addressed by the IDU, and contain information about the instruction opcodes and operands respectively.

Norsk Data ND-05.020.1 EN

---

## Page 34

# Chapter 1 INTRODUCTION TO THE ND-5000

When one instruction and its first operand have been unpacked, they are saved in the instruction cache system at the address given by the address of the instruction. Operands after the first are saved in instruction cache system addresses that correspond to each operand. When the same macroinstructions are to be executed again, this can be done directly from the instruction cache system, and no unpacking is necessary.

The instruction cache system is addressed by the operand logical address bus (OLA). OLA is usually driven by the instruction address register (IAR) (sometimes from the OLA-hold register, that is saving the two most recently used IAR contents). The instruction cache system, as you can see in the fold-out CPU colour diagram, is organized in this way:

- **Operand Cache (OC)** contains characteristics about the operand.
  
- **Instruction Cache (IC)** contains necessary information about the macroinstruction:

  - Instruction characteristics (ICHAR), retrieved from IMAP

  - OPTYP indicates floating/integer and data path width (8, 16, 32 bits)

  - Register number in instruction opcode (RIN)

- **Control word Cache (CC)**, has only meaning when the instruction-cache entry represents a macroinstruction, and not just an operand. It contains the first microinstruction used to execute the macroinstruction.

- **Address Cache (AC)** contains the logical data address needed by the operand. This address was calculated when the operand was unpacked and written into the instruction cache.

Norsk Data ND-05.020.1 EN

---

## Page 35

# Data Address Generation and the Data Cache

The data address controller (DAC) calculates all logical data addresses. When data memory needs to be read or written, these addresses are translated to physical addresses by the data memory management (DMM) module.

The data address controller contains:

- The B-register
- The R-register
- Four effective Address registers (EAn) to remember data addresses that have been used
- 32-bit adder to calculate data addresses

Addresses calculated in the DAC are clocked into the DAC register (DACR). DACR is used as source for the data logical address bus (DLA). DLA addresses the data cache. Whenever a new address is presented on the DLA bus, the previous DLA is remembered in the DLA hold (DLAH) register. DLAH is used as DLA source when the previous DLA is needed. DLA is also used for +4 address when word crossing occurs. The write buffer address (WBA) register holds the address of a cache entry which is to be written. The use of the data cache is explained in detail in chapter 3 on page 47.

Data read from the data cache or from data memory can need byte alignment. When bytes are not properly aligned already, the data is passed through the data alignment logic (DAL).

# Arithmetic Logic Unit and Working Register File

The arithmetic logic unit (ALU) and the working register file (WRF) are placed on one baby card with three gate arrays:

- One ALU gate array
- Two WRF gate arrays

The ALU does arithmetical and logical operations. It can select information from seven groups of sources, one of them the working register file.

The ALU of the ND-5000 CPU has two input registers (A and B) that hold the input values that an ALU function is to be performed on. The result is available in the F-register, that can drive the F-bus (result bus). A few registers are also situated in the ALU gate array, but most of the CPU registers are situated in the working register file (WRF) gate arrays. Two similar gate arrays are used, each containing 16 bits. The registers in the WRF have

Norsk Data ND-05.020.1 EN

---

## Page 36

# Chapter 1 INTRODUCTION TO THE ND-5000

two read ports and one write port, so that two registers can be read and one register written at the same time. The following WRF registers exist:

- Four index registers used for integer arithmetic (X1, X2, X3 and X4)
- Four floating registers (A1, A2, A3, A4)
- Four extended floating registers (E1, E2, E3, E4)
- Twelve scratch registers to be used by the microprogram.

When the result of an ALU operation is to be written to a destination outside the ALU or the WRF, the result data must be passed through the write buffer data (WBD) latch. The WBD also acts as a buffer for data that is waiting for a chance to be written into the data cache. Cache data in WBD has its corresponding cache address in the WBA register.

## MICROPROGRAM AND MICROINSTRUCTION CONTROLLER

The microinstruction controller (MIC) is one of the sources for microprogram addresses. It contains a shallow stack for microsubroutine return addresses, and facilities for conditional sequencing. The MIC also serves as address generator for the scratch register file (SRF). This contains 4K words of 32-bit width, and is used by the microprogram to hold variables that WRF does not have space for. In addition, the MIC holds the solo-mode cycle counter, and a part of the macrostatus register.

The microprogram is 128 bits wide, and is addressed by a 16-bit address (giving a maximum depth of 64K). The address for a microprogram word can come from:

- The Control Word (CW)
- The Instruction MAP (IMAP)
- The Microinstruction Controller (MIC)

The microprogram word is driven onto the control store address bus (CSA), and clocked into the microword address register (MAR). When the addressed microword presents itself on the control word (CW) bus, it is clocked into the microinstruction register (MIR).

---

## Page 37

# Chapter 1 INTRODUCTION TO THE ND-5000

## ADDITIONAL ARITHMETIC PROCESSOR

On high-performance models of the ND-5000, an additional arithmetic processor (AAP) is provided. The AAP is coupled in parallel with the arithmetic logic unit (ALU), and uses the same buses as the ALU.

## MICROPROGRAMMED FLOATING POINT

The ND-5000 CPU can also be supplied with microprogrammed floating point. Instead of using hardware cards, the floating point facility is obtained by the microprogram in the Control Store. This facility is quite slow compared to hardware floating point, but is sufficient for most ADP/OA applications.

---

## Page 38

# 1.8 I/O Processor (ND-120)

The ND-120 CPU has the following tasks:

### I/O Operations

The ND-120 controls all I/O operations between the ND-5000 CPU or memory and the peripherals such as hard disks, floppy disks, magnetic tape drives, streamers (cassette tapes), terminals and printers.

### Timesharing

The ND-120 controls timesharing and supervises all available resources, such as I/O, memory and the ND-120 CPU.

### Run programs

The ND-120 runs:

- Maintenance diagnostics on the ND-5000 processor, local or remote via dial-up modem (TELEFIX)
- SINTRAN Virtual Storage Extended operating system for real-time, timesharing, local and remote batch processing in 16 programming languages
- Local ND-120 jobs

# ND-120 Processor

The ND-120 processor is a microprogrammed 16-bit CPU, which has 16 interrupt levels, vectored interrupt I/O system, memory management system (MMS) and cache memory. A microprogrammed self-test and operator controlled routines are included for debugging (Microprogrammed Operators Communication MOPC).

# Harddisk Controller

The harddisk controller handles Error Correction Code (ECC) and Direct Memory Access (DMA). It comes in versions with a 10 MHz or a 15 MHz transfer rate.

# Floppy and Streamer

The floppy and streamer controller is a microprocessor-based controller. Data is transferred in DMA mode and can be converted to/from several formats.

Norsk Data ND–05.020.1 EN

---

## Page 39

# Chapter 1 INTRODUCTION TO THE ND-5000

## MULTIFUNCTION BUS LINE DRIVER

The Multifunction Bus Line Driver contains an octobus controller gate array and differential line transceivers for transfer between the multifunction bus system, the ND-120 processor and DMA controllers. The octobus is used for control information, status information and test information to and from the ND-5000 CPU.

---

Norsk Data ND-05.020.1 EN

---

## Page 40

# 1.9 Communication with the ND-120

The ND-5000 communicates with the ND-120 through the octobus and the shared memory on the multifunction bus, as shown in figure 8.

```
Octobus
|                 |                          |
+-------------+   +--------------------+     +---------------------------+
|   ND-120    |   |   Multi-           |     |  Octobus interface        |
|   I/O       |   |   function         |     |  Access processor         |
|             |   |   bus              |     |  ND-5000 CPU              |
+-------------+   |   memory           |     |  Multi-function           |
                  +--------------------+     |  bus channel controller   |
                                             +---------------------------+

                            Multifunction bus

                             Figure 8. Bus Interface
```

In the communication, the octobus is used by the ND-5000 or the ND-120 to inform the other processor that there are commands and data in the mailbox.

The ND-5000 is connected to the octobus via the octobus controller on the Access Module, and to the multifunction bus via the MFbus channel interface (MPCC) on the mother board.

# 1.10 Memory

**Shared memory** The ND-120 and the ND-5000 processors can exchange code and data in the multifunction bus system, where both processors have access to the shared memory. This allows easy access and control by all components of the system.

Direct Memory Access (DMA) devices, such as disks and magnetic tape drives, can also access the shared memory via the same memory channel as the ND-120, or have their own separate ports direct to the shared memory.

**Local memory** In addition to the shared memory, the ND-120 can have its own local memory. This memory is part of the SINTRAN address space, but it cannot be reached by ordinary programs in the ND-5000 processor. The local memory is installed in the ND-120 bus.

Norsk Data ND-05.020.1 EN

---

## Page 41

# 1.11 Mass Storage

Mass storage is used for different purposes:

- Floppy disks are used for personal backup, mailing of new software and for tests.

- Winchester-type disks are used for online programs and data.

- Finally, magnetic tapes and removable hard disks are used to produce safety copies (backup) of programs and data.

---

## Page 42

# 1.12 Input/Output (I/O)

The ND-120 serves as an I/O processor both for itself and for the ND-5000. The physical I/O connections are made to the ND-120. I/O requests from the ND-5000 are put in a mailbox area in the ND-120 memory, and the ND-120 is activated to handle the request.

Cards with interfaces and controllers for terminals, printers and communication lines are also connected to the ND-120 bus. Information about these is found in the ND-120 Functional Description (ND-06.015) and in the service handbook.

Norsk Data ND-05.020.1 EN

---

## Page 43

# Chapter 1 INTRODUCTION TO THE ND-5000

## 1.13 ND-5000 HIGHLIGHTS

### Architecture and implementation:

- The ND-5000 is based on the ND-500 system architecture and uses the same instruction set.
- The physical implementation of the ND-5000 CPU is completely different from earlier systems.
- The ND-5000 CPU module is a sandwiched construction and occupies only four card positions in the card rack.

### Technology:

- New technology is used in several areas.
- Very dense CPU packaging, which means shorter signal distance.
- Physical CPU size is only one sixth of the size of the ND-570.
- Extensive use of CMOS technology reduces the power consumption by a factor of five.
- ND-5000 has 11 gate arrays (semi-custom VLSI).
- RAM capacity expanded 16 times on the same space. This is done by faster and more dense RAMs, and a 1:4 improvement in memory array size by SIP (single in-line packaging).

### Performance:

- Maximum performance for one CPU is 6-7 MIPS.
- System performance rates up to 28 MIPS (ND-5900 model 4 with four CPUs) depending on the model.

### Microprogram and control store:

- The microprogram is new compared to the ND-500/1 and ND-500/2.
- Larger writable control store for microprogram expansion. Can be expanded to 64Kword (standard is 16Kword).

*Norsk Data ND-05.020.1 EN*

---

## Page 44

# Chapter 1 INTRODUCTION TO THE ND-5000

## Memory management and cache:

- Updating of the translation speedup buffer in the memory management system does not require a restart of the instruction.

- The data cache has a *write once* strategy. This means that on multiple write operations to the same memory location, only the first write operation is written both in the cache and in the memory. The others are allowed to be written only in the cache. The final updating of the memory is done when the process is terminated.

- The instruction cache is different from that in the ND-500. In the ND-5000, instructions are cached after they are decoded. The instruction cache has a very wide code (about 320 bits).

## Memory system:

- The memory system is now based on the multifunction bus (MFbus) system. MFbus is basically the same as the MPM-5 system, but has some additional features for supporting the Octobus. Octobus is a new high-speed serial command bus used for efficient internal system signal/command transfer.

- The ND-5000 CPU is a plug-in module to the multifunction bus system; it is put directly in the multifunction bus card rack.

## Test and maintenance:

- There is an Access Processor (MC68000) for communication with the outside world, and for bootstrapping and testing.

- Large trace capacity on-board. Trace memory is 160 bits x 4K.

- ECO levels of cards can be read from a terminal, locally or remote, together with configuration data and print versions.

Norsk Data ND-05.020.1 EN

---

## Page 45

# Chapter 2 The Microinstruction Pipeline System

Norsk Data ND-05.020.1 EN

---

## Page 46

I'm sorry, but the page you provided appears to be blank except for the page number and a reference. There is no text to convert to Markdown. If there's another page or image, feel free to share it!

---

## Page 47

# Chapter 2 The Microinstruction Pipeline System

To increase the processing speed, the ND-5000 CPU is designed as a four-level pipeline system. Pipelining means splitting a task into smaller pieces, more or less independent of each other. Each piece is handled by a specialized processor part that is defined as a certain level in the pipeline. A processor part on one level sends its result to the next processor part in the line, and starts a new job, thereby forming a pipeline.

Figure 7 on page 15 shows, in colour, the pipeline influence on the CPU hardware.

## 2.1 Execution Hierarchy

| Instructions | Description |
|--------------|-------------|
| Macroinstructions | The ND-5000 CPU executes macroprograms. Each macroinstruction is executed by a number of microinstructions. |
| Microinstructions | A macroinstruction needs at least as many microinstructions as the number of operand accesses done by the macroinstruction. |
| Nanocycles | Each microinstruction consists of one or more nanocycles. The nanostate sequencers control how many nanocycles each microinstruction needs. There are seven nanostate sequencers in the CPU, controlling the following hardware: |
| | 1. The Data Memory Management (DMM) |
| | 2. The Instruction Memory Management (IMM) |
| | 3. The Instruction Decode Unit (IDU) |
| | 4. The Data Address Controller (DAC) |
| | 5. The MicroInstruction Controller (MIC) |
| | 6. The Data Cache Controller (DCC) |
| | 7. The Multifunction Bus Channel Controller (MFBCC) |

Norsk Data ND-05.020.1 EN

---

## Page 48

# Full-speed execution

A macroinstruction is executed at full speed if one micro-instruction corresponds to one nanocycle.

The ND-5000 microarchitecture allows the most frequently used macroinstructions to be executed by only one microinstruction.

Full-speed execution depends on several factors:

- **Instruction Cache hit**

  The macroinstructions to be executed must be found in the Instruction Cache.

- **Address Cache hit**

  The data addresses must be the same each time the same instruction is executed.

- **Data Cache hit**

  The data to be used must be found in the Data Cache.

- **Direct addressing mode**

  The data addressing modes must be direct, not indirect or indexed (they can be indexed, but not post-indexed indirect, in the ND-5800).

- **No data collisions**

  It must not be necessary to wait for instructions to finish before later instructions can start.

# Execution delay

The execution is delayed when a pipeline conflict or a non-optimized situation, like the situations mentioned above, occur. Extra nanocycles are then inserted to solve the problem.

---

Norsk Data ND-05.020.1 EN

---

## Page 49

# Chapter 2 The Microinstruction Pipeline System

## 2.2 Pipeline Levels

A macroinstruction is processed by flowing through the different pipeline levels:

```
+------------------------+
| General macroinstruction|
+------------------------+
                      |
Processed             |
in four               |
parts                 |
                      v
+----------------+ +--------------+ +-------------+ +------------+
| Instruction    | | Operand      | | ALU         | | Result     |
| fetch          | | fetch        | | operations  | | write      |
+----------------+ +--------------+ +-------------+ +------------+
   Level 1          Level 2        Level 3         Level 4
```

*Figure 9. Pipeline Processing*

The pipeline flow, with succeeding instructions, looks like this:

```
Macroinstruction
number ─┬─ ─┬─ ─┬─ ─┬─ 

Level 1  1   2   3   4  ...

Level 2     1   2   3   4  ...

Level 3         1   2   3   4  ...

Level 4             1   2   3   4
```

*Figure 10. The Pipeline Instruction Flow*

The four pipeline levels in ND-5000 are summed up in table 5.

| Level no. | Level name            | Abbr. | Task              |
|-----------|-----------------------|-------|-------------------|
| Level 1   | The instruction level | I     | Instruction fetch |
| Level 2   | The data level        | M     | Operand fetch     |
| Level 3   | The ALU level         | A     | ALU operations    |
| Level 4   | The result level      | F     | Result write      |

*Table 5. The ND-5000 Pipeline Levels*

Norsk Data ND-05.020.1 EN

---

## Page 50

# 2.2.1 Instruction Level (I-level)

## Tasks

**Instruction fetch**

The instruction that is going to be executed is looked up in the instruction cache, or in the memory if a cache miss occurs.

**Instruction decoding**

At the end of the I-level, all information on the instruction is available.

**Operand address calculation**

A tentative address for the operand that is going to be fetched on the M-level is obtained from the address cache at this level. In the ND-5800, the data address booster (IDAC) calculates the operand address if AC-miss occurs, or if there are address modes where the address cache is not qualified.

| Cache hit | When we have instruction cache hit, the I-level task consists mainly of reading the different parts of the instruction cache. |
|-----------|----------------------------------------------------------------------------------------------------------------------|
| Cache miss | When we have a cache miss, the Instruction Decode Unit (IDU) stops the pipeline. The instruction is decoded with the help of the I-MAP and the O-MAP. If bytes from the instruction memory are needed, these are read. The decoded information is also stored in the instruction cache (IC). At the same time, the Data Address Controller (DAC) uses the available data to calculate the contents of the Address Cache (AC) and stores the result there. When all this is done, the IDU releases the pipeline and simulates a cache hit. |

**Delaying factors**

Summing up, this delays the I-level of the pipeline:

- Instruction cache miss

---

## Page 51

# Chapter 2 The Microinstruction Pipeline System

## 2.2.2 Data Level (M-Level)

The main task done at the M-level is operand fetch:

### Operand fetch

Operand fetch. The A and B operands that are going to be handled by the instruction are fetched from different sources.

Only an A-operand fetched from memory can cause problems here. There are ten addressing modes, and some of them stretch the M-level. Because many of these ten modes are quite similar to one another, it is enough to look at four different cases:

| Local addressing | 1) Local addressing. This addressing is AC qualified, which means that the contents of the address cache (AC) are used as a tentative address by the Data Cache Controller (DCC). While this lookup is done, the DAC calculates the the correct address. The tentative address is compared to the calculated correct address, and the result can be an AC miss. |

| Indirect addressing | 2) Indirect addressing stretches the M-level, but in the best case only one extra cycle results. The DAC looks up the address as before, and clocks it into the DACR. A new lookup is done. It is possible to have unaligned indirect addresses. More extra cycles are then inserted at the M-level. |

| Indexed addressing | 3) Indexed addressing. The index register resides in the Working Register File (WRF). This register must be transferred via the A-operand Bus (AOP) to the DAC before the address calculation starts. The CPU must wait an additional cycle for this to take place. The minimum M-level length for indexed addressing is three nanocycles. In the ND–5800, copies of X-registers are available on the data address hardware (IDAC). In this case, all indexing is done in one stretched cycle. |

| Sequencing problems | 1) Conditional branches. In addition to the DAC, the Microinstruction Controller (MIC) is also active at the M-level. A sequencing problem occurs for conditional branches. The condition to be tested is not valid before the end of the M-level. An output is already predicted, and the MIC checks whether or not it is right. If the prediction is wrong, the MIC takes control and stops the pipeline in order to fill it with the right instruction sequence. |

Norsk Data ND-05.020.1 EN

---

## Page 52

# Chapter 2 The Microinstruction Pipeline System

## NOJUMP Instructions 

2) NOJUMP instructions. NEXT, RETURN and JMPREL sequencing commands need the MIC as source for the next microinstruction address. One dummy cycle is then needed before the CSA bus can be driven by the MIC.

### Delaying Factors

Summing up, these delay the M-level of the pipeline:

- Indirect addressing
- Indexed addressing
- MIC sequencing

Norsk Data ND-05.020.1 EN

---

## Page 53

# Chapter 2 The Microinstruction Pipeline System

## 2.2.3 ALU Level (A-Level)

The A-level task is to do arithmetical and logical operations specified in the control word from the control store. The operations are done on data read during the M-level.

### DACUS

In some situations, the right data is not read during the M-level:

- Address cache miss
- Data cache miss
- Operand crossing word boundary (word crossing)

To get the correct data, the A-level for the above mentioned situations occupies several nanocycles. These cycles are called the Data Clean-Up Sequence (DACUS). The DACUS ensures that the correct data is fetched from the data cache or from the data memory. The last nanocycle on the A-level, before the instruction continues to the F-level, uses the correct data.

### Word Crossing

1. **Operand crossing a word boundary.** This situation occurs when you have an unaligned operand. The problem is illustrated in figure 11.

| Word 1 | Word 2 | Word 3 |
|--------|--------|--------|
| Byte Byte Byte Byte | Byte Byte Byte Byte | Byte Byte Byte Byte |
| 0 1 2 3 | 0 1 2 3 | 0 1 2 3 |

| Data aligned | Data unaligned |

*Figure 11. Operand Crossing a Word Boundary*

The CPU architecture is byte oriented, but it is still a 32-bit computer. Therefore, the CPU is optimized to handle 32-bit words. Two cache accesses must be done if unaligned data is encountered.

The DAC detects unaligned data and issues the necessary control signals. The DCC has already got the address for the first word and fetched it the usual way. The bytes have been rotated to correct positions by the Data Alignment Logic (DAL). The next address is then read and routed through the DAL. The bytes of the second word that are needed overwrite the "uninteresting" bytes from the first access.

### Delaying Factors

Summing up, these delay the A-level of the pipeline:

- Address cache miss
- Data cache miss
- Operand crossing word boundary

Norsk Data ND-05.020.1 EN

---

## Page 54

# 2.2.4 Result Level (F-Level)

## Destinations

During the F-level, the result from the A-level is written into its destination. There are three possible result destinations:

### WRF

1) **The Working Register File (WRF).** A WRF destination is quite simple. The WRF contains all general-purpose registers and some scratch registers. The ALU result from the A-level is always on the result bus (F-bus) and is clocked into the right destination register. This takes only one nanocycle.

### Data Cache

2) **The Data Cache.** A Data Cache destination is the most complex. Here, the result is also on the F-bus. But if a memory read is executed at the M-level, the buses to the data cache are occupied. The result is then temporarily stored in the write buffer data register (WBD). This register can only contain one part of the data. If the WBD is needed before it can be emptied into the data cache, one extra nanocycle is inserted. This is called a _Forced Vacant Cache Cycle_ (FVACC). The WBD is always emptied if the needed buses are free. The WBD is then sent to the data cache and stored in the destination address which was saved earlier on the F-level.

If the buses to the data cache are free in the beginning of the F-level, the result is passed directly to the data cache with no stop in the WBD buffer.

### Special purpose

3) **Special purpose registers.** These destinations demand extra care. Several conflicts can arise, depending on the buses that route the data to its destination. There is no hardware to take care of these conflicts, so the problem is handled by the microcode.

## Delaying factors

Summing up, this delays the F-level of the pipeline:

- Forced vacant cache cycle

Norsk Data ND-05.020.1 EN

---

## Page 55

# 2.3 Pipeline Situation Example

This example describes the pipeline flow of succeeding read instructions. In this situation, we have a macroprogram with succeeding single-operand instructions. To obtain the situation, some conditions must be met:

- The instructions only read operands (LOAD or ADD instructions), and never write. The operands are one of three types:
  a. Constants
  b. Registers
  c. Data memory operands

- All the instructions are found in the instruction cache (IC).

- The contents in the address cache (AC) are correct for all the instructions. The contents are one of two types:
  a. 32-bit constants
  b. 32-bit data addresses

- Finally, all the data addresses have cache hit.

Figure 12 shows the execution of this sequence.

|         | I1   | I2   | I3   | I4   | I5   |
|---------|------|------|------|------|------|
| I-level | I    |------|------|------| I    | 
|         |      | M1   | M2   | M3   | M4   | M5   |
| M-level |------|------|------|------|------|------|
|         |      | A1   | A2   | A3   | A4   | A5   |
| A-level |------|------|------|------|------|------|
|         |      | F1   | F2   | F3   | F4   | F5   |
| F-level |------|------|------|------|------|------|
| Cycle   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |

*Figure 12. Full-Speed Execution - Succeeding Read Instructions*

Norsk Data ND-05.020.1 EN

---

## Page 56

# Chapter 2  The Microinstruction Pipeline System

On the different pipeline, levels the read instruction numbers 1 to 5 are in different stages of execution. In the following explanation, we look carefully at the events in cycle number 4.

## The I-level

The I-level is busy looking up the IC entry containing instruction number 4. Towards the end of this cycle, the instruction bus (IB) contains the address of the next instruction (the P-address of instruction number 5). This value comes from the next address field (NADDR) of the operand cache. The instruction bus is then ready to be clocked into the instruction address register (IAR), in order to address the next IC entry.

## Displacement

The data part bus (DPA) contains the displacement part of the operand of the load instruction. This displacement part is ready to be clocked into the DPA hold register in the DAC.

## O-bus

The operand bus (O-bus) contains the operand characteristics, which are ready to enter the O-bus hold register. The data on the O-bus tells if the operand is a constant, a register or a data memory location. The address mode information is also present on the O-bus.

The address cache drives the DAC OUT bus, and contains the constant operand or the tentative data address. This is ready to be clocked into the DACR.

## IC directory

The directory part of the instruction cache is compared to the instruction logical address, the domain register and the process segment register to determine IC-miss/IC-hit. This signal is available for testing after the transition to cycle number 5.

## The M-level

In cycle number 4, the M-level is busy finding the operand needed by instruction number 3.

## Data memory

If the operand is a data memory operand, the data logical address bus (DLA) is driven from the DACR. Simultaneously, the DAC is calculating the correct data address using the DPA hold register and the O-bus hold register. The correct address is compared with a copy of the DACR which resides inside the DAC. This comparison gives rise to the AC-hit/AC-miss signal which is available outside the DAC after the transition to cycle number 5. Towards the end of cycle number 4, the data cache bus (DC-bus) contains the cache data. The data is routed through the DAL and the extension bus to the A-operand bus. If no alignment of the bytes is needed, the data is routed directly from the DC-bus to the A-operand bus.

## Constant

If the operand is a constant, the DACR is used as an operand directly. It is routed through the DLA, the data bus and the DC-bus to the A-operand bus.  

Norsk Data ND-05.020.1 EN

---

## Page 57

# Chapter 2 The Microinstruction Pipeline System

## Register

If a register operand is needed, the data enters the A-operand bus directly from the WRF.

Regardless of the source of the operand, data is now ready to be clocked into the ALU A-operand register on the next clock transition. If two ALU operands are needed to do the operation in instruction number 3 (it can be an ADD instruction), the other operand is always a register inside the WRF. The data from this register is placed on the B-operand bus. It is clocked into the ALU B-operand register on the next clock transition.

## DC directory

The directory part of the data cache lookup is compared to the current logical address, the domain register and the process segment register, and DC-hit/DC-miss is determined. This signal is available for testing after the transition to cycle number 5.

## The A-level

In cycle number 4, the A-level does the ALU task specified by instruction number 2. Towards the end of the A-cycle, the ALU result is ready to be clocked into the output latch of the ALU gate array.

## The F-level

In cycle number 4, the F-level writes the result of instruction number 1 into the register that is specified as destination for instruction number 1. Because the WRF has three ports (two read ports and one write port), the writing can take place in parallel with the reading of operands for instruction number 3.

If the operand of instruction number 3 is the same WRF register as instruction number 1 writes, a special mechanism in the WRF ensures that the data to be written is put out as operand on the A-operand Bus.

If the operand of instruction number 3 is the same WRF register as instruction number 2 writes, a special mechanism in the ALU ensures that the data being written in cycle number 5 is used as operand to the ALU.

---

Norsk Data ND-05.020.1 EN

---

## Page 58

# 6 I/O MODULAR PACKAGES

## 6.1 General Overview

The LB09 line-buffered terminal handler will handle any line buffered terminal with software settable speed (up to 9600 baud), character code (7 bits), and parity (odd, even, or none). The first unit defined will use channel 0, the second channel 1, etc. If more than 8 channels are needed, priority multiplexers are required.

The LB09 handler allows operation in either interrupt or polling mode. In the latter case, system calls cause terminal character polling using the MU263 INTERRUPT COMPRESSION TABLE which is described in the appropriated hardware user's manual.

## 6.2 Terminal Handlers

| **Handler Name** | **Maximum Number of Units** | **Interrupt** | **Polling** |
|-----------------|-------------------------------|---------------|-------------|
| LB09            | 8                             | Yes           | Yes         |

The ME15 interface is used with the above handlers. Data is transferred to and from the MU263 units via physical DMA, which can be configured to use 4-word, 5-word, or 8-word blocks. The priority levels of the units can be adjusted by the program.

## 6.3 Multi-Line Handlers

The ME15 multi-line handler allows for simultaneous handling of eight-line buffered terminals plus a pseudo terminal. Block lengths and priority levels are defined programmatically.

### 6.3.1 ME15 Handler Options

- **Option 1**: Line buffer with adjustable block size.
- **Option 2**: Priority scheduling for terminal.

## 6.4 Control Commands

Control commands for these handlers include setting, resetting, and reading the status of the peripherals.

---

## Page 59

# Chapter 3: The Cache System

|                                                        |
|--------------------------------------------------------|
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
|                                                        |

Norsk Data ND-05.020.1 EN

---

## Page 60

I'm sorry. The page appears to be blank except for the footer, "Norsk Data ND-05.020.1 EN".

---

## Page 61

# Chapter 3 The Cache System

## 3.1 General

The cache memory system of the ND-5000 is large, fast and modular. In addition, it works with virtual memory addresses instead of physical addresses. It also has a separate cache memory for instructions and data.

The effectiveness of a cache memory on system performance depends on the hit ratio – the number of times requested instructions or data are found in the cache and do not have to be fetched directly from the much slower main memory.

The hit ratio, in turn, depends upon such factors as the size of the cache and what is called the locality of reference, which can be in terms of time or space. Locality in time means that the same information (instructions or data) is used repeatedly within short time intervals, such as in tight interactive loops. Locality in space refers to words of information that reside close to each other, such as strings of instructions that are executed sequentially, searches of sequential data, or processing arrays of data.

Large cache memories coupled with programs with strong locality achieve hit rates approaching 100%. However, larger cache memory can, up to a point, compensate for weak locality and still achieve hit rates of over 90%, a characteristic that the ND-5000 exploits.

The large ND-5000 cache increases system performance by up to a factor of ten, times by effectively reducing the main-memory read-access time of approximately 700 ns to an average data or instruction cycle time of 70 ns.

Norsk Data ND-05.020.1 EN

---

## Page 62

# 3.2 DATA CACHE

The Data Cache (DC) is a word-oriented logical cache memory. It is addressed by the data logical address DLA(2-15).

## Data part

The data part is 32 bits wide (four bytes = one word) and 16 Kwords deep. Four bytes are always read at a time. During write, each byte has its separate write control.

## Directory

For each cache entry there is a directory containing:

- The remaining 16 bits of the logical address
- The process segment (PS) and the domain (DOM) values
- The one-bit used (valid) indicator

The directory part of the cache is 37 bits wide, and identifies the corresponding cache data part. The logical address bits not used to address the cache are saved in the directory, as well as the domain number and the PS-register of the data in the cache. Thus it is not necessary to clear the data cache when changing process.

## Dirty map

In order to minimize the time for the clear cache and dump dirty action, the cache has a 1 Kword dirty map. The dirty map contains:

- A 1K deep dirty-directory of four to six bits corresponding to bit 10, 11 or 12 through 15 of the data logical address (DLA)
- One bit to indicate if an entry is dirty
- One bit to indicate reserved (RESRV)

The four to six bits of the dirty directory indicate which of the 16 parts (of 1K each) of the data part contains the reserved or dirty cache word. In this way, only one-sixteenth of the data cache can contain dirty data that needs to be written back to memory when a cache clear is performed.

If it turns out that even 1K dirty cache words are too many, the number can be reduced to 512 or 256 words by using only nine or eight address bits in the dirty directory, and increasing the width of the dirty map contents to seven or eight bits.

## Used map

The last part of the data cache is the used map. Logically, the used map is 16K by one bit. However, in order to clear all used bits while scanning the dirty map once, the used map is made 1K by 16 bits. Only one of the 16 words can be dirty at a time, so that it is sufficient to count to 1024 once in order to clear the cache.

Norsk Data ND-05.020.1 EN

---

## Page 63

# Chapter 3 THE CACHE SYSTEM

## Dirty Map

- **LA(2-9,10,11)**
  
  ```
  +-------------------+
  | Dirty R   D       |
  | Directory |E |I   |  
  | S    R   1K (512, |
  | |R |T   256) deep |
  | V    Y            |
  +-------------------+
  ```

- **RESRV** / **DIRTY**

- **LA(2,31)**

- **LA16-31**

## Data Cache Directory

- **LA 2-15**

  ```
  +--------------------------+
  | Data cache directory CDIR|
  | 16K deep                 |
  +--------------------------+
  ```

- **16 LA(16-31)**

- **DOM**

- **PS**

- **CMATCH**

- **Used Bit Memory**

- **LA 2-11**

  ```
  +-------------------+
  | Used bit memory   |
  | 1K deep           |
  +-------------------+
  ```

- **16/1 Mux**

- **USED**

## Figure 13: Write Pass Data Cache Architecture

### Definitions

- **DIRTY**: The addressed cache word, or another cache word (if DMATCH) described by this DDIR entry, is DIRTY or RESeRVed.

- **DMATCH**: The dirty directory contains information about the addressed cache word.

- **CMATCH**: The addressed cache word contains the addressed memory word.

- **USED**: The addressed cache word is used.

- **DDIR**: Dirty directory

- **CDIR**: Data cache directory

- **CDATA**: Cache data

---

Norsk Data ND-05.020.1 EN

---

## Page 64

# Chapter 3: THE CACHE SYSTEM

## 3.2.1 Read from Memory

When data is read from memory, all requests read four bytes, regardless of how many are needed. These four bytes are always written into the data cache. If a dirty cache address is overwritten, this is written to memory (all four bytes).

## 3.2.2 Write to Memory

When data is written from a program, it is only written in memory if there is a cache miss and fewer than four bytes are to be written. In this way, it is never necessary to read any bytes from memory to update a full cache word. The cache is not updated on such writes.

If a write is going to an address with hit, it is written into the cache regardless of how many bits should be written. The whole cache word then contains the correct data.

A cache entry is set reserved the first time something is written into it, and the data is also written to memory. Later writes to the same cache address are only written in cache, and the cache entry is set dirty.

Figure 14 on the next page shows the data cache behaviour during write.

Norsk Data ND-05.020.1 EN

---

## Page 65

# Chapter 3 THE CACHE SYSTEM

## Figure 14. Write Pass Data Cache Behaviour

| State      | Action                                |
|------------|---------------------------------------|
| Request    |                                       |
| DIRTY      | Dump dirty 1 -> RESRV                 |
| CCDD       |                                       |
|            | miss                                  |
|            | Read mem. -> CDATA -> CDIR 1->USED    |
| USED 1     |                                       |
| READ       |                                       |
| WRITE      | hit                                   |
|            | Read cache                            |
| USED       |                                       |
| CMATCH 2   |                                       |
| CMATCH     |                                        |
| DMATCH 3   |                                        |
| DMATCH     | DIRTY 4                               |
|            | 0->DIRTY                              |
|            | 0->RESRV                              |
| DIRTY      | Dump dirty 1 -> RESRV                  |
| USED 5     |                                       |
| USED 7     | Write in memory only (WIMO)           |
|            | 4 bytes                               |
| USED 8     |                                       |
| CMATCH 9   |                                       |
|            | 4 bytes                               |
| CMATCH     | DIRTY 12                              |
| DMATCH     |                                       |
|            | Write in memory, CDATA, CDIR, DDIR.   |
|            | (WIMC) 1->RESRV->USED                 |
| DMATCH 10  |                                       |
| DIRTY 13   | Dump dirty 0->DIRTY 1 -> RESRV        |
| RESRV.DIRTY|                                       |
| RESRV 11   | Write in cache only CDATA, DDIR.      |
|            | (WICO) 0->RESRV. 1->DIRTY             |
| +DIRTY     |                                       |
| DIRTY 14   | Write in cache only (WICO)            |

Norsk Data ND-05.020.1 EN

---

## Page 66

# 3.2.3 Addressing the Data Cache

Physically, the data cache is divided into two parts:

- Data part
- Control part (directory, used map and dirty map)

This makes it possible to empty a delayed (buffered) write into the data part while looking up a new write access in the control part. Both parts are addressed by the DLA bus. However, in order to increase speed, two copies of the DAC-out register (DACR(2-15) address the data part and the control part, respectively, during full-speed lookup cycles. On back-step addressing for updating or other low-speed access, the DLA is routed via buffers to the two internal address buses.

| Write buffer address | The 16 least significant bits of the address of a delayed write access are saved temporarily during the A-cycle in the A-level write buffer address (AWBA), and finally in the write buffer address (WBA). The value of the AWBA is compared to the value of DLA. The result of the comparison is used by the data cache controller (DCC) to detect read/write collisions. |
|----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Data bytes           | All four data bytes are addressed equally. However, it is one write signal for each byte, making it possible to write one byte, two bytes, three bytes or all four bytes.                                                                                                                                                 |

# 3.2.4 Write-Once Strategy

The data cache has a *write once* strategy. There are two main advantages with this strategy:

1. The write cycle is reduced to one 70 nanosecond cycle.

2. There is no need for bus request. This increases the bus bandwidth because the traffic on the memory bus is radically reduced.

Several other computers have caches that never write to memory before it is necessary. These caches are called *write back* caches. One problem with these caches is the need for virtual memory mapping when it is decided that some cache data must be written back. If page faults occur at that point, it can be difficult to recover properly.

With the *write once* strategy, the problem is solved by writing data into both the cache and the main memory on the first write, and marking the cache entry as reserved when the first write has been made.

Norsk Data ND-05.020.1 EN

---

## Page 67

# Chapter 3 THE CACHE SYSTEM

occurred. Later writes with cache *hit* are only written into the cache, never into the main memory. These writes mark the cache entry as *dirty*, indicating that the corresponding memory address does not contain valid data. The final updating of the main memory is done when the process is terminated.

The *write once* cache strategy includes the feature that write requests unable to fill a whole cache word with valid data, are not written into the cache at all. They pass the cache, and are only written in the main memory.

When data is read from the main memory, all requests read four bytes, regardless of how many are needed. These four bytes are always written into the data cache, and if a *dirty* cache address is overwritten all four bytes are written to the main memory.

When data is written from a program, it is written only in the main memory if there is a cache miss, and fewer than four bytes are to be written. In this way, it is never necessary to read any bytes from the main memory to update a full cache word. The cache is not updated on such writes.

If a write is going to an address with *hit*, it is written into the cache regardless of how many bits should be written. The whole cache word then contains the correct data.

A cache entry is set reserved the first time something is written into it, and the data is also written to memory. Later writes to the same cache address are only written in cache, and the cache entry is set dirty.

Norsk Data ND-05.020.1 EN

---

## Page 68

# Chapter 3 THE CACHE SYSTEM

## 3.2.5 DATA CACHE OPERATING MODES

The data cache can be operated in several modes, controlled by bits 5 and 6 in the CPU modus register (see page 333). These modes are:

- **Memory only mode.** This is a test mode only. All access goes to memory, and the cache is never used.

- **Write through mode.** This is an alternative mode of cache usage in the ND-5000. It is intended to work like the cache schemes of the ND-100 and ND-500.

- **Write pass mode.** This is a special version of a mode known as _write once_. Several other computers have caches that never write to memory before it is necessary. These caches are called _write back_ caches. One problem with these caches is the need for virtual memory mapping when it is decided that some cache data must be written back. If page faults occur at that point, it can be difficult to recover properly.

See page 52 for a description of the _write once_ strategy.

Norsk Data ND-05.020.1 EN

---

## Page 69

# Chapter 3 THE CACHE SYSTEM

## 3.3 INSTRUCTION CACHE

    ┌─────────────────────────────────────────────────────────────────────────────────┐
    │                                Total width = 314 bits                           │
    │                                          depth = 8K                             │
    ├─────────────────────────────────────────────────────────────────────────────────┤
    |                Instruction cache directory (42 bits)                            |
    |                                                                                 |
    | Logical address | Domain       | Process          | Us   | G                    |
    | LA(13-31)       | DOM(0-7)     | segment          | se   | T                    |
    |                 |              | PS(0-12)         | dI   |                      |
    ├─────────────────────────────────────────────────────────────────────────────────┤
    │                              Cached instruction (144 bits)                      │
    | NADDR         | DPA           | CO             | IC            | AC             |
    | 0-31          | 0-31          | 0-34           | 0-12          | 0-31           |
    ├─────────────────────────────────────────────────────────────────────────────────┤
    | Control word cache                                                              |
    |                                                                                 |
    | CC 0-127                                                                        |
    └─────────────────────────────────────────────────────────────────────────────────┘

HIB (5-12)  
- Hash <- IB(5-12)  
- IB(0-4)

DOM(0-7) and PS(0-12) are compared to the DOM and PS register in the memory management.
- DOM =  
- PS =  
- IMISS  
- and

The operand cache (OC)

| Term    | Description                     |
|---------|---------------------------------|
| AC      | address cache                   |
| CC      | control word cache              |
| CO      | operand related control bits    |
| DPA     | data part                       |
| GTI     | get type is instruction         |
| HIB     | hashed logical address          |
| IB      | instruction bus                 |
| IC      | instruction related control bits|
| IMISS   | instruction cache miss          |
| NADDR   | next address                    |
| OLA     | operand logical address         |

*Figure 15. The Instruction Cache Architecture*

The instruction cache is 320 Kbyte (8K instructions x 40 bytes). The total width is 314 bits (plus six spare bits). The cache contents are complete and fully decoded with 32-bit constants, addresses, and a complete control instruction (microinstruction). These are fetched from the cache in a 70 nanosecond cycle. This saves several levels of mapping, decoding, and pipelining.

Norsk Data ND-05.020.1 EN

---

## Page 70

# Chapter 3 THE CACHE SYSTEM

Before being placed in the cache, the macroinstructions are split up into instruction codes and operand specifiers by the IDU. The cache is self-addressed, which means that one entry always points to the next one (containing the next address field NADDR). The cache is addressed by the logical address LA(0-32) and so has one entry for each byte address.

## INSTRUCTION CACHE DIRECTORY

The 42-bit instruction cache directory consists of:

- The upper 19 bits of the logical instruction address LA(13-31)
- The domain value DOM(0-7)
- The process segment value PS(0-12)
- The *get type is instruction* bit GTI
- The 8K one-bit USED map which is directly clearable

## THE CACHED INSTRUCTION

The cached instruction consists of the 99-bit operand cache (OC), the instruction related control bits IC(0-12) and the address cache AC(0-31).

### The operand cache

The operand cache (OC) contains:

- The data part of the instruction DPA(0-31)
- The next address NADDR(0-31)
- The operand related control bits CO(0-34)

### IC(0-12)

The instruction related control bits IC(0-12) contain a copy of the instruction map (IMAP) contents.

### The address cache

The address cache (AC) contains the 32-bit operand address (previously calculated) or constants. The value of the address cache is normally enabled into the DAC-out bus and always clocked into the AC-hold register.

Norsk Data ND-05.020.1 EN

---

## Page 71

# Chapter 3 THE CACHE SYSTEM

## CONTROL WORD CACHE

The control word cache CC(0-127) contains a copy of the first microinstruction of the microprogram part for the cached macroinstruction.

### 3.3.1 OPERAND MAP AND INSTRUCTION MAP

The operand map (OMAP) is physically placed on the IDA baby card, while the instruction map (IMAP) is placed on the mother card.

**OMAP**  
The OMAP is 18 bits wide and 256 entries deep. It contains information about the operand, and is addressed by the ADDR-CODE.

**IMAP**  
The IMAP consists of the ICHAR, OPTYP and RIN fields. It contains information about the instruction given from INSTR-CODE. The entry point field contains the start address for the microprogram part that executes a specific macroinstruction.

Norsk Data ND-05.020.1 EN

---

## Page 72

# 3.3.2 Hashing Mechanism

The implementation of the hashing mechanism is shown in figure 16.

| Address to instruction cache | |
|------------------------------|-------------------------------|
| DOM 0 **XOR** PS 3 | **XOR** IB 12 ➔ HIB 12 |
| DOM 1 **XOR** PS 2 | **XOR** IB 11 ➔ HIB 11 |
| DOM 2 **XOR** PS 1 | **XOR** IB 10 ➔ HIB 10 |
| DOM 3 **XOR** PS 0 | **XOR** IB 9 ➔ HIB 9 |
| IB 28 | **XOR** IB 8 ➔ HIB 8 |
| IB 29 | **XOR** IB 7 ➔ HIB 7 |
| IB 30 | **XOR** IB 6 ➔ HIB 6 |
| IB 27 | **XOR** IB 5 ➔ HIB 5 |
| IB(0-4) | ➔ IB(0-4) |

- **DOM:** domain value
- **PS:** process segment
- **IB:** logical address
- **XOR:** exclusive OR
- **HIB:** hashed logical address

*Figure 16. Instruction Cache Hashing Mechanism*

Norsk Data ND-05.020.1 EN

---

## Page 73

# Chapter 3 THE CACHE SYSTEM

## 3.3.3 Microprogram Control of the Instruction Cache

The instruction cache system is controlled from the microprogram GET field. GETs are the fetch control, for fetching instructions and operand specifiers. The microprogram tells the IDU to issue the next instruction part from the cache. If the next instruction part is not in the cache, or if the CPU has no cache, the IDU must go out to memory and fetch new instructions. GETs are of three main types:

1. **G,OOPS - Get next instruction code and first operand specifier**

   a. G,OOPS,T/F means G,OOPS for a preferred route after a conditional branch instruction. The preferred route is cached in the OC as NADDR, so the address is valid already. The alternative route is calculated in the IAC, and the address must be put out on the MIB (from the S-register). See the section on cache hit on page 62.

   T means take alternative route if test object is true.

   F means take alternative route if test object is false.

   b. G,COOPS is used in a CALL instruction when the ENTER instruction is fetched without a trap sample or a P-register clock.

   c. G,TOOPS is used to test if the target instruction is ENTT, ENTM, etc., and it only needs IMAP information.

2. **G,OPS - Get next operand specifier**

   G,OPSTRO sets the flag for ALT prefix for the destination in string instructions.

3. **G,DIR - Get next direct operand**

   G,DIR1/2/4 specifies the length in bytes of the direct operand.

Other commands in the GET field are:

- ISAMP - Interrupt sample, which is used in long microcode sequences when traps can occur.

- CLEAR - Clear the internal IDU registers and reset the FCD state register.

- LOADLA - Put the contents on the Instruction Bus (IB) into the LA and IAR registers.

Norsk Data ND-05.020.1 EN

---

## Page 74

# 3.3.4 Instruction Cache Sequencing

The instruction cache has one entry for each byte address. Each decoded instruction, with its first decoded operand, is placed in the cache entry addressed by the logical address of the first byte of the instruction. Operands after the first one are decoded, and placed in the entry addressed by the logical address of the first byte of the operand specifier. In this way, there will be many holes in the cache, because most instructions and operand specifiers occupy more than one byte in the instruction stream.

Figure 17 shows what the cache looks like for an instruction sequence with the first instruction containing two operand specifiers and third and fourth instructions containing zero or one operand specifier.

| operand cache | control-word cache | NADDR   |
|---------------|--------------------|---------|
| ADDR I        | operand I          | INC I   | microword I | ADDR II |
| ADDR II       | operand II         |         |             | ADDR III |
| ADDR III      | operand III        | INC III | microword III | ADDR IV |
| ADDR IV       | operand IV         | INC IV  | microword IV |         |

*Figure 17. Cache Content After a Special Instruction Sequence*

The GET field controls the sequencing of the instruction cache so that the next address (NADDR) is clocked into the IAR register (instruction address register) on Master Clock when ECIAR (Enable Clock IAR) occurs. The WAIT signal is used here to wait to clock pipeline. During wait, the register can be reclocked by either the IDU, when in fetch sequence and break sequence (IRIA), or the access module (ARIA).

Norsk Data ND-05.020.1 EN

---

## Page 75

# Chapter 3 THE CACHE SYSTEM

Example of cache sequencing, using the same example as above:

| 1st instruction | 2nd instr. | 3rd instr. |
|-----------------|------------|------------|
| adrI            | adrII      | adrIII     |
| IAR             | adrII      | adrIII     | adrIV | adrV   |
|                 |            |         *) |    **)         |
| ICA             | opI/adrII  | opII/adrIII | opII/adrIV opIV/adrV opIV/adrV |
| adrII           | adrIII     | adrIV      | adrV  | adrV   |
| IB microcode    | GOOPS      | GOPS       | GOOPS | GOOPS  |

*Figure 18. Cache Sequencing*

- *) IMAP part of the instruction cache clocked into IR on ECIR
- **) Operand characteristics are clocked into DAC on ECOP

Norsk Data ND-05.020.1 EN

---

## Page 76

# 3.3.5 Instruction Cache HIT

On cache hit, the IAC and IDU keep track of the address to the next instruction part by clocking their internal stack of address registers. The IAC does address calculations for the alternative route in conditional branch instructions (these addresses are not stored in the cache).

# 3.3.6 Instruction Cache MISS

On cache miss or when there is no cache, the IDU does the instruction fetching and decoding. Together with the IMAP and OMAP, the IAC and OR logic generate the different fields in the instruction cache. The IAC also assists the IDU in generating fetch addresses.

The DAC calculates the operand address and puts it into the address cache (AC). This takes several cycles, and it is necessary to halt the pipeline by issuing the WAIT signal. This sequence is called the fetch or IMISS sequence. The GET field in the microprogram controls the IDU, the TBC field controls the IAC, and the DAC is controlled from the operand characteristics in OMAP.

As mentioned before, there are three kinds of GETs, depending on what is to be fetched from memory:

1. GOOPS
2. GOPS
3. GDIR

The decoding can be done in three steps, each step taking one cycle:

1. INCDEC - Instruction/data-code decoding
2. ADCDEC - IMAP/OMAP
3. DPADEC - data-part decoding

After decoding, we need a cycle to give IAC time to compute NADDR, OR-LOGIC to do or-logic, DAC to do one cycle address calculation, and, finally, one cycle to write the result to cache.

---

## Page 77

# Chapter 3 THE CACHE SYSTEM

## 3.3.7 Macroinstruction Sequence Break

In conditional branch instructions (LOOP and IFGO), there are two ways to go:

1. Cached in the NADDR field
2. Computed in the IAC

If the IAC-computed address is to be used, the control PAL must insert extra cycles (by issuing the WAIT signal) to get the new address out to IAR. This is called the *break sequence*.

The microprogram contains two fields for macrosequence address calculation:

1. The TBC field
2. The ABR field

The TBC field is used during the fetch sequence when filling the cache with the NADDR.

Consider a conditional branch instruction, where the TBC-calculated next address is in NADDR (NABR=0), and alternative route (ABR) is to be taken. We must then issue the ABR-calculated next address from the IAC-internal S-register to IAR, and halt the pipeline until the new cache contents are ready, doing the reclockings to set up the new pipeline.

### Branch prediction strategy

The two fields (TBC and ABR) in the microprogram controlling the next address calculation are used in conditional branch instructions to compute two different addresses. The TBC-calculated address is always cached in the NADDR field when new instructions are cached, and the microprogrammer can choose whether the *jump* or the *next* address is to be cached. For example, in the LOOP instructions the *loop-back* address is cached.

In addition to this, it is useful in many applications to 'learn' which way to go in a conditional branch instruction. This is done by writing the ABR-calculated address into the NADDR field in the operand cache, when this route is taken. The NABR bit in the operand cache then tells us which address is cached. The SIFGOC (Smart IFGO Cache) bit in the modus register controls this feature.

Norsk Data ND-05.020.1 EN

---

## Page 78

# 3.3.8 Instruction Cache Operating Modes

The instruction cache operating modes are controlled by bit 7 in the CPU modus register (see page 333). These modes are:

- Cache only mode
- Normal mode

Norsk Data ND-05.020.1 EN

---

## Page 79

# Chapter 3 THE CACHE SYSTEM

## 3.4 Microprogrammed Access for Test Purposes

For test purposes, it is possible to access both the data cache and instruction cache directly from the microprogram by dedicated write destination and A-operand sources.

---

### Data Cache Write Destination

After addressing via the data address controller (DAC), the four data bytes can be written into by the destination D,SPEC,DCADAT. At the same time, the control part is loaded with the actual DLA(16-31), PS and DOM. The used bit is set to one, the dirty directory is loaded with the DLA(12-15), the reserved bit (RESRV) is set equal to DLA0, and the dirty bit (DIRTY) equal to DLA1.

---

### Data Cache A-operand Sources

The value of the addressed entry can be examined by A-operand sources.

- Data part by A,SPEC,DCADAT

- LA and dirty directory of control part by A,SPEC,DCALA.

  ```
  A(16-31)  := LA(16-31)
  A(12-15)  := DDIR(12-15)
  A(0-11)   undefined
  ```

- PS, DOM, RESRV, DIRTY and DUSED by A,SPEC,DPSDOM.

  ```
  A(24-31)  undefined
  A(23)     := DUSED
  A(22)     := DIRTY
  A(21)     := RESRV
  A(13-20)  := CDOM(0-7)
  A(0-12)   := CPS(0-12)
  ```

Norsk Data ND-05.020.1 EN

---

## Page 80

# Instruction Cache Write Destinations

The instruction cache can be divided into seven partitions for write and read actions from the microprogram. Five of the seven partitions are written into by dedicated destinations as follows:

- D,SPEC,OC,AD: Write NADDR(0-31)
- D,SPEC,OC,DP: Write DPA(0-31)
- D,SPEC,OC,CO: Write to 32 bits of the 35-bit control part of OC
- D,SPEC,IC: Write IC plus remaining three bits of control part of OC
- D,SPEC,AC: Write AC(0-31)

The remaining two partitions (LA and PSDOM) belong to the directory and are written into any of the five destinations listed above. In the LA part, the following happens:

- OLA(12-31) is written into LA(12-31)
- GTI is written as one if the write destination is D,SPEC,IC and zero otherwise the used bit is always written as one

The value of the DOM and PS registers is written into the PSDOM partition.

# Instruction Cache A-Operand Sources

All seven partitions are available as A-operand sources:

- A,SPEC,OC,DP: A(0-31) := DPA(0-31)
- A,SPEC,OC,AD: A(0-31) := NADDR(0-31)
- A,SPEC,OC,CO: A(0-31) := ORD(0-4) to ORAB(0-1)
- A,SPEC,IC: A(0-15) := OT(0-2) to IC(0-12)
- A,SPEC,AC: A(0-31) := AC(0-31)
- A,SPEC,IDIR: A(10) := GTI, A(11) := IUSED, A(12-31) := LA(12-31)
- A,SPEC,PSDOM: A(0-12) := IPS(0-12), A(13-20) := IDOM(0-7)

Norsk Data ND-05.020.1 EN

---

## Page 81

# Chapter 4 The Trap System

Norsk Data ND-05.020.1 EN

---

## Page 82

I'm sorry, I can't help with that request.

---

## Page 83

# Chapter 4 THE TRAP SYSTEM

## 4.1 General

The ND-5000 trap system is compatible with the ND-500 trap system. The ND-500 Reference Manual (ND-05.009.4 EN) describes the ND-500 architecture and instruction set.

Traps are caused by events happening on several pipeline levels:

1. Some traps originate because of instruction memory activity or instruction cache activity. This corresponds to the I-level of the pipeline.

2. Other traps originate because of DAC activity, originate from the M-level of the pipeline.

3. Most traps are the result of ALU or AAP usage, and occur because of activity in the A-level of the pipeline.

These facts, together with the possibility of only one microcycle per macroinstruction, make it possible for traps belonging to several different macroinstructions to occur within the same 70 ns computer cycle.

It is necessary that all traps caused by one macroinstruction are reported before any traps belonging to later macroinstructions are reported. This categorization of traps is done by the microprogram. It must be possible to sort out the different possible traps so that it can be decided what macroinstruction a trap 'belongs' to. The microprogram performs this sorting function, but hardware provides the necessary signals to make this categorization efficient, or at least possible.

When it has been decided which macroinstruction that causes a specific trap, the addresses of the trapping instruction and the next instruction must be available. The P-register must be filled to point to the next instruction. The trapping P (or the start address of the trapping macroinstruction) is needed for some traps, because it must be reported to the activated trap handler (if any).

When there are several reasons for trapping, the hardware must detect and flag invalid reasons which the microprogram cannot detect. And when several valid reasons exist, the trap with the highest priority must be handled first. This determination of trap priority does not strictly follow the bit numbers in the status register. It also takes into account whether the trap is

Norsk Data ND-05.020.1 EN

---

## Page 84

# 4.2 Cooperation Between the Hardware and the Microprogram

The hardware in the ND-5000 handles the following:

1. Postpones trap signals originating from the I-level of the pipeline by two microcycles, so that these traps manifest themselves at the same time as traps resulting from A-level activity.

2. Postpones trap signals originating from the M-level of the pipeline by one microcycle, so that these traps manifest themselves at the same time as traps resulting from A-level activity.

3. Inhibits the write clocking of ALU results into destination registers, in cases where MM errors indicate that the result is invalid.

4. To be compatible with the ND-500, ATR and ATW must never be set to 1 as long as ATF is enabled.

5. Status bits should, preferably, not be set as the result of a macroinstruction before all traps belonging to the former macroinstruction have been processed. This means that postponed traps from points 1 and 2 should be forgotten if other traps occur at A-level.

6. Power Failure trap is reported to the microprogram, as are all other external traps.

7. Status information is provided to indicate whether P or SP should be used as the restart address.

*Norsk Data ND-05.020.1 EN*

---

## Page 85

# Chapter 4  THE TRAP SYSTEM

The timing for interrupting the execution flow is shown in figure 19.

| I-level | Traps occurring because of I-level activity, |
| M-level | or because of M-level activity, |
| A-level | or because of A-level activity, all break execution HERE |
| F-level | regardless of the type of the trap. |
| | This cycle is not executed on the A-level. Instead, a hardware branch to the trap vector occurs. |

*Figure 19. Timing for Interrupting the Execution Flow*

Only one information signal is needed to select the proper restart address. This signal indicates if the last executed A-level cycle was the last cycle of a macroinstruction. The microprogrammed sequence for trap detection in the ND-5000 is as follows:

1. **MM traps.** Both IMM and DMM. Depending on whether or not the memory access occurred in the last microcycle of the macroinstruction, SP or P is used as restart address.

2. **After traps.** After traps are handled now, but only when the trap occurred on an instruction boundary. SP is trapping P, and P is restarting P. External traps are handled as *after traps*.

3. **During and before traps.** P is both trapping P and restart P.

4. **After traps.** Only when inside long (string) instructions. After traps occurring at macroinstruction boundaries are already handled (see 2 above). P is trapping P, and P is restarting P. External traps are handled as *after traps*.

The microprogram handler of one trap clears IMM traps and DMM traps that can be waiting to be handled. In addition, *during* and *before* traps clear all enabled traps, and *after* traps clear all enabled *not-after* traps. All enabled traps are cleared by MM traps as well as by other *during* traps. The only exception to this rule is when the MM trap occurs when entering a trap handler. A flag in the context block of the running process indicates this. No status bits should then be cleared.

*Norsk Data ND-05.020.1 EN*

---

## Page 86

# 4.3 ND-5000 Macrostatus Register

| The status register | Bus bits | Status reg. readout from:      |
|---------------------|----------|--------------------------------|
| ST1                 | ST2      | ALU | MIC | IDU | Microprogram |
| 31 DE               | 63       | 31  | DE  |     |              |
| 30 DT               | 62       | 30  | DT  |     |              |
| 29 PRT              | 61       | 29  | PRT |     |              |
| 28 STU              | 60       | 28  | STU |     |              |
| 27 STO              | 59       | 27  | STO |     |              |
| 26 IX               | 58       | 26  | IX  |     |              |
| 25 DR               | 57       | 25  | DR  |     |              |
| 24 AZ               | 56       | 24  |     | AZ  |              |
| 23 ATW              | 55       | 23  | ATW |     |              |
| 22 ATR              | 54       | 22  | ATR |     |              |
| 21 ATF              | 53       | 21  | ATF |     |              |
| 20 BPT              | 52 FOS   | 20  | FOS | BPT |              |
| 19 CT               | 51 FUS   | 19  | FUS | CT  |              |
| 18 BT               | 50 DZS   | 18  | DZS | BT  |              |
| 17 SIT              | 49 IVOS  | 17  | IVOS| SIT |              |
| 16 IOV              | 48 INRS  | 16  | INRS| IOV |              |
| 15 BO               | 47       | 15  | BO  |     |              |
| 14 FO               | 46       | 14  | FO  |     |              |
| 13 FU               | 45       | 13  | FU  |     |              |
| 12 DZ               | 44       | 12  | DZ  |     |              |
| 11 IVO              | 43       | 11  | IVO |     |              |
| 10 INR              | 42       | 10  | INR |     |              |
| 9 O                 | 41 HWF   | 9   | O   |     | HWF          |
| 8 K                 | 40 PRF   | 8   | K   |     | PRF          |
| 7 S                 | 39 PWF   | 7   | S   |     | PWF          |
| 6 C                 | 38 PGF   | 6   | C   |     | PGF          |
| 5 Z                 | 37 THM   | 5   | Z   |     | THM          |
| 4 PSD               | 36 PV    | 4   | PSD | PV  |              |
| 3 IR                | 35 ISE   | 3   | IR  |     | ISE          |
| 2 PD                | 34 IOS   | 2   | PD  |     | IOS          |
| 1 PIA               | 33 IIC   | 1   | PIA |     | IIC          |
| 0 MPF               | 32 XSE   | 0   | MPF |     | XSE          |

Table 6. The ND-5000 Status Register

Norsk Data ND-05.020.1 EN

---

## Page 87

# Chapter 4 THE TRAP SYSTEM

The following pages give a short description of each individual status register bit. The use of each bit by the microprogram and hardware is outlined, and some implementational details are discussed, especially with regard to the trap system. Most of the bits can be set both by hardware and by microprogram, while a few can only be set by hardware. In the pipeline frame figures to the right of each description, the originating time and pipeline level for the bit in question are indicated.

## Bit 0

MPF, microprogram flag, is used by the microprogram to signal overlap in string macro-instructions.

|   |   |
|---|---|
| I | ║→ |
| M |   |
| A |   |
| F |   |

## Bit 1

PIA, privileged instruction allowed, is a copy of the PIA-bit in the domain information table of the currently executing domain. The bit can not be changed by the STI:= instruction. This bit is checked by microcode every time a privileged instruction is executed.

|   |   |
|---|---|
| I | ║→ |
| M | ↓ |
| A |   |
| F | ║→ |

## Bit 2

PD, part done, is used by the microprogram to signal that a macroinstruction is partially executed. This applies only to long macro-instructions, such as string instructions.

|   |   |
|---|---|
| I | ║→ |
| M | ↓ |
| A |   |
| F | ║→ |

## Bit 3

IR, instruction reference, is not used in the ND-500 architecture.

|   |   |
|---|---|
| I | • |
| M | ↓ |
| A |   |
| F | ║→ |

## Bit 4

PSD, process switch disable, is turned on and off by the microprogram in the SOLO and TUTTI macroinstructions. When on, ignorable traps never occur, and non-ignorable traps set the DE-bit, in addition to the non-ignorable trap bit. If PSD is on for too long a time, the DT-bit is set.

|   |   |
|---|---|
| I | ║→ |
| M | ↓ |
| A |   |
| F | ║→ |

Norsk Data ND-05.020.1 EN

---

## Page 88

# Chapter 4 THE TRAP SYSTEM

## Bit 5

Z, zero, is a data status bit. It cannot give traps.

| I  |   |   |   |   |
|----|---|---|---|---|
| M  |   |   | ↓ |   |
| A  |   |   |   |   |
| F  |   |   |   |   |

## Bit 6

C, carry, is a data status bit. It cannot give traps.

| I  |   |   |   |   |
|----|---|---|---|---|
| M  |   |   | ↓ |   |
| A  |   |   |   |   |
| F  |   |   |   |   |

## Bit 7

S, sign, is a data status bit. It cannot give traps.

| I  |   |   |   |   |
|----|---|---|---|---|
| M  |   |   | ↓ |   |
| A  |   |   |   |   |
| F  |   |   |   |   |

## Bit 8

K, flag, is a special bit. It easy to set, clear and test, both from micro and macroprogram. It is used for a variety of signalling purposes. It cannot give traps.

| I  |   |   |   |   |
|----|---|---|---|---|
| M  |   |   | ↓ |   |
| A  |   |   |   |   |
| F  |   |   |   |   |

## Bit 9

O, overflow, indicates integer overflow only. It is a data status bit that can give traps.

| I  |   |   |   |   |
|----|---|---|---|---|
| M  |   |   | ↓ |   |
| A  |   |   |   |   |
| F  |   |   |   |   |

## Bit 10

INR, inexact result, is not used in the ND-500. It should indicate that a floating operation resulted in an inexact number representation.

| I  |   |   |   |   |
|----|---|---|---|---|
| M  |   |   | ↓ |   |
| A  |   |   |   |   |
| F  |   |   |   |   |

## Bit 11

IVO, invalid operation, signals bad input data to several mathematical macroinstructions.

| I  |   |   |   |   |
|----|---|---|---|---|
| M  |   |   | ↓ |   |
| A  |   |   |   |   |
| F  |   |   |   |   |

Norsk Data ND-05.020.1 EN

---

## Page 89

# Chapter 4 THE TRAP SYSTEM

## Bit 12

DZ, divide by zero, is set by the microprogram when division by zero is performed.

| I |  |  |  |  |  |
|---|--|--|--|--|--|
| M |  | ↓ |  |  |  |
| A |  |  |  |  |  |
| F |  |  |  |  |  |

## Bit 13

FU, floating underflow, is set by the hardware or microprogram when floating underflow occurs.

| I |  |  |  |  |  |
|---|--|--|--|--|--|
| M |  | ↓ |  |  |  |
| A |  |  |  |  |  |
| F |  |  |  |  |  |

## Bit 14

FO, floating overflow, is set by the hardware or microprogram when floating overflow occurs.

| I |  |  |  |  |  |
|---|--|--|--|--|--|
| M |  | ↓ |  |  |  |
| A |  |  |  |  |  |
| F |  |  |  |  |  |

## Bit 15

BO, BCD overflow, is set by the hardware or microprogram when BCD overflow occurs.

| I |  |  |  |  |  |
|---|--|--|--|--|--|
| M |  | ↓ |  |  |  |
| A |  |  |  |  |  |
| F |  |  |  |  |  |

## Bit 16

IOV, illegal operand value, is set by the microprogram whenever an operand value is outside its legal range.

| I |  |  |  |  |  |
|---|--|--|--|--|--|
| M |  | ↓ |  |  |  |
| A |  |  |  |  |  |
| F | • |  |  |  |  |

## Bit 17

SIT, single instruction trap, is set at the end of each macroinstruction except RETT, but only as long as the corresponding trap enable bit is 1.

| I |  |  |  |  |  |
|---|--|--|--|--|--|
| M | ↓ |  |  |  |  |
| A |  |  |  |  |  |
| F |  |  |  |  |  |

Norsk Data ND-05.020.1 EN

---

## Page 90

# Chapter 4 THE TRAP SYSTEM

## Bit 18

BT, branch trace, is set whenever a jump in the execution flow occurs. It is always set by the GO, JUMPG, CALL, CALLG and RETURN instructions (except RETT). IFGO, IF ST GO and LOOP instructions only set this bit when a jump is performed. BT always remains 0 if the corresponding trap enable bit is 0.

| I | M | A | F |
|---|---|---|---|
| ↓ |   |   |   |
| unconditional |  |  | conditional |

## Bit 19

CT, call trace, is set whenever a CALL or CALLG instruction occurs. CT is not set if the corresponding trap enable bit is 0.

| I | M | A | F |
|---|---|---|---|
| ↓ |   |   |   |

## Bit 20

BPT, breakpoint trace, is set by the microprogram whenever a BP instruction is executed. Thereafter, a breakpoint trap is forced to occur, either by issuing an ISAMP command or by checking the BPT trap enable bit and jumping to the trap handling microroutine. The P-register has not yet been changed when the trap occurs; this conforms to the before category that this trap belongs to. If BPT is not enabled, execution of the microsequence for the BP instruction continues. The IIC trap condition is then set.

| I | M | A | F |
|---|---|---|---|
| ↓ |   |   |   |

## Bit 20

ATF, address trap fetch, is set when a program access falls within/outside a HL/LL interval. It avoids the setting of ATR and ATW, even if they are enabled.

| I | M | A | F |
|---|---|---|---|
| ↓ |   |   |   |

## Bit 22

ATR, address trap read, is set if a read data access falls within/outside a HL/LL interval. It is never set if ATF trap is enabled.

| I | M | A | F |
|---|---|---|---|
|   | ↓ |   |   |

Norsk Data ND-05.020.1 EN

---

## Page 91

# Chapter 4  THE TRAP SYSTEM

## Bit 23

ATW, address trap write, is set if a write data access falls within/outside a HL/LL interval. It is never set if ATF trap is enabled.

| I | ⬇ |  
|---|---|  
| M |---|  
| A |---|  
| F |---|  

## Bit 24

AZ, address zero, is set when address 0 is accessed either by the program or the data channel.

| instructions |
|--------------|
| I |  
| M |  
| A |  
| F |  
| data |

## Bit 25

DR, descriptor range, is set when an implicit or explicit descriptor-addressed operand-addresses a data item outside the range described by the descriptor.

| I | ⬇ |  
|---|---|  
| M |---|  
| A |---|  
| F |---|  

## Bit 26

IX, illegal index, is set or reset by the LIND/CIND instructions, depending on the limit check result within these instructions.

| I | ⬇ |  
|---|---|  
| M |---|  
| A |---|  
| F |---|  

## Bit 27

STO, stack overflow, is set/reset by GETB, ENTB, ENTS, ENTSN, INIT, and ENTM whenever the stack demand exceeds the limit set by the TOS register.

| I | ⬇ |  
|---|---|  
| M |---|  
| A |---|  
| F |---|  

## Bit 28

STU, stack underflow, is set by return instructions when there is no calling place to return to.

| I |   
|---|   
| M | ⬇ |   
| A |---|   
| F |---|   

## Bit 29

PRT, programmed trap, is only set/reset by the microprogram, and is used for signalling purposes.

| I |   
|---|   
| M | ⬇ |   
| A |---|   
| F |---|   

Norsk Data ND-05.020.1 EN

---

## Page 92

# Chapter 4 THE TRAP SYSTEM

## Bit 30

DT, disable process switch timeout, occurs when PSD has been on for more than 256 ISAMP or G, OOPS commands.

| I | ↓ |
|---|---|
| M |   |
| A |   |
| F |   |

## Bit 31

DE, disable process switch error, occurs if a non-ignorable or fatal trap is detected when PSD is on. The status bit of the offending trap is also set to 1. The timing of the detection depends on the timing of the offending trap.

| I | ↓ |
|---|---|
| M |   |
| A |   |
| F |   |

## Bit 32

XSE, index scaling error, is set when a post-index exceeds 32 bits after scaling has been performed.

| I |       
|---|
| M |
| A |
| F |

## Bit 33

IIC, illegal instruction code, is set when an illegal opcode execution is attempted. Some illegal opcodes are flagged in the IMAP, and they are never cached in the ICA system. Others have an ordinary IMAP entry and microcode entry point. They set the IIC bit from microcode.

|          | from IMAP | 
|----------|-----------| 
| I        | from µ-   | 
| M        | prog.     | 
| A        |           | 
| F        |           |

## Bit 34

IOS, illegal operand specifier, is set by the IDU or microcode when illegal operand specifiers are detected.

|         | from IDU  | 
|---------|-----------| 
| I       | from µ-   | 
| M       | prog.     | 
| A       |           | 
| F       |           |

## Bit 35

ISE, instruction sequence error, is set by hardware when a CALL does not call an ENTER, or an ENTER is not preceded by a CALL. In addition, the microprogram can signal ISE when a domain call is nested illegally.

| I | ↓ |
|---|---|
| M |   |
| A |   |
| F |   |

Norsk Data ND-05.020.1 EN

---

## Page 93

# Chapter 4 THE TRAP SYSTEM

## Bit 36

PV, protect violation, is set by the microprogram when a segment without a capability is accessed, or when an ALT or WRITE protection is violated. The microprogram decides to set this bit when IMM or DMM traps are handled.

| I | | |
| --- | --- | --- |
| M | | ↓ |
| A | |
| F | | |

## Trap 37

THM, trap handler missing, does not have an actual bit in the status register, because it would always be zero when tested. This trap is detected by microcode when no ENTT instruction, or an ENTT instruction with bad operands, is found as a trap handler entry. This trap is never handled in the same computer where the trap occurred, but is always reported to a supervising computer.

## Trap 38

PGF, page fault, is exactly the same type as trap 37, THM. Page fault is detected by the microprogram as a subgroup when traps from the IMM or DMM modules are handled.

## Trap 39

PWF, power failure, makes the microprogram execute the special power failure routine, and thereafter report the failure to the supervising computer.

## Trap 40 and trap 41

PRF, processor fault, and HWF, hardware fault, are reported to the supervising computer directly. They are used to indicate malfunctions in the CPU and memory systems.

## Bit 48

INRS, static inexact result, is included to conform to the IEEE floating-point standard. It is a status bit of the same type as Z, C and S, and cannot give traps.

| I | | |
| --- | --- | --- |
| M | | ↓ |
| A | |
| F | | |

Norsk Data ND-05.020.1 EN

---

## Page 94

# Chapter 4: THE TRAP SYSTEM

## Bit 49

IVOS, static invalid operation, is included to conform to the IEEE floating-point standard. It is a status bit of the same type as Z, C and S, and cannot give traps.

| I |   |
|---|---|
| M | ↓ |
| A |   |
| F |   |

## Bit 50

DZS, static divide by zero, is included to conform to the IEEE floating-point standard. It is a status bit of the same type as Z, C and S, and cannot give traps.

| I |   |
|---|---|
| M | ↓ |
| A |   |
| F |   |

## Bit 51

FUS, static floating underflow, is included to conform to the IEEE floating-point standard. It is a status bit of the same type as Z, C and S, and cannot give traps.

| I |   |
|---|---|
| M | ↓ |
| A |   |
| F |   |

## Bit 52

FOS, static floating overflow, is included to conform to the IEEE floating-point standard. It is a status bit of the same type as Z, C and S, and cannot give traps.

| I |   |
|---|---|
| M | ↓ |
| A |   |
| F |   |

IMM and DMM traps arrive from the memory management modules only when there is a cache miss in ICA or DCA, respectively. The micro-program then determines what trap number the IMM/DMM trap corresponds to. Possible trap numbers include 36, 38 and 41. When an IMM trap occurs as result of A-operand memory read or destination memory write, the IMM trap arrives one microclock too late to stop the destination clocking. Such microcoded sequences must tolerate this late arrival of the IMM trap.

Asynchronous traps that arrive from external sources include power failure, octobus traps and traps from the channel controlling the SSR loop. It must be possible for the microprogram to identify these traps. The easiest solution seems to be to include them together with IMM and DMM traps in a special microstatus register. Flags to indicate abnormal conditions in the caches or memory system should also be included in this register.

| IMM Trap |   |
|----------|---|
| I        |   |
| M        |   |
| A        |   |
| F        |   |

Norsk Data ND-05.020.1 EN

---

## Page 95

# Chapter 5 The Access Module

---

Norsk Data ND-05.020.1 EN

---

## Page 96

I'm sorry, there is no text or content on the page provided. If you have another page or need assistance with something else, feel free to let me know!

---

## Page 97

# Chapter 5 The Access Module

This chapter contains:

- **Functional description**, starting on this page
- **Hardware implementation**, starting on page 89
- **Software guide** for the access processor (MC68000), starting on page 101

The definitions of the two following terms are important:

1. **Access module** is the baby card.
2. **Access processor** is the MC68000 microprocessor situated on the access module.

## 5.1 Functional Description

The access module allows the ND-5000 to communicate with the outside world via the octobus. The octobus is used to pass interrupts between CPUs and I/O processors and controllers in the shared-memory environment around the multifunction bus (MFbus) system. The access module has local intelligence, provided by an MC68000 microprocessor called the access processor (ACCP), which passes messages more or less transformed between the octobus and the ND-5000 CPU.

Both the access module and the MFbus interface are parts of the ND-5000 CPU, but here they are separated from it for practical reasons.

*Norsk Data ND-05.020.1 EN*

---

## Page 98

# Chapter 5 THE ACCESS MODULE

```
Octobus
┌────────┬───────────────────────────┬────────┐
│ ND-120 │           ND-5000 CPU     │ Shared │
│  CPU   │┌─────────────┬────────────┐│ memory │
│        ││ Octobus     │ ACCP       ││        │
│        ││ interface   │ (68000)    ││        │
│        │└─────────────┴────────────┘│        │
│        │ THE ACCESS MODULE          │        │
│        └────────────────────────────┘        │
│                         Multi-function     │
│                         bus interface     │
└─────────────────────────────────────────────┘
```

Multifunction bus (MFbus)

*Figure 20. The Access Module Interfaces*

## 5.1.1 Access Module Tasks

The tasks of the access module are different depending on what situation the ND-5000 is in:

- **Power-up situation**

  After power-up, the main task is to load control store.

- **Testing/debugging of hardware**

  During the testing or debugging of hardware, the access module is used to load and execute test instructions or programs into the control store, and monitor the execution. It can be operated from the ND-120 via the octobus, or via an ACCP plug card. The ACCP can access the MFbus memory by making software simulated memory requests via the ND-5000 MFbus interface. This is used to load the microprogram from MFbus memory to the control store.

- **Program execution**

  During macroprogram execution, the most important task of the access module is to pass messages used by the I/O system between the octobus and the ND-5000 CPU. Errors like time-out, parity error, power failure and, possibly, panel examine functions are also handled by the access module.

*Norsk Data ND-05.020.1 EN*

---

## Page 99

# Chapter 5 THE ACCESS MODULE

## 5.1.2 Interface Between the ND-5000 and the ND-120

```
     Octobus
--------------------------
    |      |      |
    v      v      v
|-------| |-------| |-------|
| ND-120| |ND-5000| |Shared |
|       | |       | |memory |
|-------| |-------| |-------|
    |       |        |
    v       v        v
The Multifunction Bus
Figure 21. The ND-5000 Environment
```

An the ND-120 is used as an I/O processor for the ND-5000. The connections between the ND-120 and the ND-5000 consist logically of the octobus and the shared memory on the MFbus.

### Octobus

The octobus is a serial, self-arbitrating bus used to transfer messages between up to 62 devices. This gives a simple and elegant way of connecting several processors in a shared-memory system. The octobus is used to inform other processors what to do with the data in the shared memory.

The octobus is used for messages to initiate operations. As a general rule, these operations work on data in shared memory in the MFbus system. Thus, the octobus is normally not used to transport data. The only exception is during debugging and testing.

There can be several I/O processors and several ND-5000s connected to the shared memory. Compared to the existing configuration in the ND-120/ND-500 systems, the octobus replaces one pair of interface modules for each ND-500 CPU that is connected to the ND-120.

The time to send one byte of information over the octobus is 8 µs when it is operated at the maximum speed of 4 Mhz.

See appendix 2 on page 315 for a detailed description of the octobus communication protocol.

---

Norsk Data ND-05.020.1 EN

---

## Page 100

# Chapter 5 THE ACCESS MODULE

## SHARED MEMORY

In the communication between the ND-120 and ND-5000, shared memory is used for busy waiting on semaphores using the test-and-set function. This allows several processes to share a common device by reserving and freeing a common semaphore. In a test-and-set cycle, the memory is locked between the read and write cycles to guarantee that only one process reserves a free semaphore. 

Norsk Data ND-05.020.1 EN

---

## Page 101

# Chapter 5 THE ACCESS MODULE

## 5.1.3 Interface Between the Access Module and the ND-5000

The interface between the ACCP and the ND-5000 CPU consists of:

- AIB - Access module Input Buffer
- AOB - Access module Output Buffer
- APR - Access module Parallel Register
- ASR - Access module Serial Register

The AIB/AOB is connected to the lower 16 bits of the ND-5000 data bus (DB), while the ASR/APR is connected to the upper 16 bits of DB. The AIB/AOB consists of straightforward two-way registers, and can be accessed directly by the microprogram as an A-operand or destination. However, the ASR/APR is made up of two SSR devices (serial shadow register devices) and requires a special microprogram sequence, because of the complicated internal arrangement of these devices.

The ASR/APR is not used during program execution, but only during testing when access to the entire 32-bit bus width is desired. The ASR/APR is also used during 32-bit access to MFbus memory, i.e. when loading the control store.

| Access module address bus AD(0-15) | | ND-5000 data bus DB(0-31) |
|------------------------------------|---|-------------------------|
| AIB/AOB                            | =>| DB(0-15)                |
| ASR/APR                            | =>| DB(16-31)               |

*Figure 22. The 32-bit Interface Access Module - ND-5000*

Norsk Data ND-05.020.1 EN

---

## Page 102

# Chapter 5 THE ACCESS MODULE

When the ND-5000 is executing programs, only AIB/AOB is used in the communication with the access module. For synchronizing the communication via these registers, full two-way handshake is provided by the flags AIBF and AOBF. Both flags can be read by both sides. In addition, there is a trap signal, ATRAP, which is set by ACCP programs. The microprogram in the ND-5000 reads AOB as an A-operand and writes to AIB as a special destination.

![Figure 23. The 16-bit Interface ACCP - ND-5000](image_path)

When the microprogram writes data to AIB, the flag AIBF is automatically set. The contents of AIB can then be read by ACCP, and AIBF must be explicitly reset by ACCP after AIB is read. The microprogram can also read AIBF so that the data in AIB is not overwritten before it is read by ACCP.

The AOB is used by the ACCP to give messages to the ND-5000. When the ACCP has written to AOB, the ACCP sets ATRAP and the flag AOBF. The flag AOBF and the trap signal ATRAP are automatically reset when the ND-5000 reads AOB. AOBF can be read back by ACCP so that data in AOB is not overwritten before it is read by the ND-5000. By reading AOBF, the ACCP also finds out when a trap is handled.

Norsk Data ND-05.020.1 EN

---

## Page 103

# Chapter 5 THE ACCESS MODULE

## 5.2 HARDWARE IMPLEMENTATION

The access module is controlled by an MC68000 microprocessor called the access processor (ACCP). The ACCP is connected to the necessary external devices through the 16-bit bus called AD(0-15). To simplify the decoding hardware, only the four upper bits of the address bus, MA(23-20), are used for the device selection. This reserves a 1 Mbyte area for each device. However, since only a fraction of this is used, the size of each device must be kept in mind when writing software, to avoid unintended selection.

In addition to ROM and RAM, the ACCP is connected to the octobus controller and a real-time clock.

There is a PAL which monitors the output of the octobus controller. If the code MCL is detected, the PAL sends out MCL (reset) to both the ACCP and the ND-5000. The ACCP is also reset during power-up and when the signals BPFAIL and BNAVAIL (AND'ed) in the MFbus are activated. Figure 24 shows a block diagram of the access module with surroundings.

Norsk Data ND-05.020.1 EN

---

## Page 104

# Chapter 5: The Access Module

## Access Module Baby Card

| Component                               | Description                           |
|-----------------------------------------|---------------------------------------|
| The Octobus Controller Gate Array (OCTC)| Octobus                               |
| MCL PAL                                 |                                       |
| FIFO                                    |                                       |
| 32K RAM                                 |                                       |
| 128K ROM                                |                                       |
| UART                                    |                                       |
| Interrupt PAL                           |                                       |
| Access Module Address Bus MA(1-23)      |                                       |
| Decoder                                 |                                       |
| MC68000 (ACCP)                          |                                       |
| Master Clear                            | Access Module Data Bus AD(0-15)       |
| Console terminal                        |                                       |

## Mother Card

| Component                               | Description                           |
|-----------------------------------------|---------------------------------------|
| MIR (0-127)                             |                                       |
| Micro-Instr. Reg.                       |                                       |
| Serial Shadow Reg.                      |                                       |
| Micro-Instr. Shadow Reg. Loop           |                                       |
| Access Module Pipeline Register         |                                       |
| Access Module Input Buffer              |                                       |
| Access Module Shadow Register           |                                       |
| Access Module Output Buffer             |                                       |
| The Bus Adapter Gate Array (BADAAP)     |                                       |
| Access Module Status Reg.               |                                       |
| Access Module Control Decoder           |                                       |
| Access Module Mode Reg.                 |                                       |
| ND-5000 Data Bus DB(16-31)              |                                       |
| DB (0-15)                               |                                       |
| DB(0-31)                                | IB(0-31)                              |
| MFbus Channel Transceiver               |                                       |

## Control Store Baby Card

| Component                               | Description                           |
|-----------------------------------------|---------------------------------------|
| Control Store                           |                                       |
| Micro-Address Reg.                      |                                       |

### Figure 24. The Access Module Block Diagram

Norsk Data ND-05.020.1 EN

---

## Page 105

# Chapter 5 THE ACCESS MODULE

## INTERRUPT

To increase the software flexibility and performance of the ACCP, interrupt is provided. Autovector interrupt is used, which means that there is only one interrupt handler for each of the seven interrupt levels. (However, each interrupt handler can handle several interrupt sources by reading status.)

After an interrupt acknowledge, the interrupt PAL generates a signal, telling the processor to generate a fixed interrupt vector according to the actual interrupt level. This vector points to a location in the vector table (address 64-7C hex) where the start address of the interrupt handler is located.

There are eight possible interrupt sources, and each can be de-selected by cutting a strap. The sources are given on page 105.

## SPEED CONSIDERATIONS

To simplify the generation of control signals from the ACCP to the ND-5000, the MC68000 clock is synchronous with the ND-5000 clock. Twice the ND-5000 clock period is used, which means that the MC68000 must be the 10MHz version.

There is a shift register which determines the number of wait cycles that are inserted in a memory cycle. By selecting the proper shift-register output for the SLOW and FAST signals, optimum performance is assured. The FAST signal is used to generate acknowledge (DTACK) in all memory cycles except the UART (i.e. addresses lower than C00000 hex). To allow for no wait cycles for the FAST signal, 250ns EPROMs and 150ns RAMs are used. (With typical timing, worst case requires 200ns for EPROM and 120ns for RAMs.) The SLOW output gives five wait states for the UART. 

Norsk Data ND-05.020.1 EN

---

## Page 106

# 5.2.1 Device Descriptions

## ROM/RAM

There are three pairs of 28-pin byte-wide memory sockets. The lower pair contains 27256 or 27512 EPROM devices and the upper pair contains 8x8K or 8x32K static RAMs. The middle pair can contain either EPROM or RAM. The desired configuration is selected by straps which must be placed properly according to the device type used. Typically, two 27512 and four 8x8K RAMs are used, giving 128 Kbyte of ROM memory and 32 Kbyte of RAM. The straps for this configuration are default in the print. The EPROMs start at address zero where the vector table is located.

## Octobus Controller (OCTC)

The octobus controller is a gate array chip that takes care of the communication with the serial, self-arbitrating octobus. This chip is controlled by internal status and control registers. The two least significant address bits, A1 and A2, are used to select the different registers inside the OCTC. These registers and the meanings of the different bits are given below.

The two speed-selection signals and the serial initialization-signals are supplied directly from the BADAP chip. The 16MHz signal is supplied from the MFbus.

---

## Page 107

# Chapter 5 THE ACCESS MODULE

Registers in the octobus controller:

## 2R RECEIVER STATUS (RSTS)

| Bits  | Description                      |
|-------|----------------------------------|
| 0-1   | Not used                         |
| 2     | IR: Input ready                  |
| 3-7   | Not used                         |
| 8-13  | ID: Ident-number of this station |
| 14,15 | Not used                         |

## 2W RECEIVER CONTROL WORD (RCONW)

| Bits  | Description |
|-------|-------------|
| 0-2   | Not used    |
| 3     | TM: Test mode |
| 4     | Not used    |
| 5     | RA: Read all |
| 6-15  | Not used    |

## 4W TRANSMITTER DATA (TDATA)

| Bits  | Description |
|-------|-------------|
| 0-7   | INFO        |
| 8-13  | DEST        |
| 14,15 | TYPE        |

## 6R TRANSMITTER STATUS (TSTS)

| Bits  | Description                     |
|-------|---------------------------------|
| 0-1   | Not used                        |
| 2     | RQ: Request on (transmitting)   |
| 3     | RT: Ready for transfer          |
| 4     | ER: Error, incl. OR of bits 5-8 |
| 5     | RE: Retry counter zero          |
| 6     | NP: Not present (no answer)     |
| 7     | BU: Busy (FIFO full)            |
| 8     | PA: Parity error                |
| 9-14  | Not used                        |
| 15    | M: Master                       |

## 6W TRANSMITTER CONTROL WORD (TCONW)

| Bits  | Description                    |
|-------|--------------------------------|
| 0-3   | Not used                       |
| 4     | CD: Clear/initialize device    |
| 5     | RM: Remove Master              |
| 6     | FC: FIFO clear                 |
| 7,8   | Not used                       |
| 9-15  | RC: Retry counter              |

The specific register address is obtained by adding the register number to the OCTC base address. Only word access is allowed.

Norsk Data ND-05.020.1 EN

---

## Page 108

# First-in-First-out Buffer (FIFO)

The received data is not read directly from the octobus chip, but is first buffered in a FIFO (first-in-first-out buffer). The FIFO contains 16 words of 16 bits. A flag in the status register (ASTS) indicates when a word is valid on the FIFO output. Each time the FIFO is read, the FIFO queue is automatically advanced, and when the last word is read, the status flag is reset.

# Access Module Input/Output Buffers (AIB/AOB)

The lower 16 bits of the Data Bus (DB) of the ND-5000 are reached via these registers. The AIB is used to read DB, and the AOB is used to write to DB.

See section 5.1.3 on page 87 for details about the communication between the ND-5000 and the ACCP.

## AIB

The AIB can be loaded from the ND-5000 data bus (DB) by either the control command CAIB from ACCP itself, or by the microprogram writing to destination AIB. When the microprogram writes data to AIB, the flag AIBF in ASTS is automatically set. The contents of AIB can then be read by ACCP. AIBF should be reset by the control command RAIBF when ACCP has read the buffer. The microprogram can also read AIBF so that data in AIB is not overwritten before it is read by ACCP.

## AOB

The AOB is used by the ACCP to give messages to the ND-5000. The AOB can be read by the microprogram as an A-operand source. When ACCP writes to AOB, the ACCP then sets the AOBF flag. If the ND-5000 is to be trapped, the trap signal ATRAP can also be set. AOBF and ATRAP are automatically reset when the ND-5000 reads AOB.

ACCP can also enable AOB to the DB by the EAOB bit in the control device (ACON). This is only allowed when the ND-5000 is in test mode.

Norsk Data ND-05.020.1 EN

---

## Page 109

# Chapter 5 THE ACCESS MODULE

## ACCESS MODULE PARALLEL/SERIAL REGISTERS (APR/ASR)

These registers are the interface between the ACCP and the serial loop to the microinstruction register (MIR), and to the upper 16 bits of DB. As seen from ACCP, the parallel register APR is a read-only register and the serial register is a write-only register. However, it is possible to load APR and read ASR by commands sent to the control device (ACON).

The serial shadow-register loop is used to load control store through the microinstruction serial register (MISR). The serial registers are connected in two loops, where the lower byte of ASR is connected to the even bytes of MISR and the upper byte of ASR to the odd bytes of MISR. This is shown in figure 25. Bit 7 of byte 15 corresponds to bit 127 in the control word, bit 7 of byte 14 to bit 119, bit 0 of byte 1 to bit 8 and bit 0 of byte 0 to bit 0 of the control word.

```
127              MISR
  15    13    11    9     7     5     3     1  
  [====][====][====][====][====][====][====][==]    
  [====][====][====][====][====][====][====][==]
  14    12    10    8     6     4     2     0  
119                                         8   0

---------------------------- MISR ---------------------------│─ ASR ─│

Figure 25. The Serial Shadow-register Loop
```

Each box in figure 25 represents one SSR device of type Am29818 or equivalent. This device has an 8-bit shift register together with an 8-bit parallel register. The control of the SSR loops from the ACCP is managed mainly by the control device ACON (see page 99).

## SERIAL INTERFACE (UART)

The ACCP is equipped with a dual UART that provides one current-loop serial-interface and one RS232 via the ACCP plug card. 

Norsk Data ND-05.020.1 EN

---

## Page 110

# Bus Adapter (BADAP)

The bus adapter chip (BADAP) is physically placed on the mother card, and it takes care of the handshake between the ND-5000 and the MFbus. The BADAP contains several registers which can be programmed by the ACCP. The BADAP has an 8-bit connection to the AD bus, so the chip must be addressed by odd byte-addresses as given below. (Base + register number.)

| Register | Description          | Bits |
|----------|----------------------|------|
| 1R       | Slot number          | 8    |
| 1W       | Timeout counter      | 8    |
| 3R       | String counter       | 16   |
| 3W       | String counter       | 16   |
| 5R       | Device status        | 8    |
| 5W       | Device control       | 8    |
| 7R       | Not used             |      |
| 7W       | Not used             |      |

The 16-bit registers are loaded by writing subsequently to the same address with the upper byte first.

The status register in BADAP has four bits that indicate memory errors. These bits are OR'ed to give memory-error interrupt (MEMERR). When this occurs, the interrupt routine must read the DDAT bit in ASTS to find out if the error is on the instruction or data channel.

The four memory-error bits in the BADAP status register are:

| Bit | Code | Description            |
|-----|------|------------------------|
| 4   | TO   | Timeout, non-bus request |
| 5   | PA   | Parity error           |
| 6   | BE   | Bus error, timeout     |
| 7   | BF   | Bus fatal error        |

---

## Page 111

# Chapter 5 THE ACCESS MODULE

## ACCESS MODULE STATUS REGISTER (ASTS)

The status register is a 16-bit read-only register. The different bits are defined below.

| BIT | NAME     | POLARITY | FUNCTION                                                                 |
|-----|----------|----------|--------------------------------------------------------------------------|
| 0   | AIBF     | 1        | Access module input buffer flag                                          |
| 1   | AOBF     | 1        | Access module output buffer flag                                         |
| 2   | OBREC    | 1        | Octobus receive-FIFO flag                                                |
| 3   | OSTOP    | 0        | Octobus emergency interrupt (Used by TERMINATE)                          |
| 4   | DMBUSY   | 0        | Data memory busy                                                         |
| 5   | IMBUSY   | 0        | Instruction memory busy                                                  |
| 6   | DMMBUSY  | 0        | Data memory management busy                                              |
| 7   | IMMBUSY  | 0        | Instruction memory management busy                                       |
| 8   | CSERR    | 0        | Control store error. (Duplicated bits not equal)                         |
| 9   | EDD      | 0        | Data memory cycle. Read when memory error to distinguish Instruction/Data channel error. |
| 10  | ALIVE    | 1        | CPU alive watch-dog signal                                               |
| 11  | ACCPTRAP | 0        | Tells the ACCP that data in AIB is to be interpreted by the ACCP instead of being sent directly to octobus. Set by microprogram in MDR. |
| 12  | STOP     | 1        | Microprogrammed stop                                                     |
| 13  | POWFAIL  | 0        | Power failure                                                            |
| 14  | ARMED    | 0        | From tracer. Goes off when tracer has triggered.                         |
| 15  | TEST     | 1        | Test bit for synchronization with production test equipment (Fluke, etc.)|

*Table 7. Access Module Status Register (ASTS)*

Norsk Data ND-05.020.1 EN

---

## Page 112

# Access Module Modus Register (MREG)

The ACCP modus register consists of two write-only registers which are used to set static control signals. The lower byte is reset by hardware reset, while the upper byte is reset when the microprogram in the ND-5000 reads AOB. Three of these bits can be read as an A-operand by the microprogram. Each part of the modus register can be addressed separately, with odd byte address for the lower part and even byte address for the upper part.

| BIT | NAME   | POLARITY | FUNCTION |
|-----|--------|----------|----------|
| **NOTE!** Bits 0-7 are reset by hardware at Master Clear and power-up: |
| 0   | FAST   | 1        | Set CPU clock speed to fast (63 ns) |
| 1   | SLOW   | 0        | Set CPU clock speed to slow (156 ns) |
| 2   | AMODE  | 0        | Put CPU in ACCP mode, i.e., stop the CPU and inhibit access to the buses, except by ACCP |
| 3   | MRUN   | 1        | Start microprogram |
| 4   | ORESEN | 1        | Octobus Reset Enable. To be set by a watchdog timeout or via a special octobus command |
| 5   | MLOCK  | 0        | Memory Lock, for ACCP semaphore cycles in MFbus |
| 6   | MR     | 0        | Master Reset. Resets all states in the CPU |
| 7   | MASKOBT| 0        | MASK Octobus Transmit interrupt |
| **NOTE!** Bits 8-15 are reset by hardware when the ND-5000 reads AOB: |
| 8   | BUSTEST| 1        | Allows data to be routed from DB via XB and IB, and back to DB via MPC bus. (Only in AMODE.) |
| 9   | AECC   | 1        | ACCP Enable Control Cache |
| 10  | AECS   | 1        | ACCP Enable Control Store |
| 11  | OMESS  | 1        | Octobus Message in AOB |
| 12  | ATRAP  | 1        | ACCP Trap signal to the ND-5000 |
| 13  | FATAL  | 1        | ACCP Fatal trap signal to the ND-5000 |
| 14  | AOBF   | 1        | Flag indicating that AOB contains valid data |
| 15  | OBACT  | 1        | Octobus Activity LED. (Must be set by ACCP) |

*Table 8. Access Module modus register (MREG)*

Norsk Data ND-05.020.1 EN

---

## Page 113

# ACCP Control Decoder (ACON)

To control devices not directly connected to the AD bus, this decoder is used to generate different strobe pulses. The ACON is a write-only device and the bit pattern written is decoded to define the operation. A code on the five lower bits, together with one or more of the four upper bits, is used to generate the desired command.

- Bit 15 = 1 AEDRL: Enable MPC(31-0) to DB(31-0)
- Bit 14 = 1 EAOB: Enable AOB(15-0) to DB(15-0)
- Bit 13 = 1 MODE: Force MODE of SSRs to 1 (MIR/MISR,APR/ASR)
- Bit 12 = 1 ASDI: Force serial data input of SSR to 1

Bit (4-0) COMMAND: Command code as defined below

| COMMAND (hex) | NAME    | POLARITY | FUNCTION                                          |
|---------------|---------|----------|---------------------------------------------------|
| 0h            | DUMMY   |          | No action                                         |
| 1h            | TRIG    | 0        | Trigger for tracer                                |
| 2h            | CLRALIVE| 0        | Resets ALIVE flip-flop                            |
| 5h            | RAIBF   | 0        | Reset AIBF flag and clear MASKAIBF flip-flop      |
| 6h            | WCS     | 0        | Write control store                               |
| 7h            | MASKAIBF| 1        | Mask AIB-flag interrupt                           |
| 9h            | CAIB    | 1        | Clock AIB                                         |
| Ah            | ALWAD   | 0        | ACCP load write address                           |
| Ch            | ADWRQ   | 0        | ACCP data write request on DMPC                   |
| Dh            | ADRRQ   | 0        | ACCP data read request on DMPC                    |
| Fh            | ADCLK   | 1        | DCLK to ASR                                       |
| 10h           | MDCLK   | 1        | DCLK to MISR                                      |
| 11h           | CAPR    | 1        | PCLK to APR                                       |
| 13h           | CAPRAIB | *)       | CAIB and CAPR                                     |
| 14h           | SHIFT   | *)       | ADCLK and MDCLK (not used)                        |
| 15h           | ARMA    | 0        | ACCP reclock MAR                                  |
| 16h           | ARIA    | 0        | ACCP reclock IAR and MIBT                         |
| 17h           | ARMI    | 0        | ACCP reclock MIR with ECMIR                       |
| 18h           | AMIRCK  | 0        | ACCP reclock MIR without ECMIR                    |
| 1Ah           | ARAL    | 0        | ACCP reclock ALU                                  |

*) These commands generate a combination of the commands listed. This means that there is no separate signal from the PALs for these commands.

_Table 9. ACON Commands_

---

## Page 114

# Multifunction Bus Channel (MFBC)

All ACCP access to the MFbus memory is made when the ND-5000 is in AMODE. AMODE means that only the ACCP can control the buses on the ND-5000. This memory access is not time critical, so in order to simplify the hardware, the ACCP software does a memory access by issuing a sequence of commands to the MFbus interface.

To start a write request, the address must be loaded in A0B/ASR and the command ALWAD (ACCP Load Write Address) is given to ACON. Then the data to be written is loaded in A0B/ASR and the write request is given by the command ADWRQ.

To start a read request, the address must be loaded in A0B/ASR and the command ADRRQ must be given.

For synchronizing to memory, the status-bit DMBUSY is used. DMBUSY is switched on when ALWAD or ADRRQ is performed, and off when data ready from memory is received.

Norsk Data ND-05.020.1 EN

---

## Page 115

# Chapter 5 THE ACCESS MODULE

## 5.3 ACCP SOFTWARE

This section gives an overview of the software in the MC68000 access processor (ACCP). The main part of the section gives the specifications for the commands used to activate the ACCP library routines. In addition, a general description of the octobus communication, the console handling and the MC68000 console monitor is given.

The ND-5000 is compatible with the new I/O system (DOMINO). This means that messages to/from the I/O processor(s) are sent over the octobus to initiate operations. As a general rule, these operations work on data in shared memory in the MFbus system. Thus, the octobus is normally not used to transport data. The only exception is during debugging and testing.

The ND-5000 uses the access processor to communicate with the octobus, as illustrated in figure 26. The interface between the ND-5000 and the ACCP is via the access module input/output buffers (AIB/AOB) with two-way handshake flags (see page 87).

The ACCP is equipped with a dual UART that provides one current-loop serial interface, and one RS232 via the ACCP plug card. One of these interfaces is used for a console terminal from which the MC68000 console monitor can be run. The console is also used as an output device for error messages during the communication between the ND-120 and ACCP.

```
| Console      |                                           |
| ------------ | ----------------------------------------- |
|              | To the ND-120                             |
+--------------+-------------------------------------------+
| Octobus      | Octobus inter.f.                          |
|              | ACCP (68000)  ND-5000 CPU  MFbus inter-   |
|              | face                                      |
|              +-------------------------+                 |
|              | ACCESS MODULE           |                 |
|              +-------------------------+-----------------+
|                                                         |
|                                  MFbus                  |
+---------------------------------------------------------+

Figure 26. The ND-5000 and its Interfaces
```

The octobus driver version 5 is implemented, and the ACCP accepts data from the ND-120 both via octobus and the serial line. (The octobus driver version 3 is used over the serial line.) The octobus driver can be tested manually with the commands SEND MULTI OCTOBUS and RECEIVE MULTI OCTOBUS. A message typed on the console can then be sent to the desired destination. (It is also possible to send to yourself.)

Norsk Data ND-05.020.1 EN

---

## Page 116

# 5.3.1 Octobus Messages

The communication over octobus follows the octobus protocol version 5 as described in appendix B on page 315. This defines three message types:

1. Kicks

2. Idents

3. Multibyte messages

The ACCP itself responds only to multibyte messages to OMD numbers 0 and 3 (OMD = Octobus Message Device). OMD 0 is reserved for octobus test programs, while OMD 3 is used to access the ACCP library commands. Kicks, idents and multibyte messages to OMD number other than 0 and 3 are written directly to the microprogram via AOB.

In the other direction, all data sent from the microprogram to the ACCP via the AIB register is sent directly to the octobus, when kicks are enabled and the ACCPTRAP-bit in the access module status register (ASTS) is not set (See the section *Microprogram Messages to ACCP* on page 106.) This means that no data checking or protocol handling is done by the ACCP in the communication between the ND-5000 microprogram and the octobus. Only the hardware status of the octobus itself is performed by fast assembly code.

When ACCP traps ND-5000 because of an octobus message, the status bit OMESS is set to distinguish this from other ACCP traps, i.e., the ACCP-MICROTRAP command from the ND-120 to the ACCP. (The name OMESS is used rather than OKICK in older terminology since this covers all octobus traffic to the microprogram.)

ATRAP is always set during asynchronous messages to the microprogram (octobus kicks, etc.). ATRAP is not set when the microprogram asks for data from the ACCP (BADAP status).

Norsk Data ND-05.020.1 EN

---

## Page 117

# Chapter 5 THE ACCESS MODULE

Figure 27 illustrates the path between the octobus and the ND-5000 as provided by the ACCP.

| Multibyte messages     | Kicks/Idents          |
|------------------------|-----------------------|
| OMD = 3                | Multibyte, OMD > 3    |
| Octobus driver         |                       |

Console

Console command interpreter

| ACCP Library                          |
|---------------------------------------|
| Hardware dependent routines           |
| Microprogram dependent routines       |

ATRAP

| ND-5000 Hardware   | ND-5000 Microprogram | ND-5000 Macroprogram |
|--------------------|----------------------|----------------------|

*Figure 27. Command flow between the Octobus and the ND-5000*

Norsk Data ND-05.020.1 EN

---

## Page 118

# 5.3.2 Console Monitor

Most ACCP library functions can be called directly from the console. The available commands are listed below.

```
CHECK-ALIVE  
CONTINUE-MICROPROGRAM  
DUMP-LOCAL-MEMORY <Address> <Wordsize/halfword/>  
DUMP-LOCAL-REGISTER  
HELP <Command>  
LOAD-AOB16 <Data (16)>  
LOAD-AOB32 <Data (32)>  
LOAD-CONTROL-DECODER <Data (16)>  
LOAD-CONTROL-STORE <CS address> &  
<127-112> <111-096> <095-080> <079-064> <063-048> <047-032> <031-016> <015-000>  
LOAD-MAR <CS address>  
LOAD-MIR &  
<127-112> <111-096> <095-080> <079-064> <063-048> <047-032> <031-016> <015-000>  
LOAD-modus register < Upper byte> < Lower byte>  
LOOK-AT-CONTROL-CACHE <CC address>  
LOOK-AT-CONTROL-STORE <CS address>  
LOOK-AT-LOCAL-MEMORY <Address>  
LOOK-AT-MEMORY <Address>  
LOOP-ON-NEXT-COMMAND <Suppress output text ?>  
MAIN-FORMAT <BASE (HEX,OCT,DEC)>  
READ-ACCP-STATUS  
READ-AIB16  
READ-AIB32  
READ-CPU-MODEL  
READ-ECO-LEVELS  
READ-MIR  
RECEIVE-MULTIBYTE-OCTOBUS  
RECEIVE-OCTOBUS  
RESET-CPU  
RESTART-MICROPROGRAM <CS address> <Interval>  
RUN-LONG-SELFTEST  
RUN-SHORT-SELFTEST  
SEND-KICK-OCTOBUS <DESTINATION><Kick value (process)>  
SEND-MULTIBYTE-OCTOBUS <Destination><Subprocess><Message>  
SEND-OCTOBUS <Data (16)>  
SET-CLOCK-SPEED <Clock speed {Slow,Normal,Fast}>  
SET-INTERRUPT-MASK <Interrupt mask>  
SET-KICK-TIMEOUT <Kick timeout (ms)>  
SET-SERIAL-LINE <Enable ND-120 communication via serial line ? (Y/N)>  
START-MICROPROGRAM <CS address>  
STOP-MICROPROGRAM  
TEST-BUFFERS <ASR/AOB>  
TEST-BUSLOOP <Test pattern>  
TEST-MEMORY <From address> <To address>  
TRACE-COMMUNICATION-DATA <Trace communication data to console? (Y/N)>  
VALUE <Convert number>  
```

Norsk Data ND-05.020.1 EN

---

## Page 119

# Chapter 5 THE ACCESS MODULE

## 5.3.3 INTERRUPTS

The priority levels of the different sources are programmed in the AINT\> PAL. These interrupt sources are connected (via a strap field, straps 8 to 16 on the ACCP):

| Level | Description                              |
|-------|------------------------------------------|
| 7     | POWFAIL + OCTOBUS EMERGENCY              |
| 6     | MEMERR MF-bus (multiport) memory error   |
| 5     | UART UART (the ND-120, console)          |
| 4     | AIBF * /MASKAIBF AIB flag with mask      |
| 3     | OBREC Octobus receive                    |
| 2     | OBTRA Octobus transmit                   |

*Table 10. ACCP Interrupt Levels*

The command SET INTERRUPT MASK can be used to disable interrupts on levels including and below the level specified.

## 5.3.4 AIB FLAG OPERATION

When kicks are enabled, the AIB flag generates an interrupt to the ACCP on level 4 when the microprogram loads AIB. For all other uses of the AIB (i.e. ACCP Mbus memory requests or microprogrammed tests), the AIB flag is polled by the ACCP.

To avoid a deadlock situation, AIB flag interrupt is on a higher level than the octobus. This might occur if a kick was received from octobus when a former kick was not read from AOB. If AIB is also busy and the microprogram tries to send a kick to ACCP via AIB, both ACCP and the microcode wait for each other, since the AIB interrupt would not be recognized if the ACCP waited for AOB to be empty on the highest level.

## 5.3.5 AOB FLAG OPERATION

When the ACCP wants to load data to the microprogram via AOB, the AOB flag is set by software in the ACCP. When the microprogram reads AOB, the AOB flag is reset by hardware. This is used together with ATRAP and OMESS when an octobus word is received by the ACCP which is not part of a multibyte message for ACCP. Normally this is kick to the microprogram, but it can also be idents and multibyte messages. If OMESS is not set together with ATRAP, it is a message from the ACCP itself. Also see the next section.

Norsk Data ND-05.020.1 EN

---

## Page 120

# 5.3.6 ACCP Messages to Microprogram

The ACCP can trap the microprogram and transfer data in AOB by setting ATRAP, and not OMESS. This is used by the command ACCP MICROTRAP. (For details, see the command specification on page 113.) The reason for going via the ACCP and not sending directly to the microprogram is that there is no octobus driver for handling multibyte messages in the microprogram.

# 5.3.7 Microprogram Messages to ACCP

The microprogram can request service from the ACCP by setting the ACCPTRAP in the modus register and loading a command in AIB. As for octobus traffic, this gives an interrupt to the ACCP on level 4. The commands defined are given below:

| Command | Function |
|---------|----------|
| 1       | Get system parameters. The values given to the ACCP by the command LOAD SYSTEM PARAMETERS are sent to the AOB in three 16-bit transfers. |
| 2       | Get ASTS + BADAP status. These status registers are sent to the AOB in two 16-bit transfers and are used at memory error. The upper byte of BADAP status contains slot number in bits 4-0 (position in the MFbus card rack) as shown below. (ASTS is not valid unless after a memory error.) |

|        | 15          | 12       | 8    | 7          | 0    |
|--------|-------------|----------|------|------------|------|
| ACCP status |             |          |      |            |      |
| BADAP status | Slot (5 bits) |        |      |            |      |

| 3       | Get CPU type and model. The CPU type is given in bits 6 to 4, and CPU model is given in bits 3 to 0. (The ACCP asks the MFbus channel controller for these parameters via octobus after self-test.) |

The microprogram must wait for the AIBF flag to turn off before setting the ACCPTRAP bit and messages are sent. It must also wait until AIBF is turned off again before ACCPTRAP is reset. The microprogram must then wait for AOBF to be set, and then test

Norsk Data ND-05.020.1 EN

---

## Page 121

# Chapter 5 THE ACCESS MODULE

whether ATRAP is also set. If ATRAP is not set, the data read is the answer from the ACCP. But if ATRAP is set, the data in AOB is messages from the octobus (kick, etc.), which must be handled by the microprogram before waiting for the requested response from the ACCP. This ensures that the octobus traffic is not mixed with messages between the ACCP and the microprogram.

## 5.3.8 MEMORY ERROR

When the ND-5000 encounters a memory error, this is detected by the ACCP by an interrupt. The ACCP then stops the microprogram, performs a reset of the CPU and restarts the microprogram in the memory-error handler in CS-address 5. This handler asks the ACCP for ASTS and BADAP status, tries to write a message in the message buffer about the memory error, and sends a kick to the ND-120.

If another memory error occurs while writing in the message block, this writing is abandoned, and instead an octobus multibyte message is sent to the ND-120. This message is built by the microprogram itself and sent directly to the octobus through the ACCP. (The ACCP does not perform any tests or protocol activity on data from the microprogram to the octobus.) The contents of this message are the same as for the message buffer. The format of this message is given below.

Multibyte message format of HARDWARE FAULT message:

| 15 8 | 7 0 |
|-------|-----|
| 1 0 X X X X X X | 0 0 1 1 Y Y Y Y | Start of message 1) |
| 0 0  | " Z Z Z Z Z Z Z | Source OMD 2) |
| 0 0  | " 0 0 1 0 0 1 1 0 | Body length = 38 |
| 0 0  | " 1 0 0 0 0 0 0 0 | Command HW-fault = 200b |
| 0 0  | " 0 0 0 0 0 0 0 1 | Fault type = 1 |
| :    | : |
| 1 0  | " | Message. See 3) below |
| 1 0  | |0 0 1 0 Y Y Y Y | End of message |

1. X = the ND-120 station number (6 bits)  
   Y = the ND-120 OMD number (4 bits)

2. Z = Source OMD number. This must be a value > 3. (4 can be used.)

3. The message looks as follows:

   Process number | 2 bytes  
   Trapping P     | 4 bytes  
   Restart P      | 4 bytes  
   Trap number    | 2 bytes  
   MMS status     | 4 bytes  
   Logical address| 4 bytes  

Norsk Data ND-05.020.1 EN

---

## Page 122

# Chapter 5 THE ACCESS MODULE

|                               |       |
|-------------------------------|-------|
| Physical address              | 4 bytes |
| Physical segment              | 4 bytes |
| MMS Working reg               | 4 bytes |
| ACCP status                   | 2 bytes |
| BADAP status                  | 2 bytes |

The ND-120 station number and the OMD number for error messages are given to the ACCP by the ND-120 at boot time with the command LOAD-SYSTEM-PARAMETERS (see page 112). In addition, this command contains four bytes for possible future extensions. Immediately after the start of the microprogram in address 0, the ACCP asks the microprogram for these six bytes.

## 5.3.9 ACCP TIMEOUT

When the ACCP does not answer octobus messages, this is usually because a previous command required some kind of response from the microprogram which never occurred, for example waiting for AIB or AOB flag. Since the ACCP does not have any form of scheduler or local timeout, it needs a terminate function from the host (the ND-120).

To terminate the ACCP, an octobus emergency message with code 244B must be sent. This gives an interrupt to the ACCP at the highest level (7) and causes the ACCP program to enter the idle loop. The ND-500 monitor sends this message when an ACCP timeout occurs. To test if this was successful, an **Alive Check** multibyte message command is sent after the terminate. This returns information on whether or not the microprogram is running. If there is no response to the **Alive Check**, another timeout occurs. This is an *impossible to terminate ND-5000 situation*, and only *master clear* can solve the problem (octobus emergency message 241B).

Norsk Data ND-05.020.1 EN

---

## Page 123

# Chapter 5 THE ACCESS MODULE

---

## 5.3.10 ACCP Command Structure

The commands sent by the ND-120 to the ACCP can have parameters sent directly over the octobus, or transferred via shared memory in the MFbus memory. Most commands have short parameters, and are transferred directly. For those commands which can use both methods (i.e. directly or via the MFbus), the command itself is always passed directly. The command LOAD PARAMETER POINTER is used during initialization to specify the location of the parameter area in shared memory. The ND-120 can check that the ACCP agrees on this address by writing a 32-bit word in the parameter area and sending the command VERIFY PARAMETER POINTER.

The ACCP then reads its parameter area and returns the first 32-bit word found there. (The ACCP cannot access the MFbus memory when the microprogram is running, and an attempt to give an ACCP command with the parameters in the MFbus memory when the microprogram is running results in an error message from the ACCP.)

The two types of parameters passing between the ACCP and the ND-120 is called *directly* and *via memory*. Both types are activated as multibyte messages. For commands with long parameters (as LOAD CONTROL STORE), the parameters are normally passed via memory since this takes the shortest time and it produces the least amount of traffic on the octobus. (This may not seem to be important during the start-up phase of a small system, but in large systems there can be several CPUs, I/O controllers etc., and one of these may need to be restarted while the others are running.)

However, commands with very short parameters are always transferred directly. Commands which can use both ways of parameter passing have the words *directly* or *via memory* included in the name. If these words are not included in the name, only direct parameter passing is used.

---

Norsk Data ND-05.020.1 EN

---

## Page 124

# 5.3.11 ACCP Command Specifications

The commands specified here are used in the communication between the ACCP and the ND-120. These commands activate routines in the ACCP library to debug, test, initialize and monitor the ND-5000.

All commands are activated by a multibyte message from the ND-120 over the octobus. Commands are normally sent via octobus (protocol version 5), but the serial current-loop interface (with protocol version 3) can also be used if this is enabled by the console command SET SERIAL LINE. The reason this is disabled by default, is that SINTRAN sometimes sends broadcasts to all terminals, and the ACCP then receives a single character on the serial line. The ACCP then waits for another character since all commands are pairs of bytes. No other commands are responded to if the second byte does not arrive.

The command name and parameters, as described here, make up the body of the multibyte message, and the message frame is added/removed by the octobus driver. The command itself is specified in the first byte in the message body.

Most commands with parameters in the MFbus memory have only a single command byte in the message body. Some commands have direct parameters and instruct the ACCP to put data in the parameter field as a response (e.g. dump control store). The parameter field is organized in 16-bit words, since both the ND-120 and the ACCP are 16-bit processors. Direct parameters with several bytes always have the most significant byte first.

The multibyte message frame is shown below (destination OMD=3 for the ACCP device handling):

| C B dest/source | E | K | M | S | DestOMD |
|-----------------|---|---|---|---|---------|
| 1 x x x x x x 0 | x | 1 | 0 | 0 | 1       |
| 0               | " | " | " | " | "       | \< Source OMD > \<= Protocol version 5 only!
| 0               | " | " | " | " | "       | \< body length > 
| 0               | " | " | " | " | "       | message body 
| 0               | " | " | " | " | "       | 
| 0               | " | " | " | " | "       | Given in this chapter
| 1               | " | " | " | " | "       | 0 x 1 0 0 0 1

*Figure 28. Octobus Multibyte Message Format*

Norsk Data ND-05.020.1 EN

---

## Page 125

# Chapter 5 THE ACCESS MODULE

In response to a multibyte message, the ACCP sends either

Message acknowledged (*Messack*)

or

Message not acknowledged (*Messnak*)

The first (*Messack*) is only a single byte which is used if everything went OK. The second (*Messnak*) returns an error code and two bytes of status to indicate that something can have gone wrong. If a command requires a response with returned data via octobus (e.g. READ MIR), this data is sent directly after *Messack* in the same multibyte message. (*Messack* is sent as a multibyte message even if there are no return parameters.)

The three status bytes returned by *Messnak* are:

- Byte 0: Command error code
- Byte 1: Hardware status register (ASTS), lower part
- Byte 2: Hardware status register (ASTS), upper part

If the ND-120 does not receive a *Messack* or *Messnak*, the ND-120 sends a TERMINATE to the ACCP to resolve possible hang-ups etc. The emergency message on the octobus is decoded by hardware, as an interrupt on nd ca level 7. This causes the ACCP to reset its buffers and start at the top of the communication loop. When the serial line is used, the TERMINATE is detected by the UART interrupt driver.

Most of the commands can only be used when the microprogram is not running. Trying to use them when the microprogram is running returns *Messnak* with error code -1 (377B/FFh). There are also some commands which can not be executed after the ENABLE KICK command has been given. (For example, READ AIB would destroy a kick being sent from the ND-5000 ). These cases return *Messnak* with -2.

An error code summary is given below:

## *Messnak* error codes:

| Code | Description                                |
|------|--------------------------------------------|
| -2   | Illegal when kicks are enabled             |
| -1   | Illegal when microprogram is running       |
| 0    | Microprogram is not started                |
| 1    | No parameter pointer is given              |
| 2    | Illegal word count                         |
| 3    | Illegal address                            |
| 4    | Checksum error                             |
| 5    | Control store/control cache HW error       |
| 6    | Undefined command                          |
| 7    | Not alive                                  |
| 8    | Memory error                               |
| 9    | CS not initialized                         |

Some commands never return *Messnak*, like ECHO TEST. (If this test fails, no meaningful data can be transmitted anyway.)

Norsk Data ND-05.020.1 EN

---

## Page 126

# 5.3.12 Echo Test (ECHO)

- Direct parameters: No. of bytes (n) (1 byte)  
  Test bytes (n bytes)

- Memory parameters: None

Returns the test pattern. Is used to assure that the basic communication between the ND-120 and the ACCP works.

- **Messack** parameters: Test pattern

# 5.3.13 Load System Parameters (LSYSPAR)

- Direct parameters: System parameters (6 bytes)

- Memory parameters: None

This command must be used when booting the system to tell the microprogram where to send octobus error messages (e.g., a hardware fault like memory error). The microprogram must ask for this information after start-up by sending ACCP-TRAP together with code 1 in A1B. The six bytes are then sent to AOB as three 16-bit words like this:

| 15      | 8  7  | 0          |
|---------|-------|------------|
| 1       | Error St.no | Error OMD |
| 2       | Host St.no  | Host OMD  |
| 3       | Opt.par     | Opt.par   |

If this command has not been executed before the microprogram asks for the system parameters, the ACCP sends -1 in all three 16-bit words. The microprogram is then not able to send octobus error messages.

Norsk Data ND-05.020.1 EN

---

## Page 127

# Chapter 5 THE ACCESS MODULE

- Messack parameters: None

## 5.3.14 ACCP MICROTRAP (AMICTRAP)

- Direct parameters: Microtrap command (1 byte)  
  Parameters (if any) (n bytes)

This command is used to let the ACCP trap the microprogram. The parameters to this command are sent to AOB and give ATRAP without OMESS to distinguish this from octobus kicks/idents (and eventual multibyte messages directly to the microprogram).

- Messack parameters: None

The following commands are currently defined:

1. REDEFINE SYSTEM PARAMETERS

   Tells the microprogram where to sent octobus trap messages/kicks and error messages.

   | Command | 0        | 1        |
   |---------|----------|----------|
   | Par.1   | Err.St.  | Err. OMD |
   | Par.2   | Host St. | Host OMD |
   | Par.3   | Spare    | Spare    |

2. HALT

   Commands microprogram to dump dirty, clear cache, save context and enter JMP*.

   | Command | 0        | 2        |

3. RUN

   Commands microprogram to restore context and run.

   | Command | 0        | 3        |

Norsk Data ND-05.020.1 EN

---

## Page 128

# 5.3.15 Load Parameter Pointer (LPARP)

- **Direct parameters:** Parameter pointer (4 bytes)
- **Memory parameters:** None

The address of the parameter area in the MFbus memory is given.

- **Messack parameters:** None

---

# 5.3.16 Verify Parameter Pointer (VPARP)

- **Direct parameters:** None
- **Memory parameters:** None

This command is used to verify that the ND-120 and the ACCP agree on where the parameter area is. Before the command is given, the ND-120 writes a 32-bit word in the parameter area. The ACCP reads and returns the word from its parameter area, and the ND-120 should then check if they are equal.

- **Messack parameters:** Test pattern (4 byte)

| Messnak Error Codes | Description                                    |
| ------------------- | ---------------------------------------------- |
| -1                  | Illegal when microprogram is running.          |
| 1                   | No parameter pointer is given                  |

---

# 5.3.17 Load Control Store Directly (LOCSD)

- **Direct parameters:** CS address (2 bytes)  
  Microinstruction (16 bytes)  
  Checksum addend (2 bytes)
- **Memory parameters:** None

Load one microinstruction to the control store via octobus. While loading, the checksum is calculated by 16-bit addition of all the words (byte pairs) including the checksum addend. If the result is zero, the loading is assumed to be OK and **Messack** is returned.

- **Messack parameters:** None

| Messnak Error Codes | Description                       |
| ------------------- | --------------------------------- |
| -1                  | Illegal when microprogram is running |
| 4                   | Checksum error                    |  

Norsk Data ND-05.020.1 EN

---

## Page 129

# 5.3.18 Load Control Store Via Memory (LOCSM)

- **Direct parameters:** None

- **Memory parameters:**

|      15     |     0     |
|-------------|-----------|
| μI word count (N) | |
| Control store address | |
| μI word 0, Bits 127-112 | |
| μI word 0, Bits 15-0   | |
| μI word 1, Bits 127-112 | |
| μI word 1, Bits 15-0   | |
| ...        |            |
| μI word N, Bits 127-112 | |
| μI word N, Bits 15-0   | |
| Checksum addend       | |

Load control store via memory. While loading, the checksum is calculated by 16-bit addition of all the words including the checksum addend. If the result is zero, the loading is assumed to be OK and *Messack* is returned.

- **Messack parameters:** None

- **Messnak error codes:**
  - -1. Illegal when microprogram is running
  - 1. No parameter pointer is given
  - 4. Checksum error

Norsk Data ND-05.020.1 EN

---

## Page 130

# 5.3.19 Dump Control Store Directly (DCSD)

- **Direct parameters:** CS address (2 bytes)

- **Memory parameters:** None

One microinstruction in the control store is dumped via the octobus. While dumping, the checksum is calculated by adding all 16-bit words in the microinstruction.

- **Messnak parameters:** 
  Microinstruction (16 bytes)  
  Checksum addend (2 bytes)

- **Messnak error codes:** 
  -1. Illegal when microprogram is running  
  5. Control store error in buffered CI-bits

**NOTE:** Microinstruction (16 bytes) and checksum addend (2 bytes) are sent after a Messnak 5.

*Norsk Data ND-05.020.1 EN*

---

## Page 131

# Chapter 5 THE ACCESS MODULE

## 5.3.20 Dump Control Store Via Memory (DUCS)

- Direct parameters: None
- Memory parameters:

| 15 | 0 |
|----|---|
| μI word count (N) |
| Control store address |

Dump control store via memory. While dumping, the checksum is calculated as for loading. The ND-120 should read the memory parameter field after receiving *Messack*.

Dumped data in memory:

| 15 | 0 |
|----|---|
| μI word 0, Bits 127-112 |
| ... | ... |
| μI word 0, Bits 15-0 |
| ... | ... |
| μI word 1, Bits 127-112 |
| ... | ... |
| μI word 1, Bits 15-0 |
| ... | ... |
| μI word N, Bits 127-112 |
| ... | ... |
| μI word N, Bits 15-0 |
| (Checksum addend) |

- *Messnak* error codes: -1. Illegal when microprogram is running
  1. No parameter pointer is given
  5. Control store error in buffered CI-bits

NOTE: Microinstruction (16 bytes) and checksum addend (2 bytes) are written to memory at *Messnak* 5.

Norsk Data ND-05.020.1 EN

---

## Page 132

# 5.3.21 Dump Control Cache Directly (DCCD)

- Direct parameters: None

- Memory parameters: None

The microinstruction, pointed to by LA, in the control cache is dumped. While dumping, the checksum is calculated as for loading.

- *Messnak* parameters: 
  - Microinstruction (16 bytes)
  - Checksum addend (2 bytes)

- *Messnak* error codes: 
  - -1. Illegal when microprogram is running
  - 5. Control cache error in buffered CI-bits

NOTE! Microinstruction (16 bytes) and checksum addend (2 bytes) are sent after a *Messnak* 5.

---

## Page 133

# 5.3.22 Dump Control Cache Via Memory (DUCC)

- Direct parameters: None
- Memory parameters: None

The microinstruction, pointed to by LA, in the control cache is dumped via memory. While dumping, the checksum is calculated as for loading. The ND-120 should read the memory parameter field after receiving *Messack*.

- *Messack* parameters: None direct.

Dumped data in memory:

| 15                     | 0                       |
|------------------------|-------------------------|
| μI word 0, Bits 127-112|                         |
| μI word 0, Bits 15- 0  |                         |
| μI word 1, Bits 127-112|                         |
| μI word 1, Bits 15- 0  |                         |
| μI word N, Bits 127-112|                         |
| μI word N, Bits 15- 0  |                         |
| Checksum addend        |                         |

- *Messnak* error codes: -1. Illegal when microprogram is running  
  1. No parameter pointer is given  
  5. Control cache error in buffered CI-bits  

NOTE! Microinstruction (16 bytes) and checksum addend (2 bytes) are written to memory at *Messnak* 5.

Norsk Data ND-05.020.1 EN

---

## Page 134

# 5.3.23 Start Microprogram (STARTMIC)

- **Direct parameters:** Control store address (2 bytes)
- **Memory parameters:** None

The microprogram is started at the given CS address by loading MAR with CSA. The AMODE bit is reset and the MRUN bit is set in the modus register.

- **Messack parameters:** None
- **Messnak error codes:** 
  - -1: Illegal when microprogram is running
  - 9: Control store not initialized

# 5.3.24 Stop Microprogram (STOPMIC)

- **Direct parameters:** None
- **Memory parameters:** None

The microprogram is stopped immediately by resetting MRUN and setting AMODE in the modus register.

- **Messack parameters:** None
- **Messnak error codes:** 
  - -2: Illegal when kicks are enabled.
  - 0: Microprogram is not started.

Norsk Data ND-05.020.1 EN

---

## Page 135

# Chapter 5 THE ACCESS MODULE

## 5.3.25 CONTINUE MICROPROGRAM (CONTMIC)

- **Direct parameters:** None
- **Memory parameters:** None

The microprogram is continued at the next microinstruction after a STOP. A STOP is caused either by the command STOP MICROPROGRAM or the STOP-bit in the microinstruction being set. To handle both situations, MRUN is first reset and then set. If no stop condition is present, the command waits until the stop bit is set.

Single-stepping of microprograms can be achieved by setting the STOP-bit in every microinstruction and using this command to step one instruction at a time.

- **Messack parameters:** None
- **Messnak error codes:** 0. Microprogram is not started.

---

## 5.3.26 ALIVE CHECK (ALIVE)

- **Direct parameters:** None
- **Memory parameters:** None

Checks if the microprogram is running by polling the ALIVE signal in the status register. ALIVE is generated by a flip-flop clocked by the MIR clock and reset by the ACCP. The microprogram has stopped if ALIVE is not set approximately 10μs after it has been reset by the ACCP. If ALIVE is true, Messack is returned; otherwise Messnak is returned.

- **Messack parameters:** None
- **Messnak error codes:** 7. Not alive

---

Norsk Data ND-05.020.1 EN

---

## Page 136

# 5.3.27 Load MAR (LMAR)

- **Direct parameters**: CS address (2 bytes)
- **Memory parameters**: None

A 16-bit control store address is loaded into MAR. The address is shifted into the jump field (bit 31-16) in MISR (microinstruction shadow register) and then clocked into MAR.

- **Messack parameters**: None
- **Messnak error codes**: -1. Illegal when microprogram is running

# 5.3.28 Load MIR (LMIR)

- **Direct parameters**: Microinstruction (16 bytes)
- **Memory parameters**: None

A 128-bit microinstruction is loaded into MIR. (The microinstruction is shifted into MISR and then clocked into MIR.)

- **Messack parameters**: None
- **Messnak error codes**: -1. Illegal when microprogram is running

# 5.3.29 Read MIR (RMIR)

- **Direct parameters**: None
- **Memory parameters**: None

A 128-bit microinstruction is read from MIR. (The contents of MIR are clocked into MISR and shifted out to ASR.)

- **Messack parameters**: MIR contents (16 bytes)
- **Messnak error codes**: -1. Illegal when microprogram is running

Norsk Data ND-05.020.1 EN

---

## Page 137

# Chapter 5 THE ACCESS MODULE

## 5.3.30 Test Buffer (TBUF)

- **Direct parameters:** Test pattern (4 bytes)
- **Memory parameters:** None

The AOB/ASR registers are loaded and the data is clocked into AIB/APR and read back.

- **Messack parameters:** Test pattern (4 bytes)
- **Messnak error codes:** -1. Illegal when microprogram is running

---

## 5.3.31 Test Bus (TBUS)

- **Direct parameters:** Test pattern (4 bytes)
- **Memory parameters:** None

This command tests most of the buses on the mother board by sending the test pattern in a bus loop. MIBT is loaded through DB, X and IB buses, and it is read through the MIB, MPC and back to the DB bus. (The BUSTEST bit in the modus register is set to establish this special bus routing. This is reset after the test.)

- **Messack parameters:** Test pattern (4 bytes)
- **Messnak error codes:** -1. Illegal when microprogram is running

---

## 5.3.32 Read AIB16 (RAIB16)

- **Direct parameters:** None
- **Memory parameters:** None

The AIB flag (AIBF) is polled and AIB is read (16 bits) when the flag is set. After the read, AIBF is reset. The polling can be terminated by the command TERMINATE to resolve a hang-up.

- **Messack parameters:** AIB data (2 bytes)
- **Messnak error codes:** -2. Illegal when kicks are enabled

---

Norsk Data ND-05.020.1 EN

---

## Page 138

# 5.3.33 Read AIB32 Directly (RAIB32D)

- Direct parameters: None
- Memory parameters: None

The AIB flag (AIBF) is polled and AIB/APR is read (32 bits) when the flag is set. After the read, AIBF is reset. The polling can be terminated by the command TERMINATE to resolve a hang-up.

- **Messnak** parameters: AIB/APR data (4 bytes)
- **Messnak** error codes: -2. Illegal when kicks are enabled

# 5.3.34 Read AIB32 Via Memory (RAIB32M)

- Direct parameters: None
- Memory parameters: None

The AIB flag (AIBF) is polled and AIB/APR is read (32 bits) when the flag is set. After the read, AIBF is reset. The polling can be terminated by the command TERMINATE to resolve a hang-up.

- **Messnak** parameters: None direct, AIB/APR data in memory:

|        |        |
|--------|--------|
| APR data (Bits 31-16) |  |
| AIB data (Bits 15-00) |  |

**Messnak** error codes: -2. Illegal when kicks are enabled

Norsk Data ND-05.020.1 EN

---

## Page 139

# Chapter 5 THE ACCESS MODULE

## 5.3.35 LOAD AOB16 (LAOB16)

- **Direct parameters**: AOB data (2 bytes)
- **Memory parameters**: None

The AOB flag (AOBF) is polled and AOB is loaded (16 bits) when the flag is reset. (ND-5000 clears this flag when reading AOB). After the load, AOBF is set. The polling can be terminated by the command TERMINATE to resolve a hang-up.

- **Messack parameters**: None
- **Messnak error codes**: -2. Illegal when kicks are enabled

---

## 5.3.36 LOAD AOB32 DIRECTLY (LAOB32D)

- **Direct parameters**: AOB/ASR data (4 bytes)
- **Memory parameters**: None

The AOB flag (AOBF) is polled and AOB/ASR is loaded (32 bits) when the flag is reset. (ND-5000 clears this flag when reading AOB). After the load, AOBF is set. The polling can be terminated by the command TERMINATE to resolve a hang-up.

- **Messack parameters**: None
- **Messnak error codes**: -2. Illegal when kicks are enabled.

---

Norsk Data ND-05.020.1 EN

---

## Page 140

# 5.3.37 Load A0B32 Via Memory (LA0B32M)

- **Direct parameters:** None
- **Memory parameters:** 15

|                |                |
|----------------|----------------|
| ASR data       | (Bits 31-16)   |
| A0B data       | (Bits 15-00)   |

The A0B flag (A0BF) is polled and A0B/ASR is loaded (32 bits) when the flag is reset. (ND-5000 clears this flag when reading A0B). After the load, A0BF is set. The polling can be terminated by the command TERMINATE to resolve a hang-up.

- **Messnak parameters:** None

- **Messnak error codes:** -2. Illegal when kicks are enabled

# 5.3.38 Read ASTS (RASTS)

- **Direct parameters:** None

- **Memory parameters:** None

The Access Module status register is read (16 bits). The definition of the status register is given on page 97.

- **Messnak parameters:** ASTS data (2 bytes)

# 5.3.39 Load Mode (LMODE)

- **Direct parameters:** MODE data (2 bytes)

- **Memory parameters:** None

The ACCP modus register is loaded. This must be done with care since this register is not readable, and all bits are affected. The lower byte is cleared by hardware reset, and the upper byte is cleared when the microprogram reads A0B.

- **Messnak parameters:** None

- **Messnak error codes:** -1. Illegal when microprogram is running

Norsk Data ND-05.020.1 EN

---

## Page 141

# Chapter 5 THE ACCESS MODULE

## 5.3.40 Load CON (LCON)

- Direct parameters: CON data (2 bytes)
- Memory parameters: None

The ACON decoder is loaded (16 bits). This is used to generate strobe pulses according to the bit pattern loaded. Nothing is stored. The definition of the ACON decoder is found on page 99.

- *Messack* parameters: None
- *Messnak* error codes: -1. Illegal when microprogram is running.

---

## 5.3.41 Write Multiport (WMPM)

- Direct parameters: 
  - Address (4 bytes)
  - Data (4 bytes)
- Memory parameters: None

The given 32-bit word is written to MFbus memory at the specified address.

- *Messack* parameters: None
- *Messnak* error codes: -1. Illegal when microprogram is running.

---

## 5.3.42 Read Multiport (RMPM)

- Direct parameters: Address (4 bytes)
- Memory parameters: None

A 32-bit word is read from the specified address in MFbus memory.

- *Messack* parameters: Data (4 bytes)
- *Messnak* error codes: -1. Illegal when microprogram is running.

---

Norsk Data ND-05.020.1 EN

---

## Page 142

# Chapter 5 THE ACCESS MODULE

## 5.3.43 Test Multiport (TESTMPPM)

- Direct parameters: Start address (4 bytes)  
  End address (4 bytes)

- Memory parameters: None

The communication from ACCP to MFbus memory is tested in the specified address range by doing a *not address in address test*.

- *Messnak* parameters: None

- *Messnak* error codes: 8. Memory error  
  Result (4 bytes)  
  Address (4 bytes)

## 5.3.44 Set Trace Selector (SETTRAC)

- Direct parameters: Selector setting (6 bytes)

- Memory parameters: None

The trace selector is set to select the desired buses for tracing by an external tracer (logic analyzer). The parameter formats are:

| Bit number: | 15... | ...8 | 7... | ...0 |
|-------------|-------|------|------|------|
| Bytes 1,2:  | xDDD  | xCCC | xBBB | xAAA for pin row c |
| Bytes 3,4:  | xDDD  | xCCC | xBBB | xAAA for pin row b |
| Bytes 5,6:  | xDDD  | xCCC | xBBB | xAAA for pin row a |

The three uppercase letters represent the plug numbers from 2 to 7 in the actual plug rows on the motherboard. x means unused bit. (If for example xDDD = 0101, this means that plug number 5 is selected on row D.)

- *Messnak* parameters: None

Norsk Data ND-05.020.1 EN

---

## Page 143

# Chapter 5 THE ACCESS MODULE

## 5.3.45 LOOP (LOOP)

- Direct parameters: None

- Memory parameters: None

This command causes the next command to be executed repetitively until the TERMINATE command is sent. It can be used to make a loop without communication delay, and is suited for debugging with an oscilloscope. When this command is executed, the next command does not give any response before TERMINATE is given.

- Messack parameters: None

---

## 5.3.46 RESTART MICROPROGRAM (RESTMIC)

- Direct parameters: CS address (2 bytes)  
  Interval (2 bytes)

- Memory parameters: None

Restart the microprogram, at the given CS address, repetitively at given intervals. The time between the intervals is approximately 1 μs multiplied by the number given as the interval parameter. This command can be used to make a loop without communication delay, and is suited for debugging with an oscilloscope. This command is terminated by the TERMINATE command.

If zero is given as the interval parameter, the microprogram is restarted if ALIVE goes false, indicating that the microprogram has stopped. (ALIVE is described in the ALIVE CHECK command.)

- Messnak error codes: 
  - -1. Illegal when microprogram is running

Norsk Data ND-05.020.1 EN

---

## Page 144

# 5.3.47 Enable Kicks (ENKICK)

- **Direct parameters:** None

- **Memory parameters:** None

This command is used by the ND-120 when all initialization is finished and the operating system and I/O system are to be started. After this command has been given, all commands which affect the hardware in the ND-5000 are disabled (i.e. they return Messnak with Not allowed when kicks are enabled). This command enables AIB interrupt from microcode to ACCP, and allows the ND-5000 to receive/send octobus messages through the ACCP.

- **Messnak parameters:** None

# 5.3.48 Disable Kicks (DISKICK)

- **Direct parameters:** None

- **Memory parameters:** None

If the ENABLE KICKS command has been executed after a reset, this command must be given to return to the "test/init-mode". This puts the ACCP back in the same mode as after a reset, and all commands can be executed. Octobus messages, other than multibyte messages for OMD = 3 (ACCP), received in this mode are ignored. This command disables AIB interrupt from microcode to ACCP.

- **Messnak parameters:** None

# 5.3.49 Reset CPU (CPURES)

- **Direct parameters:** None

- **Memory parameters:** None

Performs CPU Master Clear on the ND-5000. (Not the ACCP itself.)

- **Messnak parameters:** None

---

## Page 145

# Chapter 5 THE ACCESS MODULE

## 5.3.50 Terminate (TERM)

- Direct parameters: None
- Memory parameters: None

This command requires ACCP print version C or later for octobus hardware decoding.

The command has a special code with the emergency bit set (bit 7) and is detected by the hardware and causes an interrupt on highest level to the ACCP. (The octobus driver is not activated.) This command can be used to resolve a hang-up or to abort a looping test. (When serial line is used instead of octobus, the control byte with bit 7 set is detected by the interrupt driver.)

There is no response to this command.

## 5.3.51 ACCP Reset (ARES)

- Direct parameters: None
- Memory parameters: None

This command has a special code with the emergency bit set (bit 7) and is detected by the hardware, causing the ACCP to be reset and enter the power-up sequence. This includes a RESET CPU, and a short version of ND-5000 self-tests are performed.

On ACCP print versions A and B, this command sets the RESET signal on, and requires the CONTINUE message to be sent after at least 100 ms to turn the reset signal off and make the ACCP run. On version C or later, this command generates a pulse of sufficient duration for a complete restart of the ACCP.

(When serial line is used instead of octobus, the control byte with bit 7 set is detected by the interrupt driver and causes only a soft reset similar to typing CTRL+X on the console.)

There is no response to this command.

Norsk Data ND-05.020.1 EN

---

## Page 146

# 5.3.52 Read ECO Levels (RECO)

- **Direct parameters:** None
- **Memory parameters:** None

Reads print status of the motherboard and all baby cards. The print status of each module consists of two bytes, where the first byte gives the print type and the second the ECO level. (The actual reading of the ECO status PALs is done only at RESET CPU, i.e when the RESET ACCP or RESET CPU commands are used.) The information in the two print-status bytes is:

| 15 14 13 12 | 11 10 9 8 | 7 6 5 4 3 2 1 0 |
|-------------|-----------|-----------------|
| 0           | Part no.  | Version         |
| 0           | ECO no. (Binary)           |

If a module or its print status PAL is not installed, their print status reads 7F55h.

- **Messack parameters:** ECO levels (32 bytes) as follows:

```
Byte  0,  1  Motherboard
      2,  3  ALU
      4,  5  AAP
      6,  7  IDAC (Booster)
      8,  9  IDA
    10, 11   MMU
    12, 13   Cache
    14, 15   Spare
    16, 17   Control store
    18, 19   Spare
    20, 21   Spare
    22, 23   Spare
    24, 25   MIC
    26, 27   ACCP
    28, 29   Spare
    30, 31   Spare
```
Norsk Data ND-05.020.1 EN

---

## Page 147

# Chapter 5 THE ACCESS MODULE

## 5.3.53 RUN SELF-TEST (RUNTST)

- Direct parameters: None

- Memory parameters: None

Runs the full self-test of the ND-5000 CPU. This test takes approximately three minutes and, in addition to the Master Clear self-test, it includes a thorough test of control store and cache.

The self-test status is a 16-bit word, where each bit refers to a different test. If a bit is set, this test has failed. The bits are allocated as follows:

| Bit | Test               |
|-----|--------------------|
| 0   | BUS test           |
| 1   | MIR test           |
| 2   | CS test            |
| 3   | START/STOP test    |
| 4   | ARG test           |
| 5   | ALU test           |
| 6   | REG test           |
| 7   | TSB test           |
| 8   | INSTR. CACHE test  |
| 9   | DATA CACHE test    |
| 10  | CONTROL CACHE test |
| 11  | AAP                |
| 12  | -                  |
| 13  | -                  |
| 14  | -                  |
| 15  | -                  |

- *Messack* parameters: Self-test status (2 bytes)

- *Messnak* error codes: -1. Illegal when microprogram is running

Norsk Data ND-05.020.1 EN

---

## Page 148

# 5.3.54 Read Self-test Status (RTEST)

- **Direct parameters:** None
- **Memory parameters:** None

Get the ACCP self-test status. After the ND-5000 receives a Master Clear, or after power-up, a self-test program is loaded from ACCP PROMs and executed under full ACCP control. This takes some time, and the ND-120 must issue this command every 5 seconds after a master clear or power failure in order to find out when it can start booting the ND-5000.

The self-test started at master clear is a short version, taking approximately twenty seconds. The full self-test must be started by the command RUN SELFTEST. This test takes approximately three minutes.

- **Messack parameters:** Self-test status (2 bytes) zero if OK

# 5.3.55 Set Clock Speed

- **Direct parameters:** Clock speed (1 byte)
- **Memory parameters:** None

Sets master clock speed to 

| Speed   | Parameter Value |
|---------|-----------------|
| SLOW (156 ns) | 0               |
| NORMAL (70 ns) | 2               |
| FAST (67 ns)   | 3               |

- **Messack parameters:** None

# 5.3.56 Read ACCP PROM Version

- **Direct parameters:** None
- **Memory parameters:** None

Returns the date and version of the ACCP PROMs in the form A.00. (Max. value Z.99)

- **Messack parameters:** Date (Eight ASCII bytes in this format: 87. 3.18)

Norsk Data ND-05.020.1 EN

---

## Page 149

# Chapter 5 THE ACCESS MODULE

## 5.3.57 READ CPU MODEL

- Direct parameters: None

- Memory parameters: None

Reads CPU type and model. CPU types are:

1 - No cache, AAP and IDAC (booster)  
2 - With cache and AAP  
3 - With cache, AAP and IDAC (booster)  

CPU models are 2, 4, 5, 7, 8 or 9 for the CPUs from the ND-5200, the ND-5400, and so on, up to the ND-5900.

- Messack parameters: CPU type (bits 7-4)  
  CPU model (bits 3-0) (1 byte)

- Messnak error codes:  
  11. MFbus controller has incorrect CPU setting.  
  12. Illegal CPU configuration.

Norsk Data ND-05.020.1 EN

---

## Page 150

I'm sorry, but there's no visible content on the scanned page to convert to Markdown. If you have another page or document, feel free to share it!

---

## Page 151

# Chapter 6: The Memory Management System (MMS)

Norsk Data ND-05.020.1 EN

---

## Page 152

I'm sorry, I can't process the content of that image.

---

## Page 153

# Chapter 6 The Memory Management System (MMS)

## 6.1 Tasks

The main tasks of the memory management system (MMS) are:

- **Administration of the memory resources.** The main task of an operating system is to administer the CPU, I/O and memory resources available. The MMS is a subsystem of the operating system. In a multiuser environment, such as the ND-5000, memory administration means keeping track of the code and data for the various users (processes in ND-5000 terminology). The code and data can reside on the disk or in the memory, and the code and data on the disk must be transferred to the memory for execution.

- **Translation from logical to physical memory address.** As different users can use the same logical address space, the address must be converted to a user-related physical address. This is done by referring to different tables in memory. The address translation part of the MMS is controlled by the ND-5000 MMS baby card itself, and not, as in the ND-500/2, by the microprogram. The microprogram is only involved by page fault, protect violation, memory error, etc.

## 6.2 ND-5000 MMS Compared to ND-500/2 MMS

- **TSB fault handling.** When a Translation Speed-up Buffer (TSB) fault is detected, the MMS card goes through the necessary tables in memory. If a page fault or protect violation is detected, the microprogram is notified, and a trap-handling microroutine is started. But if all the necessary tables are found in physical memory, the MMS performs all the handling itself. The microprogram is started when the final data read from memory is available. It looks as the main processor pauses until the MMS and memory is able to supply the data.

  This is in great contrast to the ND-500/2, where the microprogram itself is responsible for the access to the various tables. The macroinstruction that gave rise to the TSB fault had to be restarted in the ND-500. This is not necessary in the ND-5000. For the same reason it is not necessary with a sequential TSB in the ND-5000.

  TSB fault in the ND-5000 only traps the microprogram if page

Norsk Data ND-05.020.1 EN

---

## Page 154

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

fault, write protect violation, parameter access protect violation, memory error, etc. are detected.

- WIP and PGU handling. WIP (Written In Page) and PGU (Page Used) handling are performed by the MMS, and not by the microprogram.

## 6.3 MEMORY MANAGEMENT BABY CARD OVERVIEW

The ND-5000 memory management baby card consists of two parts:

1. The Instruction Memory Management (IMM)
2. The Data Memory Management (DMM)

Each part has separate, and nearly identical, hardware:

| Instruction memory management hardware: | Data memory management hardware: |
|----------------------------------------|-----------------------------------|
| ND-S-MM gate array chip                | ND-S-MM gate array chip           |
| IMM nanostate sequencer (PAL that controls the state of the IMM gate array) | DMM nanostate sequencer (PAL that controls the state of the DMM gate array) |
| Translation speed-up buffer (TSB, a 4K RAM with a map of the most recently used logical memory references) | Translation speed-up buffer (TSB, a 4K RAM with a map of the most recently used logical memory references) |

Norsk Data ND-05.020.1 EN

---

## Page 155

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## 6.4 MMS Functional Description

This section contains the subsections

- Address translation using logical segment number (this page)
- Address translation using physical segment number (page 152)
- Special mechanisms for database recovery procedures (page 155)

See the ND-500 Reference Manual (ND-05.009 EN) for more information on the function of the memory management system.

## 6.4.1 Address Translation Using Logical Segment Number

```
Process Segment No. n-2
----------------------
Process Segment No. n-1
----------------------
Domain 0
----------------------
Domain 1
----------------------
Process Segment No. n          |  15                           0
-------------------------------|-------------------------------
Domain 256                     |  Program capability table     | 32 entries
-------------------------------|-------------------------------
Process Segment No. n+1        |  Data capability table        | 32 entries
                               |-------------------------------
                               |  Domain call information      |
                               |  Trap handling information    | 64 entries
                               |-------------------------------
                               |  Domain characteristics       |
```

*Figure 29. Process Segment (PS)*

For each active process there is one process segment. On a process-segment page there can be up to 256 domain information tables; one table of 256 bytes for each domain owned by the process. Each domain information table keeps information on the structure and properties of one domain.

Each domain information table has two capability tables - one for

Norsk Data ND-05.020.1 EN

---

## Page 156

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

Data and one for program. Each capability table has 32 elements; one for each of the 32 logical segments that can be in one domain. In addition, each domain information table contains domain call information, trap handling information and domain characteristics. Each logical segment can have up to 128 Mbytes.

The five most significant bits of the logical address are referred to as the logical segment number. These five bits are used to point to one of the 32 elements in the Data Capability Table or in the Program Capability Table. One such element is called a capability, and has the same layout as for the ND-500.

---

Norsk Data ND-05.020.1 EN

---

## Page 157

# Chapter 6 The Memory Management System (MMS)

## Program Segment Capability

a) Direct capability

| 1 bit :  | 2 bits : | 13 bits                     |
|----------|----------|-----------------------------|
| Direct=0 | unused   | physical segment table index |

b) Indirect capability

i) This computer

| 1 bit :  | 1 bit :  | 1 bit : | 8 bits | 5 bits  |
|----------|----------|---------|--------|---------|
| Indirect=1 | other computer=0 | unused | domain | segment |

ii) Other computer

| 1 bit :  | 1 bit :  | 14 bits                |
|----------|----------|------------------------|
| Indirect=1 | other computer=1 | computer number |

## Data Segment Capability

| 1 bit | 1 bit | 1 bit | 13 bits                      |
|-------|-------|-------|------------------------------|
| write permitted | parameter access | shared segment | physical segment table index |

## Physical Memory

Because the number of address bits between the ND-5000 CPU and its associated memory is limited to 32, the physical main memory size can be up to 2**32 bytes. With a page size of 2048=2**11, this implies 2**21 pages or a 21-bit page number. The table structure of the memory management system supports 2**41 bytes or 2**30 pages (or approximately 2 Terabytes).

A bit table is maintained in physical memory. The table is called the Page-Used/Written-in-Page (PUWP) table. It can be up to 2*(2**30) bits in size and is accessible through microcode and privileged instructions. It contains two bits per physical memory page. One bit, the WIP bit, contains a '1' if the page has been

Norsk Data ND-05.020.1 EN

---

## Page 158

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

written to since the bit was cleared by software. This means that the page must be copied back to mass storage before it is replaced by another one. The other bit is the PGU bit. It indicates that a page has been used since the bit was cleared. This can be used to determine which pages are candidates to be overwritten when more memory space is needed.

The MMS updates these bits during the TSB fault handling.

---

## PHYSICAL SEGMENT TABLE

The MMS has a Physical Segment Table Pointer (PSTP) pointing to the start of the Physical Segment Table (PST). You can find the PSTP in the ND-5000 monitor:

```
SINTRAN@ND-5000⊣
ND-5000:MEMORY-CONFIGURATION⊣
PHYSICAL SEGMENT TABLE:
```

The PST contains four-byte entries for each physical segment in the whole system. Each entry contains the page number of a data page or an index page.

The 13-bit physical segment number in the capability table points to one of the 8192 elements in PST. Depending on the size of the physical segment, the access method is direct or indexed, once or twice. Bits 30 and 31 of each element in the PST hold information about the access mode:

| 31  | 0  |
|-----|----|
| **2 bits** | **30 bits** |
| access | physical page number |

The two access bits have the following meaning:

### Access=0 Direct:

Bits 0-29 contain the physical page number that contains the physical segment. The physical segment has only one page in memory. The logical address bits 0-10 give the displacement within the 2 Kbyte page.

### Access=1 Single indexing:

Bits 0-29 contain the physical page number of an index page. Logical address bits 11-19 give the displacement within this index page. This index page entry contains the physical page number that contains the logical address. Logical address bits 0-10 give the displacement within the 2 Kbyte page.

Norsk Data ND-05.020.1 EN

---

## Page 159

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## Access=2 Double indexing

Bits 0-29 contain the physical page number of the second-level index page. Logical address bits 20-26 give the displacement within this second-level index page. This index page entry contains the physical page number of the first-level index page. Logical address bits 11-19 give the displacement within this first-level index page. This index page entry contains the physical page number that contains the logical address. Logical address bits 0-10 give the displacement within the 2 Kbyte page.

The maximum size of a segment is 2*27 = 128 Mbytes or 2*16 = 64K pages.

The physical page access is illustrated in figure 30.

Norsk Data ND-05.020.1 EN

---

## Page 160

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## Logical Address

| 5 bits | 7 bits | 9 bits | 11 bits |
|--------|--------|--------|---------|
| 31     | ↓ 27   | 26 ↓   | 20 ↓ 19 |  
| \      | \      | \      | 11 ↓ 10 |  
| \      | \      | \      | 0       |

### Index in page

### Via data or instruction capability tables in the Domain information Table

- **Physical Segment Table Index (13 bits)**
  - PSTP
  - **Physical Segment Table (PST)**
    - 0 Page no.
      - Access bits
    - 1 Page no.
      - Access bits
    - 2 Page no.
      - Access bits

**8192 entries (max.)**

### Page no.

- 30 bits
- Page no. (30 bits)
  
  | Page no. | Index to 2nd level | max. 2Kbyte |
  |----------|--------------------|-------------|

- Page no.
  - 30 bits
  - Page no. 30 bits

  | Page no. 30 bits | max. 1Mbyte |
  |------------------|-------------|

- Page no. 30 bits

  | Page no. 30 bits | max. 128Mbyte |
  |------------------|---------------|

**2048 entries**

- **2nd level of index table (128 entries)**
- **1st level of index table (512 entries)**

*Figure 30. Physical Page Access*

Norsk Data ND-05.020.1 EN

---

## Page 161

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## Process Registers

The capability tables hold the physical segment numbers of all logical segments in a domain. The capabilities are found on the physical segment specified by the process segment register (PS) of the process. This physical segment is called the process segment of the process.

On this segment, the currently executing domain register (CED) selects a 256-byte domain information table. This table includes the capability tables. The logical segment number selects an entry in the capability table. This table entry contains the physical segment number of the referenced segment.

An example of addressing a program capability is shown in figure 31.

Norsk Data ND-05.020.1 EN

---

## Page 162

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## Registers

| Registers |                           | Physical Segment Table |
|-----------|---------------------------|------------------------|
| PSTP      |                           |                        |
| PS=100    |                           |                        |
| CED=0     |                           |                        |
| Seg.no.=3 |                           |                        |

- - - - 

The addressed capability is:

- 2 * 3
  - Program capability table
  - Data capability table
  - Domain information

DOM 0  
- Current domain information table

DOM 1  
- Process segment of current process

DOM 2  

*Figure 31. Addressing Program Capability*

## The abbreviations mean:

**PSTP - Physical Segment Table Pointer (30 bits):**

This register points to the start of the Physical Segment Table.  
This is a global pointer for the whole system. You can find PSTP  
by doing MEMORY-CONFIGURATION in the ND-5000 monitor.

**PS - Process Segment register (13 bits): Bits 12-0 of PS**

This register points to an element of the Physical Segment Table.  
The PST element addresses the process segment of the the process.  
Each process has its own PS register.

**CED - Current Executing Domain (8 bits): Bits 7-0 of CED**

This register holds the domain number used by the currently  
executing process. Each process has its own CED register.

**CAD - Current Alternative Domain (8 bits): Bits 7-0 of CAD**

This register holds the alternative domain number used by the  
current process. Each process has its own CAD register.

Norsk Data ND-05.020.1 EN

---

## Page 163

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## TRANSLATION SPEED-UP BUFFER

The worst case of a memory reference would be a look-up in up to eight memory locations before the physical address is available. Up to eight accesses for every memory reference is not acceptable. It would be much too time-consuming.

To reduce the number of memory accesses, the translation speed-up buffer (TSB) is used. The TSB is a special hardware buffer consisting of 4K RAM. There is one TSB for the data memory management and one for the instruction memory management.

The physical page number obtained by address translation is saved in one entry in the TSB, together with the following information:

- The logical page number of a reference (the upper 21 address bits)
- The domain number
- The process number
- The permit bits of the corresponding capability

Following an access to one page, all subsequent accesses to the same page find the physical page address in the TSB. Because the domain number and the process number are stored together with the physical and logical page number, there is no need to clear the TSB when changing processes.

## TSB ADDRESSING

When using a logical address, the following comparison is made between the MMS and the TSB:

| MMS           | TSB           |
|---------------|---------------|
| LA(11-31)     | LA(11-31)     |
| PS(0-12)      | PS(0-12)      |
| DOM(0-7)      | DOM(0-7)      |

If the values match and if the used-flag is set, the TSB contains the physical page address corresponding to the given logical address, process segment, and domain number.

Norsk Data ND-05.020.1 EN

---

## Page 164

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

The TSB is 4096 entries deep. The total of 36 bits used to address these entries is reduced to a 12-bit address by a hashing algorithm. The 36 bits are exclusive OR'ed, forming the 12-bit index HX(0-11). See table 11. HX(0-11) is taken from:

- Logical address bits LA(11-22)
- Logical address bits LA(27-31)
- Process segment bits PS(4-10)
- Process segment bits PS(0-3)
- Domain bits DOM(0-7)

| HX(11) | = LA(22) xor LA(27) xor PS(0) |
|--------|-------------------------------|
| HX(10) | = LA(21) xor LA(28) xor PS(1) |
| HX(9)  | = LA(20) xor LA(29) xor PS(2) |
| HX(8)  | = LA(19) xor LA(30) xor PS(3) |
| HX(7)  | = LA(18) xor LA(31) xor DOM(0)|
| HX(6)  | = LA(17) xor PS(4)  xor DOM(1)|
| HX(5)  | = LA(16) xor PS(5)  xor DOM(2)|
| HX(4)  | = LA(15) xor PS(6)  xor DOM(3)|
| HX(3)  | = LA(14) xor PS(7)  xor DOM(4)|
| HX(2)  | = LA(13) xor PS(8)  xor DOM(5)|
| HX(1)  | = LA(12) xor PS(9)  xor DOM(6)|
| HX(0)  | = LA(11) xor PS(10) xor DOM(7)|

(xor = exclusive OR)

**Table 11. Hashed Index for the TSB**

The total number of bits wanted as index for the TSB is reduced from 42 bits to 12 bits by this hashing algorithm. The hashing algorithm is made in such a way that access to different pages within a small logical segment is mapped to different entries in the TSB. For small segments, different logical segments also map to different entries in the TSB.

Using LA(22-11) direct as index to the TSB maps uniquely all pages within a segment with less than 4K pages.

Using LA(31-27) direct as index maps uniquely different logical segments within a domain.

An index taken direct from DOM(7:0) maps uniquely different domains within a process.

(Using PS(0-10) (11 bits) maps uniquely different process segments.)

Norsk Data ND-05.020.1 EN

---

## Page 165

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

| Hashed address (0-11) | Logical Address | Process Segment | Domain | Capability table | Physical Page Number |
|-----------------------|-----------------|------------------|--------|-----------------|---------------------|
|                       | 11-31           | 0-12             | 0-7    | 0-3             | 11-40               |

Capability Table:  
T - Written in table updated  
W - Write permitted  
P - Parameter access permitted  
S - Shared segment  

*Figure 32. Layout of the Translation Speed-up Buffer*

In the TSB, there are four capability bits (T, W, P and S):

## T - Written In Page Table Updated:

This bit is used to indicate that the page pointed to by the physical page number has been written to, and that the Written In Page Table bit in memory has been set. When an entry in TSB is written because of a read reference, this bit should be reset. The bit is always checked when a write is done. If the bit is '1', nothing special must be done. But if the bit is '0', this bit and the corresponding bit in the Written In Page Table in the memory both must be set to one.

Each Domain in a Process can have 32 logical Segments. Each segment is protected by one element in the Capability Table of the Domain Information Table. For Program Segments, only read is allowed. For Data Segments, there are three bits used by the protection system. These bits are the same as the three bits in the TSB:

## W - Write Permitted:

This bit indicates that the physical page can be written to.

## P - Parameter Access via ALT-prefix Permitted:

This bit indicates whether routines in other domains can refer to this segment through the ALT prefix.

## S - Shared Segment (Cache Inhibit):

This means that the segment can be shared between several domains or processes. If a segment is shared, data is always read from main memory rather than from cache. This ensures that different processes are aware of each others updating of a data item.

*Norsk Data ND-05.020.1 EN*

---

## Page 166

# 6.4.2 Address Translation Using Physical Segment Number

The ND-5000 MMS is provided with hardware for two new commands in the ND-500 instruction set. They make it possible to copy directly between a domain in one process and a segment in another process. The commands are:

- RPHS - read from physical segment
- WPHS - write to physical segment

See the ND-500 Reference Manual (ND-05.009 EN) for a detailed description of the commands.

The physical segment number is used, together with the Physical Segment Table Pointer, to give the physical page number of the wanted data page or the corresponding index page. The last used physical segment and logical address bits 11-26 are kept in the TSBPHS (translation speed-up buffer for physical segment address translation). The corresponding physical page number is in the WR register (working register), see page 161.

This translation is similar to the ordinary logical to physical address translation, except there is no need for the translation from logical to physical segment number. This means that the physical segment number, together with the physical segment table pointer, gives the physical page number of the wanted data page or the corresponding index page.

The translation from logical to physical address can require several memory accesses for each memory reference. To speed-up this translation, we need to have a Translation Speed-up Buffer for physical segment translation (TSBPHS) similar to that for ordinary logical to physical address translation. Instead of comparing process segment number and domain number with TSBPHS, we compare only Physical Segment number with TSBPHS. The LA(26:11) is compared with the TSBPHS in the same way as for the ordinary TSB. The PHS needs to have only one entry in the TSBPHS because translation is only needed when page boundaries are crossed. The logical addresses are sequential.

*Norsk Data ND-05.020.1 EN*

---

## Page 167

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

The TSBPHS is a register on the MMS chip containing logical address bits 26-11, and physical segment number and a USED flag. The WR register contains the physical page number. The used bit is cleared with the CTSB command or whenever the WR-register is used. See figure 33.

| The TSBPHS register | WR register |
|---------------------|-------------|
| LA(26:11)           | PHS(12:0)   | Physical Page Number(40:11) |

_Used_

*Figure 33. TSB for Physical Segment Translation*

In case of TSBPHS miss (e.g. when crossing page boarders), the translation mechanism picks up the next physical page number according to the physical segment table (and corresponding index pages).

Norsk Data ND-05.020.1 EN

---

## Page 168

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

The physical page access for physical segment translation is illustrated in figure 34:

## Logical Address

| Bits      | Description       |
|-----------|-------------------|
| 31 - 27   | Not used          |
| 26 - 20   | Physical Segment Number |
| 19 - 11   | Index to 1st level |
| 10 - 0    | Index in page     |

## Tables

| Table                      | Description                      | Entries              |
|----------------------------|----------------------------------|----------------------|
| Physical Segment Table     | Physical Segment Table Pointer   |                      |
|                            | - Page no.                       |                      |
|                            | - Access bits                    |                      |
|                            | 0 Page no. (30 bits)             |                      |
|                            | 1 Page no. (30 bits)             |                      |
|                            | 2 Page no. (30 bits)             |                      |
|                            | 8192 entries (max.)              |                      |
| 2nd level of index table   |                                  | 128 entries          |
| 1st level of index table   |                                  | 512 entries          |
|                            | Page no. (30 bits)               |                      |
|                            | Page no. 30 bits                 |                      |

## Maximum Sizes

- max. 2Kbyte
- max. 1Mbyte
- max. 128Mbyte
- 2048 entries

*Figure 34. Physical Page Access for Physical Segment Translation*

Norsk Data ND-05.020.1 EN

---

## Page 169

# 6.4.3 Special Mechanisms for Database Recovery Procedures

The `write permit` mechanisms in the ND-500/1 and ND-500/2 are altered. The most significant bit of the last index page entry (Page-Write-Not-Permitted bit) indicates that a special trap (for the attention of the swapper only) occurs whenever a write to a page is attempted.

- 0 in the bit specifies that write is performed normally.
- 1 in the bit specifies that write gives a special trap.

If a physical page is mapped directly from the PST, with no index pages necessary, the bit is taken to be 0.

This means a new level of write protection on each page. When the Page-Write-Protect bit (in the last index page) is set and the write-permitted flag is set in the capability, the system can make a backup of this page (resetting the MSB bit) and continue writing to the page. These new mechanisms are implemented in hardware (in the MMS chip) on the ND-5000, and only microprogram changes are needed in order to implement them in the ND-500/1 and ND-500/2.

The last index page must be checked when TSB is to be updated, and the TSB W-bit must be kept cleared until the Page-Write-Protect bit = 0 is found in the index page. This handling comes in addition to the handling of the special TSB bit that indicates whether or not the memory resident WIP table has been updated.

|                      | Present solution in ND-500/1 and ND-500/2 | Modified solution in ND-500/1 and ND-500/2 |
|----------------------|------------------------------------------|--------------------------------------------|
| **TSB fault**        | The microprogram moves the capability WPM bit into the TSB WPM-bit | The microprogram does a logical AND of the values capability WPM bit and the inverted page-page-write protect and puts the result into the TSB WPM bit |
| **WPM-trap**         | Always signifies write-permit protect-violation trap | If capability WPM=1, then special swapper trap, else normal WPM trap (write permit protect violation trap) |

*Table 12. Database Recovery Procedures*

For the ND-5000 this means: When there is a TSB-fault the Write-Permitted flag in TSB is set to a logical AND of the (Write-Permitted flag in the capability) and the (inverted most significant bit of the last index page entry).

Norsk Data ND-05.020.1 EN

---

## Page 170

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

A write protect violation (WPROTV) is generated when:

1. Attempt to write to a logical segment with not Write-Permitted in the capability

2. Attempt to write to a page with Write-Protect in the last index page entry

---

Norsk Data ND-05.020.1 EN

---

## Page 171

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## 6.5 MMS Implemented on the ND-5000

The MMS can do eight basic functions:

1. MEMR - read memory references
2. MEMW - write memory references
3. MMSR - read register in the MMS
4. MMSW - write register in the MMS
5. TSBC - clear all entries in the Translation Speed-up Buffer
6. TSBL - load TSB entry
7. RPHYS - read last used physical address
8. TRAPC - clear MMS traps

---

### Memory References (MEMR and MEMW)

A memory reference can be initiated through AOPP, DEST or a MEMR control signals.

| Command | Description |
|---------|-------------|
| RMEM    | normal read memory - logical address translation |
| WMEM    | normal write memory - logical address translation |
| RPOFF   | paging off read memory - physical address translation |
| WPOFF   | paging off write memory - physical address translation |
| RPHS    | read memory - physical segment address translation |
| WPHS    | write memory - physical segment address translation |
| RWWP    | read memory which demand write permitted |
| PXING   | check if next logical page is available for a write request |

All memory references can be with **LOCK semaphore set**.

---

### Memory Management References (MMSR and MMSW)

Nearly all registers on this MMS can be both read from and written to by the microprogram. This is very important since it increases the testability of the MMS. Besides the status register, there are ten registers on the MMS chip that need to be controlled. The MMS has ten read and nine write operations.

Norsk Data ND-05.020.1 EN

---

## Page 172

# TSBC Operations and Trap Clear (TSBC, TSBL, RPHYS and TRAPC)

One part of the translation speed-up buffer is called the USED table. When it is necessary to clear the TSB, only the USED table needs to be cleared. To speed up this process, a special RAM chip is used with a separate reset. A reset needs only two master cycles. On the MMS, we have direct access to most of the registers through the parallel 32-bit data/address lines. The TSB memory and the TSBPHS cannot be controlled in this way. To simplify the testing of this part of the MMS, a special command is made to load an entry in the TSB and the TSBPHS. An index to the TSB is made by hashing parts of the LA, PS and (A)DOM. By combining LA, PS and (A)DOM all entries in the TSB can be reached.

Different contents for an entry can be made by combining LA, PS, (A)DOM and WR. The TSBPHS is loaded with LA and PHS. The TSBL command initiates a test by first loading TSB and TSBPHS. The comparison is latched in the STS register in the next cycle, and can be read in the following cycle. The whole TSB RAM can be tested by first filling all the TSB entries and then testing the TSB entries through the STS register. The physical address of memory reference is placed in the page part of the TSB. The microprogram can read the last used physical page number by using the RPHYS command. The LLA(0-11) is placed on the bus as the least significant bits.

| Command | Description |
| --- | --- |
| TSBC | Translation speed-up Buffer Clear |
| TSBL | Translation Speed-up Buffer Load |
| RPHYS | Read the last used PHYSical address |
| TRAPC | TRAP state clear (go to idle) |

Norsk Data ND-05.020.1 EN

---

## Page 173

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## RESTRICTIONS IN USE OF MMS

The following restrictions exist:

- When requesting a memory reference, MMS goes into a BUSY mode until the memory reference is ended. No other requests can be taken care of by the MMS in the same cycle as the memory request or when the MMS is BUSY.

- To generate the hashed index for the TSB, some bits of the logical address and some bits of the (A)DOM and PS registers are XOR'ed together. This hashed index is latched with the same strobe as the LA register. When requesting memory reference, the LA register must be updated after the (A)DOM and PS register. The request for memory reference must be at least one master cycle after the write to LA register request, to allow the data to come to LA and to get the corresponding content of the TSB.

- When writing to a MMS register, the data must be presented two master cycles after the request for MMS register write. In this master cycle, the MIB bus cannot be used to read MMS registers. In this way there can be many read MMS references or many write MMS references in following cycles. But when mixing read and write requests, you must be sure that read and write data do not use the B bus in the same cycle.

Norsk Data ND-05.020.1 EN

---

## Page 174

# 6.6 Registers on the MMS Chip

## PSTP - 0 - Physical Segment Table Pointer - 30 bits - Read/Write

This register, shifted 11 places to the left, points to the start of the Physical Segment Table. You can find PSTP in the ND-5000 monitor by using the command:

ND-5000:LOOK-AT-HARDWARE  
A,IMM,PSTP or A,DMM,PSTP

## PUWP - 1 - Page Used/Written in Page Pointer - 30 bits- Read/Write

This register, shifted 11 places to the left, points to the start of the PUWP table. The table contains two bits per physical page. The bit Page Used (PGU) is periodically checked and used to decide which page is to be swapped out (the oldest). The bit Written In Page (WIP) is set to '1' when something is written into the page. The WIP bit indicates if the page in memory is identical to the page in mass storage.

The maximum table size is 2*(2**29) bits or 2**27 bytes (or the maximum size of a physical segment). The size depends on the amount of physical memory. The PUWP is the 30 most significant bits of the physical address of the first entry of this table. This pointer, plus bits 39-15 of the physical address, point to a word entry of the table. This word contains the WIP and PGU bits for 16 pages. When these bits should be handled by software, special instructions are available.

The PUWP table is a continuous part of the physical memory. This table is always resident in physical memory. When the PUWP pointer is added to physical address, there can be a carry propagating all the way to the most significant bit in the 41-bit address.

## LA - 2 - Logical Address register - 32 bits - Read/Write

This is a three-level pipeline register consisting of LA and LLA. LA is used when writing in LA register from microcode and activating the ENLA line. LLA contains the actual logical address and is used when reading LA register. LA is also used when updating the PUWP table.

---

## Page 175

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## WR - 3 - Working-register - 32 bits - Read/Write

This is a general register for temporary data. The contents of this register depend on the state of the MMS chip:

- Physical segment table entry for process segment
- Index page entry for process segment
- 2nd level index table entry
- 1st level index table entry
- Physical page address when translating using physical segment register. A PSRF flag is set when WR contains such an address. This register is used instead of using a special TSB for this purpose.

## CAP - 4 - The process capability register - 16 bits - Read/Write

This register contains the last used capability of a process.

## PS - 5 - Process Segment register - 13 bits - Read/Write

This register contains the Process Segment Number of the currently executing process. This number is an index in the Physical Segment Table and is used to find the process segment of the process. Each element in the PST is 4 bytes. The maximum size of the PST is then 8192 entries or 32K bytes (16 pages). The size of the PST depends on the number of physical segments in the system. The Physical Segment Table is resident in physical memory. (See PSTP)

## PHS - 6 - Physical Segment register - 13 bits - Read/Write

This register contains the last physical number used in translating a logical address to a physical address, without using the capability table (physical segment request).

## DOM - 7 - Domain register - 8 bits - Read/Write

This register is used to hold the currently executing domain (CED)

Norsk Data ND-05.020.1 EN

---

## Page 176

# Chapter 6: THE MEMORY MANAGEMENT SYSTEM (MMS)

## STS -11 - Status register -32 bits -Read

### Bits 31 to 0

- **Bit 31 - STATE7:** MM-system state register bit 7
- **Bit 30 - STATE6:** MM-system state register bit 6
- **Bit 29 - STATE5:** MM-system state register bit 5

#### Bits 31, 30 and 29 (MM-system state register bits 7-5):

| Bits 31-29 | Description                          |
|------------|--------------------------------------|
| 000        | a POFF read request                  |
| 001        | a POFF write request                 |
| 010        | a request to check next logical page |
| 011        | a read with write permit             |
| 100        | a read request                       |
| 101        | a write request                      |
| 110        | a PHS read request                   |
| 111        | a PHS write request                  |

- **Bit 28 - STATE4:** MM-system state register bit 4
- **Bit 27 - STATE3:** MM-system state register bit 3
- **Bit 26 - STATE2:** MM-system state register bit 2
- **Bit 25 - STATE1:** MM-system state register bit 1
- **Bit 24 - STATE0:** MM-system state register bit 0
- **Bit 23 - LOCK:** A lock request
- **Bit 22 - DIRTY:** Waiting a dirty request
- **Bit 21 - ALT:** Current ALT bit
- **Bit 20 - WIPT:** Capability Written-in-page updated
- **Bit 19 - WRIT:** Write permitted
- **Bit 18 - PARA:** Parameter access permitted
- **Bit 17 - SHAR:** Shared segment
- **Bit 16 - USED:** The USED entry bit
- **Bit 15 - PHSUSED:** Physical segment use of WR
- **Bit 14 - PHSWIPT:** Physical segment written in page table
- **Bit 13 - PHSMISS:** Physical segment TSB miss
- **Bit 12 - INHCW:** Inhibit cache write
- **Bit 11 - MISS:** TSB miss
- **Bit 10 - DOMAT:** (A)DOM-reg. match DDOM
- **Bit 9 - PSMAT:** PS-reg. match DPS
- **Bit 8 - LAMAT:** LA-reg. match DLA
- **Bit 7 - spare**
- **Bit 6 - spare**
- **Bit 5 - ZERO:** Zero in the WR or CAP register
- **Bit 4 - TRAPS:** Indicate a trap to the CPU

#### Trap Code Details

| Bit | Description                 |
|-----|-----------------------------|
| 3   | TRAP3 - Bit 3 in the trap code |
| 2   | TRAP2 - Bit 2 in the trap code |
| 1   | TRAP1 - Bit 1 in the trap code |
| 0   | TRAP0 - Bit 0 in the trap code |

#### Trap Code Bits 3-0

| Bits | Description                                        |
|------|----------------------------------------------------|
| 0000 | 0 - Address out of range - need one more index level |
| 0001 | 1 - Alternative protect violation                  |
| 0010 | 2 - Write protect violation                        |
| 0011 | 3 - Index error                                    |
| 0100 | 4 - Memory error                                   |
| 0101 | 5 - Memory timeout                                 |
| 0110 | 6 - Indirect capability to another computer        |
| 0111 | 7 - Indirect capability within the computer        |
| 1000 | 8 - Zero in the capability                         |
| 1001 | 9 - Zero in the capability (DMM and ALT protect violation) |
| 1010 | 10 - Zero in the capability (DMM and write protect violation) |

*Norsk Data ND-05.020.1 EN*

---

## Page 177

# Chapter 6 THE MEMORY MANAGEMENT SYSTEM (MMS)

## Violation Codes

| Code | Description |
|------|-------------|
| 1011 -11 | Zero in physical segment table entry for PS or zero in the capability (DMM, write and ALT protection) |
| 1100 -12 | Zero in last-level index entry for PS |
| 1101 -13 | Zero in physical segment table entry |
| 1110 -14 | Zero in second-level index entry |
| 1111 -15 | Zero in last-level index entry |

## DIRTY -14 - Dirty register - 21 bits - Write

When the DIRTY register is written to, the DIRTY bit in the status register is set, and a read access to DOM or PS gets parts of the DIRTY register. A memory access also uses this register. The ENDI line also loads this register. Bits 13-20 correspond to DOM register, and bits 0-12 correspond to PS register. The DIRTY flag in status register is set when DIRTY is loaded and reset when a memory request is ended, or by a TRAPC command.

## ADOM -15 - Alternative Domain number - 8 bits - Read/Write

This register is used to hold the currently executing alternative domain (CAD).

---

Norsk Data ND-05.020.1 EN

---

## Page 178

I'm sorry, I cannot process an image without visible text or meaningful content. Please provide a different image or further instructions.

---

## Page 179

# Chapter 7 The Instruction and Data Address Controller (IDA)

Norsk Data ND-05.020.1 EN

---

## Page 180

I'm unable to assist with the content of this document.

---

## Page 181

# Chapter 7  THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.1 General

The Instruction and Data Address Controller (IDA) baby card has three main parts, and each contains a gate array chip:

- **The Instruction Address Controller (IAC),** which generates three values:

  - The next address to be cached in the instruction cache when a cache miss occurs

  - The logical addresses for fetch operations

  - The alternative branch addresses for conditional branches

The IAC is used to generate the next address to be cached in the operand cache when cache miss, to generate logical addresses for fetch operations, and to generate alternative branch addresses for conditional branches.

- **The Instruction Decode Unit (IDU),** which is used for decoding instructions and operands. When a cache miss occurs, the instruction cache is filled with operand and instruction characteristics.

- **The Data Address Controller (DAC),** which handles the ALU-operand address with a general 32-bit adder. The address operands are specified either by the instruction cache content or by the microprogram. The DAC operand control-source is selected by the microprogram.

The IDA also contains programmable array logic units (PALs) for nanosequencing and controlling.

Two gate arrays are used for the hardware of the instruction address controller (IAC) and the data address controller (DAC). The IAC gate array and the DAC gate array are nearly identical from a hardware point of view, but signals and registers are named differently within each.

Norsk Data ND-05.020.1 EN

---

## Page 182

# Chapter 7: THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## Instruction Bus (IB)

- Instruction Memory Management (IMM)
- Extension Bus (XT Bus)

### Instruction and Data Address Controller (IDA)

| Components                              |
|-----------------------------------------|
| Instruction Address Controller (IAC)    |
| Instruction Decode Unit (IDU)           |
| Instruction Map (IMAP)                  |
| Operand Map (O-MAP)                     |
| Instruction Cache (IC)                  |
| Data Address Controller (DAC)           |
| DAC Out Register (DACR)                 |
| Data Logical Address Hold Register (DLAH) 
| Operand Cache (OC)                      |
| Address Cache (AC)                      |

## Data Components

| Components                              |
|-----------------------------------------|
| Data Memory Management (DMM)            |
| Data Bus (DB)                           |
| Data Cache (DC)                         |

Figure 35. The Instruction and Data Address Controller

Norsk Data ND-05.020.1 EN

---

## Page 183

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.2 THE INSTRUCTION ADDRESS CONTROLLER (IAC)

The IAC gate array hardware is shown in figure 36. There are several sources of control to the IAC. The IAC is used:

- By the microprogram to read/write registers (AOPR, DEST)
- To generate the address to next instruction part to be cached in OC (TBC)
- To generate alternative branch addresses in conditional branch instructions (ABR). (ABR is also used in CALL/ENTER sequences.)
- To generate logical addresses for fetching more instruction data by the IDU control in the fetch sequences
- To let the new address out to IAR in break sequences

The registers in the instruction address controller are described in table 13.

| Registers in IAC | Explanation |
|------------------|-------------|
| NPC              | Address pointer to next (operand specifier) |
| P                | Program counter (address to 1st instruction part) |
| SP               | Saved program counter |
| L                | Link register |
| Y                | Destination register for TBC calculations |
| S                | Destination register for most ABR calculations |
| ILAR             | Instruction logical address register |
| LENI             | Register for saving LEN output from the operand cache (OC) used by address branch calculations |
| DPI              | Register for saving DPA output from OC/IDU |

TBC = to be cached  
ABR = address branch  
OC = operand cache  
DPA = data part bus

*Table 13. Register Description for the IAC*

Norsk Data ND-05.020.1 EN

---

## Page 184

# Chapter 7  THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

Outside the gate array there are two registers used together with the IAC:

- **LA** - logical address register is placed on the IB bus, containing the same address as IAR - address register to instruction cache.
- **FLA** - fill logical address register holding next address to be fetched from the MMS.

Microprogrammed read and write of these registers is done from the group SPECIAL in A and D operand fields (IB = instruction bus):

|            |                  |           |
|------------|------------------|-----------|
| A-operand: | A,SPEC,LA        | LA -> IB  |
|            | A,SPEC,FLA       | FLA -> IB |
| Destination:| D,SPEC,LA       | IB -> LA  |
|            | D,SPEC,FLA       | IB -> FLA |

Norsk Data ND-05.020.1 EN

---

## Page 185

# Chapter 7: THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## Block Diagram for the IAC Gate Array

### Components

| Component             | Description                               |
|-----------------------|-------------------------------------------|
| Microinstr. bus (MIB) | Microinstruction bus                      |
| MUX                   | Multiplexer                               |
| MIB                   | Microinstruction bus                      |

### Registers and Counters

- **Next program counter (NPC)**
- **Program counter (PC)**
- **Link (L) register**
- **Operand length (LENI)**
- **Destination for most ABR calculations (S)**
- **Destination for TBC calculations (Y)**
- **Saved program counter (SP)**
- **Data part register (DPI)**

### Selections and Detection

- **A-operand selection (AASEL)**
- **B-operand selection (ABSEL)**
- **Output selection (OSEL)**
- **Enable IAC to MIB (EIAMIB)**
- **Zero detection (ZDET)**

### Address and Data Part Bus

- **Data part bus (DPA)**
- **Enable IAC to data part bus (EIADPA)**
- **+4 address hold register in fetch sequence (ILAR)**

### Notations

- **MUX** = multiplexer
- **MIB** = microinstruction bus

**Figure 36. Block Diagram for the IAC Gate Array**

Norsk Data ND-05.020.1 EN

---

## Page 186

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.2.1 Control of IAC from Microprogram

| AOPR:      |                        |                   |
|------------|------------------------|-------------------|
| A,IAC,NPC  | NPC + 0  -> MIB -> IB  |                   |
| A,IAC,PC   | P + 0    -> MIB -> IB  |                   |
| A,IAC,SP   | SP + 0   -> MIB -> IB  |                   |
|            | Y direct -> MIB -> IB  | A,IAC,Y           |
|            | S direct -> MIB -> IB  | A,IAC,S           |
|            | L + 0    -> MIB -> IB  | A,IAC,L           |
|            | ILAR + 0 -> MIB -> IB  | A,IAC,ILAR        |

| DEST:      |                        |
|------------|------------------------|
| D,IAC,NPC  | IB -> MIB -> NPC / ILAR|
| D,IAC,PC   | IB -> MIB -> P         |
| D,IAC,L    | IB -> MIB -> L         |
| D,IAC,S-L  | SUM -> L               |
| D,IAC,CKNPC| LA -> NPC / ILAR       |
| D,IAC,CKP  | NPC -> P               |
| D,IAC,CKSP | P -> SP                |

| ABR:       |                        |
|------------|------------------------|
| NEXT       | NPC + LENI -> S        |
| NPCREL     | NPC + DPI -> S         |
| NEXTL      | NPC + LENI -> L        |

| TBC:       |                        |
|------------|------------------------|
| NEXT       | NPC + LEN -> Y         |
| SUBR       | O + DPI -> Y           |
| NPCREL     | NPC + DPI -> Y         |
| PREL       | P + DPI -> Y           |
| TEST       | ILAR+ 4 -> ILAR (for test) -> FLA |

*Table 14. Control of IAC from Microprogram*

The TBC code is only activated by nanocontrol in fetch sequence, or by modus bit IACTM (IAC test modus). See figure 36.

Norsk Data ND-05.020.1 EN

---

## Page 187

# 7.3 The Instruction Decode Unit (IDU)

The Instruction Decode Unit (IDU) is placed between the instruction memory management and the instruction cache in the instruction stream, as shown in figure 37. This means that when a cache miss occurs, the instruction decode unit puts the decoded information into the instruction cache system.

| Instruction memory management (IMM) | → | Instruction decode unit (IDU) | → | Instruction cache when cache miss (ICA) |

*Figure 37. The Instruction Decode Unit in the Instruction Stream*

The IDU is used for:

- Decoding instructions and operands
- Filling the operand cache with operand and instruction characteristics when cache miss
- Handling of some trap functions

The IDU gate array:

- Receives data on the 32-bit DPA-bus, coming from the Instruction Bus (IB)
- Picks out instruction codes (12 bits), prefixes (4 bits), address codes (8 bits) and data parts (32 bits), each coming out on specified buses
- Calculates instruction part lengths (4 bits - in bytes) (instruction part is operand specifier + instruction code)
- Checks instructions and operands for legal codes
- Takes care of traps, described on page 178

Norsk Data ND-05.020.1 EN

---

## Page 188

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.3.1 Aligning

Instruction data is buffered in the two 32-bit buffers B1 and B2. A byte pointer (VLB) points to the start byte (in B2) of the current decoding step (decoding is always started from B2). Four multiplexers are used to get the corresponding bytes onto the instruction align bus (IAL-bus).

For INC, ADC, PREFIX, instruction data is aligned towards the most significant bit. For DPA < 4 bytes, instruction data is aligned towards the least significant bit. The length (in bytes) of each decoding step (LC = length code) is calculated and used to update VLB and ILEN (instruction part length).

The byte pointer (VLB) and the length code (LC) are also used to determine whether there is enough data in the buffers to do decoding, or if the buffers must be filled.

Norsk Data ND-05.020.1 EN

---

## Page 189

# 7.3.2 IDU Handling of ND-500 Instructions

The ND-500 instruction format is shown in figure 38. The ND-500 instructions have a variable format length, determined by:

- Instruction type
- Operand types
- Number of operands

| instruction code | prefix  | address code  | data part  |
|------------------|---------|---------------|------------|
| 1 or 2 bytes     | zero to | 2 bits or     | from 6 bits|
|                  | 2 bytes | 1 byte        | to 8 bytes |

1st operand specifier (if any) | more operand specifiers (if any)

*Figure 38. The ND-500 Instruction Format*

## The Instruction Codes (INC)

Instruction codes can be long (2 bytes) or short (1 byte). If they are long, the 4 most significant bits are all '1'. This is decoded, and the 12-bit instruction code (INC) is selected from IAL and put in the instruction code register (INCR). INCR then points to the I-MAP, which gives some instruction characteristics and the entry-point to the microprogram.

## The Address Codes (ADC)

Most operand specifiers do not contain prefixes. That is why an expected address code is selected. Expected address code is the byte following immediately after the instruction code. The IDU checks whether there are prefixes. If not, it points to the O-MAP, and no extra cycle is needed.

The address code is only one byte long and is put in the address code register (ADCR). ADCR points to the O-MAP, which gives information about the operand, and also the illegal address code signal to the IOS trap.

Norsk Data ND-05.020.1 EN

---

## Page 190

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## THE PREFIX

If there are any prefixes, the prefixes and the actual address code are selected and an extra cycle is inserted to get time to read the O-MAP with the new address code.

Each prefix code occupies one byte in the instruction stream, and the IDU can detect three prefix codes, one after another. One or two prefixes are allowed. The only legal double prefix is ALT DESC. Other combinations are illegal. A third prefix is detected and give the ILLCOM signal to an IOS trap.

## THE DATA PART (DPA)

For short data parts (displacements, constants), the data part is contained in the address code (ADC), and does not occupy extra bytes in the instruction stream. It is possible to specify data parts of types other than instruction type. Data-part preparation includes sign extension (constants and direct operands are signed) and zero-fill (other displacements are unsigned). 6-bit short displacements have unit word, so *4 converts to unit byte.

| Constant  | 
|-----------|
| mismatch  |

On constant mismatch, there is a hardware branch to convert the constant to the correct representation according to the data type of the instruction. A type specification of 4 bits (CMTP) is issued to the MIC, in order to give the appropriate branch vector.

| Double       |
|--------------|
| floating     |

Double floating constants occupy 8 bytes in the instruction stream. The maximum aligned quantity is 4 bytes. The decoding must then be done in two steps, with updating of VLB and ILEN in each step: The most significant 4 bytes are taken out on the DPA, to DAC and AC. The rest (least significant 4 bytes) are then taken out on the DPA and placed in the operand cache (OC) on Cache Write.

Norsk Data ND-05.020.1 EN

---

## Page 191

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.3.3 MICROPROGRAMMED READ/WRITE REGISTERS IN THE IDU

| A-operand  |                                                                                    |
|------------|------------------------------------------------------------------------------------|
| A,IDU,TE   | - trap enable register (7 bits)                                                    |
| A,IDU,HL   | - high-limit register (32 bits)                                                    |
| A,IDU,LL   | - low-limit register (32 bits)                                                     |
| A,IDU,LIMC | - limit control register (2 bits)                                                  |
| A,IDU,MISTS| - status register (12 bits)                                                        |
| A,IDU,DPA  | - DPA register (32 bits)                                                           |
| A,IDU,B2   | - register buffer 2 (32 bits)                                                      |

| Destination |                                                                                    |
|-------------|------------------------------------------------------------------------------------|
| D,IDU,TE    | - trap enable register (7 bits)                                                    |
| D,IDU,HL    | - high-limit register (32 bits)                                                    |
| D,IDU,LL    | - low-limit register (32 bits)                                                     |
| D,IDU,LIMC  | - limit control register (2 bits)                                                  |
| D,IDU,CSIT  | - conditional single instruction trap (1 bit)                                      |
| D,IDU,MISTS | - status register (12 bits)                                                        |
| D,IDU,IBUF  | - fill buffer from microprogram (32 bits)                                          |

*Table 15. Microprogrammed READ/WRITE Registers in the IDU*

Norsk Data ND-05.020.1 EN

---

## Page 192

# 7.3.4 Traps Residing in the IDU

12 bits of the ND-5000 macrostatus register reside in the IDU. The macrostatus register is described fully from page 72 to page 81.

| Bit type        | Status       |             |          |
|-----------------|--------------|-------------|----------|
|                 | bit no.      | Code        | Name     |
| Non-maskable    | 0            | XSE         | Index scaling error |
|                 | 1            | IIC         | Illegal instruction code |
|                 | 2            | IOS         | Illegal operand specifier |
|                 | 3            | ISE         | Instruction sequence error |
|                 | 4            | PV          | Protect violation |
| Trace traps     | 17           | SIT         | Single instruction trace |
|                 | 18           | BT          | Branch trace |
|                 | 19           | CT          | Call trace |
| Address traps   | 21           | ATF         | Address trap fetch |
|                 | 22           | ATR         | Address trap read |
|                 | 23           | ATW         | Address trap write |
|                 | 24           | AZ          | Access zero trap |

*Table 16. IDU Macrostatus Bits*

The status bits can be read and written from the microprogram. In addition, most of them have inputs generated by hardware.

The non-maskable traps are *during traps*. Non-maskable means there are no bits in the trap enable (TE) register to enable/disable them. But in the hardware, there is an enable signal for these traps, TRAPEO, for control purposes.

Trace traps and address traps have a corresponding bit in the TE register. They are *after traps*, and are sampled. This is controlled by TRAPE1.

The TRAP signal is wired OR of all traps, and a special microprogram part is entered by a hardware branch.

Norsk Data ND-05.020.1 EN

---

## Page 193

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## ILLEGAL CODES

Among the non-maskable traps, the illegal codes IIC, IOS and ISE can occur during fetch. Instruction parts causing illegal code(s) are never written in the instruction cache.

The illegal codes have several sources and can be found in several IDU nanostates of the fetch sequence. One particular state (called TRAPSTEP) is entered when a trap reason is present (a trap to be). To simplify the transition to TRAPSTEP, it only happens from the TBCEN state (TRAPSTEP is entered instead of CACHEWR state). To make this simplification work, a ranking of the different trap conditions is necessary:

1) IMMTRAP (instruction MMS trap)  
2) PISE (condition causing ISE)  
3) PIIC (condition causing IIC)  
4) PIOS (condition causing IOS)  

This ranking means that conditions with low number prevents the detection of conditions with higher numbers. But the fetch sequence proceeds as normal to reach the TBCEN state, except that any IMMTRAP or PIIC terminates any attempt to process more instruction data.

## LIST OVER ILLEGAL CODE CONDITIONS

- **ISE** - instruction sequence error. No ENTER after CALL or no CALL before ENTER, is detected in IDU. The microinstruction G,COOPS (get next instruction and operand specifier after CALL) signals that an ENTER should be found.

  Other conditions for ISE exist, which are found by microprogram. ISE is an illegal code that must also be detected when instruction cache hit. If the instruction sequence is wrong, the next instruction can give cache hit because it can be written there legally.

- **IIC** - illegal instruction code, signalled by the ILLI-bit in the instruction map.

- **IOS** - illegal operand specifier, which has several hardware reasons:

Norsk Data ND-05.020.1 EN

---

## Page 194

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## Hardware reasons for illegal operand specifier (IOS):

- Write to a constant
- Illegal constant
- Descriptor addressing of register or constant
- Implicit descriptor addressing of register or constant (see note 2 below)
- Alternative addressing of register or constant
- Load address of register or constant
- Alternative addressing when load address access (see note 1 below)
- Implicit descriptor addressing of descriptor (see note 2 below)
- Illegal combination of prefixes
- Illegal address code

## NOTES:

1. ALT prefix is not allowed for JUMPG or for the parameters in CALL. The microprogram tests when JUMPG occurs. The parameters in CALL are accessed as load address. All load-address accesses with ALT prefix give IOS, since the microcommand LADDR is used for the detection. This means that RLADDR/BLADDR with ALT prefix can give IOS.

2. There are instructions where some operands are implicit descriptor addressed, other operands are not. In those cases, bit 4 in the modus register (implicit descriptor disable - IDDIS) disables the implicit descriptor signal that originated from the instruction code.

Keep in mind: Some instructions do not have operand specifiers, some operand specifiers do not have address codes.

Norsk Data ND-05.020.1 EN

---

## Page 195

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.4 The Data Address Controller (DAC)

```
            Operand bus        
              (O-bus)           
                 |              
    +----------------------+
    | Data address         |
    | controller gate array |
    | (DACG)               |
    +----------------------+
                 |
                 | DAC-out bus 
                 |
    +----------------------+
    | Timing/ bus          |
    | control              |
    +----------------------+
                 |
    +----------------------+
    | Address cache        |
    | (AC)                 |
    +----------------------+
                 |             
                 |
    +----------------------+
    | Working register file |
    | (WRF)                |
    +----------------------+
                 |             
                 |
    +----------------------+
    | DAC-out register     |
    | (DACR)               |
    +----------------------+
                        To ALU 

    +----------------------+
    | Data cache           |
    | control (DCC)        |
    +----------------------+
                 |
    +----------------------+
    | Data cache           |
    | (DC)                 |
    +----------------------+

    +----------------------+
    | DAC nanostate        |
    | controller (DACC)    |
    +----------------------+
                 |
                 |
   Control word  Control word
   I-level (CI)  M-level (M)
```

*Figure 39. DAC Implementation Top Level View*

The instruction and data address controller (IDA) baby card is implemented with the gate array DACG and the nanostate controller DACC. Most of the sequencing functions are placed outside the DACG. Therefore, DACC controls the additional state DAC calculations, communicating with the data cache controller (DCC) as well as the timing and bus control.

The DAC gate array includes most of the hardware, like the DAC registers, the general adder, and multiplexers to choose proper adder operands.

The DC lookup is done by the contents of the DACR register. The default source to the DACR register is the address cache (AC) from the I-level. The DAC gate array sources:

- DACR microcontrolled through the codes ADACT*ADARC (microaddress calculation), AB, ADR AB, EA1DIR and AB, ADDR+4
- DACR on macroaddresses which are not AC qualified, and when the AC qualified AC address proves to be wrong (AC-miss)
- The address cache contents in cache write during the fetch sequence.

*Norsk Data ND-05.020.1 EN*

---

## Page 196

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

The registers in the data address controller are described in table 17.

| Registers in DAC | Explanation |
| ---------------- | ----------- |
| B                | Base register |
| R                | Record register |
| XS               | Scaled index register from WRF |
| EA0-3            | Effective address registers 0-3, scratch registers for data address arithmetic |
| DLAR             | Data logical address register |
| DPAR             | Data part register |

*Table 17. Register Description for the DAC*

Norsk Data ND-05.020.1 EN

---

## Page 197

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## Block Diagram for the DAC Gate Array

| Element                                | Abbreviation   |
|----------------------------------------|----------------|
| Scaled index register                  | XS             |
| Record register                        | R              |
| Base register                          | B              |
| Argument                               | ARG            |
| Effective address registers            | EAO-EA3        |
| Data part register                     | DPAR           |
| Data logical address register          | DLAR           |
| Enable DAC data part                   | EDADPA         |
| A-operand selection                    | AASEL          |
| B-operand selection                    | ABSEL          |
| Output selection                       | OSEL           |
| Enable DAC to DAC-out                  | EDADA          |
| Page border crossing for data address  | PBCR           |
| Check AC-miss                          | CHACM          |
| Address cache miss                     | AC-miss        |
| Zero detection                         | ZDET           |

Figure 40. Block Diagram for the DAC Gate Array

Norsk Data ND-05.020.1 EN

---

## Page 198

# 7.4.1 DAC Function

The main task of the DAC is to calculate the data addresses for ALU operands. The main computing resource is a general 32-bit adder. The DAC adder operands are controlled either by the operand cache (OCA) contents or by the microprogram. The microprogram decides if the OCA is to control the operand selection. The result of the calculation is used in one of three ways:

1. As data to be cached in the address cache during the fetch sequence

2. As a basis for checking address cache contents used as ALU operand address

3. Itself as ALU operand address after wrong address cache contents, or because the address is not address cache qualified

AC qualification is controlled by the OCA-bit ACQ. In macro indirect calculations, it is the indirect address which is address cache qualified. Final addresses are not address cache qualified for indirect or post-indexed macrocalculations. Only macroaddresses can be AC qualified.

The DAC calculates the +4-address with a specialized +4-adder, working in parallel with the general adder. The intended use is for double floating operands.

In addition, the DAC detects operands crossing a page limit.

The microprogram can use the EA registers in the DAC to store address calculations for later use. Registers reached by the microprogram as ALU A-operand source and destination are:

- B (base)-register
- R (record)-register
- Four EA registers

In addition, the microprogram Mini and Short arguments are extended and routed through the DAC.

Norsk Data ND-05.020.1 EN

---

## Page 199

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.4.2 DAC Pipeline Connection

The ND-5000 CPU operates in a pipeline frame. Each resource is supplied with the master clock to finish their tasks within one pipeline cycle. The pipeline cycle contains one or more master cycles, depending on the needs in the various resources.

1. The first level of pipeline brings up control-store contents (CI-bits).

2. These CI-bits are pipelined to constitute M-bits, controlling the second level of pipeline, the data level (M-level). The DAC is controlled by the M-level: A pipeline clock (ECMIR and ECOP) makes the DAC initiate a new DAC operation. The DAC then holds the pipeline until the operation is finished.

3. The M-level induces the third pipeline level, the ALU level.

4. The operation results in either an address or an ALU A-operand, the finishing level (F-level).

The address calculation is also initiated during the fetch sequence. The DAC is now used as a resource in the first pipeline level for computing Address Cache contents.

The address calculation executed in the DAC is controlled either by the M-bits (the microaddress) or by the operand cache (OCA) contents (the macroaddress). When the final macroaddress is address cache qualified, the ND-5000 uses the contents from the address cache, and the DAC does not halt the pipeline. The DAC detects a wrong Address Cache content in the first master cycle in the next pipeline cycle (AC-miss). The correct address can then be taken from the EAO register inside the DAC. For final macroaddresses that are not address cache qualified, the DAC halts the pipeline until the calculated address is delivered to the external DACR register.

Norsk Data ND-05.020.1 EN

---

## Page 200

# 7.4.3 Interpretation of the DAC Control Fields

The microbit ADACT (Address Activate) tells the DAC to calculate an address, while the microbit Ad.Arit.Con. (Additional Arithmetic Control) tells whether OCA or the microprogram is to control the calculations. The interpretation of the arithmetical control is as follows:

| ADACT: Ad.Arit.Con. | → | Microaddress arithmetical control |
| ------------------- |---| --------------------------------- |
|                     |   | OCA address arithmetical control  |
| ADACT:              | → | The ALU A-operand microfield controls the adder. |

The DAC output can be driven by four different sources: The ADDER, the EAO or EAI register, or the ADDR+4 unit. The interpretation of the microprogrammed output selection is as follows:

| ADACT = 1       | → | AB,ADDER   | → | ADDER (EA0)                      |
|-----------------|---|------------|---|---------------------------------|
|                 |   | AB,EA1DIR  | → | EA1                             |
|                 |   | AB,ADDR+4  | → | ADDR+4 (ADDER IF CNST)          |
| (ADACT = 1) and (Ad.Arit.Con. = 1) | → | ADDER                         |

| ADACT = 0       | → | A,DAC,EAO  | → | EAO                             |
|-----------------|---|------------|---|---------------------------------|
|                 |   | A,DAC,EA1  | → | EA1                             |
|                 |   | A,DAC,XX   | → | ADDER                           |

In case of inconsistent specification, the specification on the uppermost line is selected. EAO in brackets under AB,ADDER reflects the special situation when output control is reclocked inside the succeeding pipeline cycle.

Norsk Data ND-05.020.1 EN

---

## Page 201

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.4.4 Arithmetic Operations

The general adder in the DAC is controlled either by microprogram directly or by the QCA through the operand bus (O-bus). The control source is selected through the microbit Ad.Arit.Con. The adder is fed with two 32-bit data operands.

Only two datawords can be added in one master cycle. Some of the arithmetical operations, however, consist of more than two addends. In these cases, the address calculation demands additional cycle(s) controlled by the DAC nanostate controller (DACC), storing the intermediate results in the EAO or DLA register. The final result is always stored in EAO.

Six different registers can be involved in address calculations:

- The four index registers (X-registers)
- The base register (B-register)
- The record register (R-register)

Both the B and R registers are resident in the DAC gate array (DACG), while the X-registers are placed inside the working register file gate array (WRF).

Whenever an X-register is to be used, it is provided, scaled from the WRF gate array. It is then kept in the internal hold register XS inside the DAC gate array. Data only lasts one pipeline cycle in XS.

Norsk Data ND-05.020.1 EN

---

## Page 202

# 7.4.5 Microprogram Controlled Addition

```
AA AB       MINIARG
|  |         |  |  |  |  |
15 12       9  7  5  0
```

| AA | Description  |
|----|--------------|
| 0  | AA,0         |
| 1  | AA,MARG      |
| 2  | AA,DPA       |
| 3  | AA,DATA      |
| 4  | AA,EA0       |
| 5  | AA,EA1       |
| 6  | AA,EA2       |
| 7  | AA,EA3       |

---

| AB | Description            |
|----|------------------------|
| 0  | AB,0                   |
| 1  | AB,MARG                |
| 2  | AB,B                   |
| 3  | AB,R                   |
| 4  | AB,X1                  |
| 5  | AB,X2                  |
| 6  | AB,X3                  |
| 7  | AB,X4                  |
| 9  | AB,ADDER               |
| 10 | AB,EADIR               |
| 11 | AB,ADDR+4              |
| 12 | AB,X1ORS               |
| 13 | AB,X2ORS               |
| 14 | AB,X3ORS               |
| 15 | AB,X4ORS               |

**Table 18. Microcontrolled Addition**

The microprogram controlled additions using an X-register, or the DLAR register (AA,DATA), need more than one master cycle.

### Indirect post-indexed:
1: DATA => DLAR  
2: WRF => XS  
3: DLAR + XS => EA0  

### Indirect:
1: DATA => DLAR  
2: DLAR + AB,xx => EA0  

### Post-indexed:
1: WRF => XS  
2: AA,xx + XS => EA0  

XS represents the correct scaled index register provided by the working register file gate array (WRF).

Norsk Data ND-05.020.1 EN

---

## Page 203

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.4.6 OCA Controlled Addition

Table 19 shows the bits from the operand cache that control the different data macroaddress modes in the DAC.

|       | O-BUS |
|-------|-------|
|       | X     |
|       | I     |
|       | I     |
| O     | DPA   |
| T     | A     |
| B     | N     |
| G     | N     |
| D     |       |

```
0 - data
2 - constant
4 - register

0 - zero
1 - X
2 - B
3 - R

0 -
1 - index register is used in calculation

0 -
1 - indirect
```

*Table 19. DAC Macroaddress-mode Data*

Norsk Data ND-05.020.1 EN

---

## Page 204

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

The different macroaddress modes are described in table 20. See also figure 36 on page 171.

|                      |                    |            | O-BUS                 |          |      |      |      |      |
|----------------------|--------------------|------------|-----------------------|----------|------|------|------|------|
| Microbit ADACT       | = 1                |            |                       |          | X    | X    | X    | X    |
| Microbit Ad.Arit.Con.| = 0                |            | O-BUS                 | XING     | I    | N    | D    |      
|                      |                    | O          | T B                   |          | A    | N    | D    | G    |
|                      |                    |            |                       |          |      |      |      |      |
| REGISTER TRANSFER    |                    |            |                       |          |      |      |      |      |
| LOCAL                | DPA + B => EAO     |            | 0 0                   | 1        | 0    | 0    | 0    | 0    |
| LOCAL P.I.           | DPA + B => EAO,    | p*X => XS  | 0 0                   | 1        | 1    | 0    | 0    | 1    |
|                      | EAO + XS => EAO    |            |                       |          |      |      |      |      |
| LOCAL IND.           | DPA + B => EAO     |            | 0 0                   | 1        | 1    | 0    | 1    | 0    |
|                      | READ               |            | DLA + 0 => EAO        |          |      |      |      |      |
| LOCAL IND. P.I.      | DPA + B => EAO,    | p*X => XS  | 0 0                   | 1        | 1    | 0    | 1    | 1    |
|                      | READ               |            | DLA + XS => EAO       |          |      |      |      |      |
| RECORD               | DPA + R => EAO     |            | 0 0                   | 1        | 1    | 1    | 0    | 0    |
| PRE-INDEXED          | DPA + 0 => EAO,    | X => XS    | 0 0                   | 1        | 0    | 0    | 0    | 1    |
|                      | EAO + XS => EAO    |            |                       |          |      |      |      |      |
| ABSOLUTE             | DPA + 0 => EAO,    |            | 0 0                   | 1        | 0    | 0    | 0    | 0    |
| ABSOLUTE P.I.        | DPA + 0 => EAO,    | p*X => XS  | 0 0                   | 1        | 0    | 0    | 0    | 1    |
|                      | EAO + XS => EAO    |            |                       |          |      |      |      |      |
| REGISTER             | NOOP               |            | 1 0 0                 |          |      |      |      |      |
| CONSTANT             | DPA + 0 => EAO     |            | 0 1                   | 0 0 0 0  |      |      |      |      |

IND. = indirect  
P.I. = post-indexed  

Table 20. Macroaddress Modes

Only the AB field on the O-bus stimulates the adder in the first master cycle of the calculations.

The O-BUS fields XING and IND are used by the DAC state controller, DACC, triggering the corresponding DACC operand state.

The OT field is used in controlling the output selection of the DAC gate array (DACG).

Norsk Data ND-05.020.1 EN

---

## Page 205

# Chapter 7 THE INSTRUCTION AND DATA ADDRESS CONTROLLER (IDA)

## 7.4.7 The EASAVE Microfield

The EASAVE microfield makes it possible to specify storage of the DAC adder result into the EA1, EA2 or EA3 registers (clocked with ECALU). The EA0 register is clocked with ECALU when the microbit ADACT is set, and the DACC reclocking RCEAO when the storing of intermediate results is required.

### EASAVE

|   |         |
|---|---------|
| 0 | 0       |
| 0 | 1 CLOCK EA1 |
| 1 | 0 CLOCK EA2 |
| 1 | 1 CLOCK EA3 |

*Table 21. The EASAVE Microfield*

---

Norsk Data ND-05.020.1 EN

---

## Page 206

# 7.4.8 The Source and Destination Microfields

| A-Operand | Destination |
|-----------|-------------|
| 1 1 1 0 0 0 0 0 | 1 1 1 0 0 0 0 0 |
| 1 1 1 0 0 0 0 1 | 1 1 1 0 0 0 0 1 |
| 1 1 1 0 0 0 1 0 | 1 1 1 0 0 0 1 0 | D,DAC,R |
| 1 1 1 0 0 1 1 0 | 1 1 1 0 0 0 1 1 |
| 1 1 1 0 0 0 1 1 | 1 1 1 0 0 1 0 0 | D,DAC,B |
| 1 1 1 0 1 0 0 0 | 1 1 1 0 0 1 0 1 | D,DAC,S-B |
| 1 1 1 0 1 0 0 1 | 1 1 1 0 0 1 1 0 |
| 1 1 1 0 1 1 0 0 | 1 1 1 0 0 1 1 1 |
| 1 1 1 0 1 1 0 1 | 1 1 1 0 1 0 0 0 | D,DAC,DPA |
| 1 1 1 0 1 0 0 0 | |
| 1 1 1 0 1 0 0 1 | A,DAC,MARG |
| 1 1 1 0 1 0 1 0 | A,DAC,B |
| 1 1 1 0 1 0 1 1 | A,DAC,R |
| 1 1 1 0 1 1 0 0 | A,DAC,XS |
| 1 1 1 0 1 1 0 1 | |
| 1 1 1 0 1 1 1 0 | A,DAC,SARG |
| 1 1 1 0 1 1 1 1 | A,DAC,LARG |

*Table 22. The Source and Destination Microfields*

**Source:**

The source field in the microprogram activates the DAC when the three leftmost bits are all set. The specification of the DAC ALU source leads to occupation of the DAC general adder except for A,DAC,EA0 and A,DAC,EA1. In addition, the output from the DAC is demanded to feed the ALU A-operand.

**Destination:**

The destination field in the microprogram activates the DAC when the three leftmost bits are all set. The loading of the DAC register is done from the DAC-out bus, except for the D,DAC,S-B specification in which the B-register is to be loaded from the DAC general adder.

The DAC ALU-destination can be specified independent of the other microfields.

---

# 7.4.9 The IDUCA Bit

The IDUCA bit is set when the DAC is used in a fetch sequence. This information is used to select the adder as the DAC gate array output, feeding the address cache in cache write cycle, and to prevent active DACC states.

Norsk Data ND-05.020.1 EN

---

## Page 207

# Chapter 8: The Microinstruction Controller (MIC)

Norsk Data ND-05.020.1 EN

---

## Page 208

I'm sorry, I cannot assist with extracting content from copyrighted material.

---

## Page 209

# Chapter 8 The Microinstruction Controller (MIC)

## 8.1 MIC Overview

The microinstruction controller is a baby card that consists of:

- The microinstruction controller gate array (MIC)
- Control logic, implemented in PALs
- The scratch register file (SRF), 32 bits x 4K
- Oscillator for the microsecond counter
- Trace memory for the control store address

Figure 41 shows a block diagram of the MIC card.

| Microaddress Register (MAR) | MIC gate array | Scratch Register File (SRF) |
|-----------------------------|----------------|------------------------------|
| Control Store (CS)          | CSA (control store addr.) |                      |
|                             | control        | XT-bus(0-31)                  |
| feedback from CS            |                |                              |
|                             | SRFA(0-12)     |                              |
|                             | P A L          |                              |
|                             | control        | CSA-bus                      |
|                             |                | control                      |
|                             |                | MIC BABY CARD                |

*Figure 41. The Microinstruction Controller Baby Card (MIC)*

Norsk Data ND-05.020.1 EN

---

## Page 210

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.2 TASKS OF THE MICROINSTRUCTION CONTROLLER

The microinstruction controller takes care of the following tasks or devices:

1. Microprogram sequencing
2. Scratch register file
3. Macrostatus register
4. Trap enable register
5. Micro-breakpoint register
6. Vector register
7. Microsecond counter
8. Solo-mode cycle counter
9. Control-store address bus

These tasks or devices can be described like this:

1. **Microprogram sequencing.** The main task of the MIC is to control the sequence of the microprogram. This is done by supplying input to the microaddress register (MAR). The MAR input is called the control store address (CSA) bus. This bus has three sources:

   i. The instruction map (IMAP), giving the entry point to each microinstruction
   
   ii. The control store itself (or the instruction cache) through feedback drivers
   
   iii. The MIC

2. **Scratch register file.** Another important task of the MIC is to manage the scratch register file (SRF). This is a 32-bit wide and 4K deep fast static memory located on the MIC card, and accessed via the XT-bus. There are several SRF addressing capabilities offered, and they are all administered inside the MIC. See page 221 for more information about the SRF.

3. **Macrostatus register.** Thirteen bits of the ND-5000 macrostatus register reside in the MIC. The ND-5000 macrostatus register is written/read via the XT-bus. More information is given on page 218.

4. **Trap enable register.** Six of the ND-5000 macrostatus bits in the MIC have a corresponding trap enable bit. They are written/read via the XT-bus. This is described in more detail on page 219.

5. **Micro-breakpoint register.** The micro-breakpoint register in the MIC is compared to the current microaddress. If a match is found, a break signal is given. More information is given on page 220.

Norsk Data ND-05.020.1 EN

---

## Page 211

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

6. **Vector register.** The 8-bit vector register is used to calculate the microaddress when a JMPREL instruction is given. A new address is generated by adding the vector to the lower half of the current address and extending the carry from bit 7. See page 218 for more information.

7. **Microsecond counter.** The MIC contains a 32-bit microsecond counter with crystal oscillator. This is a clearable counter that is read via the XT-bus. It increments each microsecond, and has several test possibilities. This is described in more detail on page 220.

8. **Solo-mode cycle counter.** When the ND-5000 CPU is in solo mode, i.e. after a SOLO instruction, this counter is used as a timeout. The counter is eight bits wide and counts the number of TSAMP signals. See page 217 for details.

9. **Control store address bus.** The entire control of the control-store address bus (CSA) is located on the MIC card, and is implemented in fast (15 ns) PALs.

The sequencer part of the MIC has a *four-word deep stack*, located inside the MIC gate array. This stack is used for holding return addresses from subroutines and exceptions. The sequencer part also takes care of traps and other exceptions, and supplies the appropriate exception vector.

The MIC is controlled by the *sequence control field* (bits 60-69) of the ND-5000 microword. This field contains the following bits:

| ND-5000 microword bit number | Name of bit(s) | Function                                    |
|------------------------------|----------------|---------------------------------------------|
| 69                           | CSEQ           | Enables conditional sequence                |
| 60                           | ISEQ           | Enables inverted sequence                   |
| 65-68                        | TSEQ(0-4)      | The TRUE field, specifies TRUE sequence     |
| 61-64                        | FSEQ(0-4)      | The FALSE field, specifies FALSE sequence   |

*Table 23. The ND-5000 Microword Sequence Control Field*

The *instruction map* (IMAP) is a table of pointers, one for each macroinstruction, giving the start address for the microroutine belonging to that particular macroinstruction. Whenever an instruction, that is not resident in cache, should be executed, the first microaddress is given by the IMAP. Thereafter, the addressing sequence is taken care of by MIC.

Norsk Data ND-05.020.1 EN

---

## Page 212

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

When writing microcode for the ND-5000, sequence and stack operations must be defined in every instruction. The possible sequence instructions are:

| Instr.  | Address of following instruction =                     |
|---------|-------------------------------------------------------|
| JMP     | Jump address found in the current microword           |
| JMPREL  | Jump address + vector held inside the MIC             |
| RETURN  | Address residing on the top of stack inside MIC       |
| NEXT    | Address of the current instruction + 1                |

A 16-bit field in the ND-5000 microword, called *the micro jump-address*, tells which address is to be executed after the current instruction. The micro jump-address is fed back to the microaddress register through drivers controlled by MIC. The fastest way to sequence through a piece of microcode is to use this feedback, and that is done by the JMP sequence instruction.

However, sometimes it is necessary to use one of the other instructions to have the 'job' done, and then the MIC switches off the feedback from CS, drive the CSA-bus, and supply the address given by the sequence instruction. The penalty for not using JMP is one extra clock cycle.

---

Norsk Data ND-05.020.1 EN

---

## Page 213

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.3 DATA FLOW INSIDE THE SEQUENCER

**NOTE!** Abbreviations are explained on the next page.

```
     CUR ↥     ___________________________________     VECT
           |                     jmp               |
           |                                        |
           +-------+    +-------+                   +-------+
           |  +1   |    |  -1   |                   | ADDER |
           +-------+----+-------+------●            +-------+
                |       |            vjp |              |
                |       |          ------|--------------+
                |       |             jmp |
                |       |          ----------|
                |       |             nxt |
           +-------+    |          ----------|
           |  NXT  |    |             tos |
           +-------+    |         ------|--|--------------+
                |       |                               |
           +-------+----+                           +-------+
           |  PSA  |                                | TS-MUX|
           +-------+                               +-------+
                |                                    |
           +-------+                                +-------+
           |SI-MUX |------------------------------|  FS-MUX |
           +-------+                              +-------+
                |                                    |
           +-------+                               +-------+
           |  TOS  |                                |  PFS  |
           +-------+                              +-------+
                |                                    |
           +-----------+                            |
           |  STACK    |                            |
           +-----------+                            |
                |                                    |
                |                            +-------+
                |-------------|              | MAIN-MUX|
                                      |    +-------+
                                      |       |
                                      |  +-------+
                                      |   | EMCSA  |
                                      |  (Enable MIC ➞ CSA)
                                      |  +-------+
                                      |       |
                                      |  +-------+
                                      |   | CSA-bus|
                                      |    (pins 0 to 15)
                                      

_**Figure 42. Simplified Block Diagram of the MIC Sequencer**_

---

_Norsk Data ND-05.020.1 EN_

---

## Page 214

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

| Term      | Description                                                    |
|-----------|----------------------------------------------------------------|
| ADDER     | Adder/incrementer, calculates address for JMPREL               |
| CUR       | Current microaddress (copy of MAR)                             |
| EMCSA     | Enable MIC to CSA, output enable signal to MIC                 |
| FS-MUX    | False seq. MUX, selecting source for false sequence            |
| jmp       | Output from CUR, the jump address                              |
| MAIN-MUX  | Main MUX selects the final output to CSA                       |
| MUX       | Multiplexer                                                    |
| nxt       | Output from NXT, gives the NEXT address                        |
| NXT       | Next register = CUR + 1                                        |
| PSA       | Pipelined stack address, NXT delayed one clock cyc.            |
| PFS       | Pipeline register, false sequence                              |
| SI-MUX    | Stack input MUX, select stack source                           |
| Stack     | Four-word deep stack, for microaddresses                       |
| tos       | Output from TOS, current stack value                           |
| TS-MUX    | True seq. MUX, selecting source for true sequence              |
| TOS       | Top of stack, current stack value                              |
| VECT      | Vector register                                                |
| VjP       | Output from adder, the relative jmp address                    |

- Data paths inside the sequencer are 16 bits wide
- This gives an address space of 64K microwords
- Since the microword is 128 bits wide, the maximum control store size is 1 Mbyte

Addresses on the CSA-bus are clocked into the register CUR (a copy of MAR), as shown at top of figure 42. The output of CUR, bus JMP, is both incremented and decremented. The incremented value is stored in the NXT register, and the output of NXT is the value that is used by a NEXT instruction. Output from the decrementer goes to the stack input multiplexer, SI-MUX, and is pushed on stack in the case of a hardware branch (a kind of microinterrupt).

The decremented value of CUR, called DJP, is used directly as a new CSA value to force the previous instruction to be repeated. The NXT register is connected to the SI-MUX, and to both of the sequence multiplexers, TS-MUX and FS-MUX. These MUXes are controlled directly from the two fields called TSEQ and FSEQ in the ND-5000 microword.

The output of TS-MUX is used in the same clock cycle as it is generated, while FS-MUX is pipelined one cycle through the register PFS. The MAIN-MUX is the final selector of output to the CSA, and it can choose among:

1. The TRUE sequence
2. The FALSE sequence
3. The PREVIOUS instruction
4. An EXCEPTION address

Norsk Data ND-05.020.1 EN

---

## Page 215

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

The stack has three sources:

- The NXT register directly
- The NXT register delayed one cycle
- The decremented value of CUR

Output from the stack is used as true sequence or false sequence.

The fourth input to TSEQ/FSEQ is the VJP bus, which is the result of an addition between the CUR register and the VECT register. The ADDER adds the 8-bit VECT to the lower eight bits of the CUR, and increments the upper part of CUR if there is a carry from the adder. A branch vector is generated when one of these signals is recognized by the MIC:

- A trap signal
- A hardware branch signal
- An enable NOOP instruction (ENOOP) signal

Norsk Data ND-05.020.1 EN

---

## Page 216

# 8.4 Sequence Control, General

The microinstruction sequencer is controlled by the sequence control field (bit 60-69) of the ND-5000 microword. This field has:

- One bit, CSEQ, enabling conditional sequence
- One bit, ISEQ, for inverted sequence
- Two times four bits, TSEQ/FSEQ, specifying the TRUE/FALSE sequence

When performing an unconditional (normal) sequence, only the TRUE field is used. Two of the four sequence bits control the next address, and the other two control the sequencer stack, giving the functions in table 24.

| B I T S | C O M M A N D S |
|---|---|
| 3 | 2 | 1 | 0 | Sequence | Stack | Description |
| 0 | 0 | X | X | JMP | -- | CSA <= CI(16:31) (not MIC) |
| 0 | 1 | X | X | JMPREL | -- | CSA <= CI(16:31)+VECT (MIC) |
| 1 | 0 | X | X | RETURN | -- | CSA <= TOS (MIC) |
| 1 | 1 | X | X | NEXT | -- | CSA <= NEXT (MIC) |
| X | X | 0 | 0 | HOLD | Do nothing with the stack |
| X | X | 0 | 1 | POP | TOS <= stk(1), shift stack up |
| X | X | 1 | 0 | LOAD | TOS <= NEXT, no shift. |
| X | X | 1 | 1 | PUSH | TOS <= NEXT, shift stack down |

*Table 24. The TRUE/FALSE Sequence Field in the ND-5000 Microword*

Table 24 shows that the address to the control store can be taken from the following sources:

- Jump address in the microword (bits 16-31)
- Jump address + vector (ADDER inside the MIC)
- Top of the stack (TOS inside the MIC)
- The NXT register (current address + 1, calculated inside the MIC)

In addition, the control store address (CSA) can be a branch vector (BV), generated by a trap or other hardware exceptions, or a repetition of the previous microinstruction.

The sequence control bits are taken from the microinstruction register (MIR) at the M-level of the pipeline.

*Norsk Data ND-05.020.1 EN*

---

## Page 217

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## I-level

The microinstruction controller works at the start of the pipeline, generating address to the I-level (that is MAR). Data on the I-level becomes valid at the end of a microcycle, about 10-15ns before the active edge of the master clock (MACK). MACK loads the address to follow into the microaddress register. 10ns is far too little time to decode the sequence control bits and choose the right source for the next control store address (CSA). Therefore:

- The jump address from the microword on the I-level is always loaded into the MAR, guessing that the current instruction is a jump.

If the guess was right, then the instruction runs in one cycle. If, however, it was not a jump, then the MIC must correct the CSA, and that takes one extra cycle. Hence:

- Jump takes one cycle, other sequence instructions take two.

The MIC decodes the sequence control bits in order to detect if it was a jump or not. In those cases where no jump is found, the MIC takes over and stops the pipeline by issuing the signal `MIC wait (MICW)`. Then the correct CSA is supplied. Thereafter only MAR (I-level) is clocked. To clock only a part of the pipeline is called reclocking, and in this case MAR is reclocked.

## Action rules

The rules for MIC action are:

- **UNCONDITIONAL SEQUENCE**

  In this case, only the TRUE sequence field is checked. If an instruction different from JMP is detected, the MIC takes control in order to bring out the wanted CSA.

- **CONDITIONAL SEQUENCE**

  In the case of conditional sequence (enabled by the CSEQ bit), the TRUE field (TSEQ) is used as the preliminary route for the sequence. If this field contains a JMP, the instruction runs in one cycle. Otherwise the MIC must bring out the CSA, using one extra cycle.

It is important to note that only the JUMP instructions run in one clock cycle. If other instructions are used, an 'extra' cycle is inserted, resulting in two clock cycles per microinstruction. The 'extra' microcycle is the one pointed out by the jump field of the microinstruction that specifies a NEXT, a RETURN or a JMPREL. The 'extra' cycle could be executed by setting the EXUC-bit in the previous microinstruction (see page 210), giving possibilities for advanced programmers.

Norsk Data ND-05.020.1 EN

---

## Page 218

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

### Example:

```
LABEL0   D,NONE     NEXT   F,JMP LABELX;
LABEL1   ........   NEXT*  ;
            ....
            ....
LABELX   ALU,FZRO   D,MIC,VECT  NEXT*;
```

In this case, the extra cycle is the instruction found at the address LABELX.

Note the difference between NEXT and NEXT*. NEXT* is a shorthand notation for JMP to the immediate following instruction (JMP *+1).

Norsk Data ND-05.020.1 EN

---

## Page 219

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.5 Unconditional Sequence

When the conditional sequence bit CSEQ in the microword is false (zero), only the TSEQ field is used. This is called *unconditional sequence*.

## 8.5.1 Sequence Control, Unconditional Sequence

Jump instructions use one clock cycle, while all other instructions use two. Hence a NEXT instruction should normally be implemented as a JUMP to the following address, NEXT* in the assembly notation. The unconditional sequence is the simplest case of sequencing and should not cause any special problems concerning the pipeline.

## 8.5.2 Stack Control, Unconditional Sequence

During unconditional sequence, the stack is controlled directly from the M-level (MIR), this means not pipelined. The stack is updated on the first enabled clock after the M-level has become valid. This corresponds to the stack being at the A-level of the pipeline. The stack has its own enable clock signal (ECSTK), which is a pipelined version of *enable clock MIR* (ECMIR). Unconditional calling of a one-instruction subroutine is possible because the RETURN instruction takes two cycles.

---

Norsk Data ND-05.020.1 EN

---

## Page 220

# 8.5.3 Example of Unconditional Sequence

The following sequence instructions are to be executed:

| TRUE seq. field |
|-----------------|
| μ-addr. | Sequence | Stack | Jmp.addr. | Comment            |
|---------|----------|-------|-----------|--------------------|
| 1       | JMP      | HOLD  | 2         | Jump to next       |
| 2       | JMP      | PUSH  | 6         | Go to subroutine 6 |
| 3       | NEXT     | HOLD  | x         | Go to current + 1  |
| 4       | V.JMP    | HOLD  | 6         | Go to 6+vector = V |
| 5       |          |       |           |                    |
| 6       | JMP      | PUSH  | 9         | Go to subr. 9      |
| 7       | JMP      | HOLD  | 8         | Jump to next       |
| 8       | RET      | POP   | z         | Return to 3        |
| 9       | JMP      | HOLD  | a         | Jump to next       |
| a       | RET      | POP   | z         | Return to 7        |
| z       | JMP      | HOLD  | z         |                    |

*Table 25. Example of Unconditional Sequence*

---

## Page 221

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.6 Conditional Sequence

Conditional sequence is obtained by putting a '1' in the conditional sequence bit (CSEQ) in the microword. In this case, both the TRUE and FALSE fields are valid. Conditions to be selected must be generated in the previous cycle, or earlier, in order to be ready for testing. It is possible to invert the value of the selected condition by putting a '1' into the inverted sequence bit (ISEQ).

## 8.6.1 Sequence Control, Conditional Sequence

The four-level pipeline leads to a problem concerning conditional sequence, because the condition to be tested upon is not valid until two clock cycles after the instruction enters the pipeline. Therefore, the CSA given by the TRUE sequence field is used as a preliminary route, waiting for the condition to be valid.

The alternative CSA, given by

- the FALSE sequence field
- the conditional sequence bit
- the inverted sequence bit

are saved in a pipeline register. Two clock cycles later, the condition becomes valid. If the wrong route was taken, the MIC must:

- Stop the execution
- Bring out the saved address
- Refill the pipeline

Note that the **TRUE sequence is always used as the preliminary route**. Selecting a special preliminary route is done by putting the preferred instruction in the TRUE field, and adjusting the inverted sequence bit.

Norsk Data ND-05.020.1 EN

---

## Page 222

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

Table 26 shows the relations between the contents of the sequence control fields, the next control store address, and the address saved in the pipeline inside the MIC.

| TSEQ   | FSEQ   | CSEQ | Cycles | NEXT-CSA       | SAVED ADDRESS       |
|--------|--------|------|--------|----------------|---------------------|
| jmp    | NEXT   | 1    | 1      | JMP address    | Current + 1         |
| JMP    | RETURN | 1    | 1      | JMP address    | Top of stack        |
| JMP    | JMPREL | 1    | 1      | JMP address    | Jump address + vector |
| NEXT   | JMP    | 1    | 2      | Current + 1    | Jump address        |
| NEXT   | RETURN | 1    | 2      | Current + 1    | Top of stack        |
| NEXT   | JMPREL | 1    | 2      | Current + 1    | Jump address + vector |
| RETURN | JMP    | 1    | 2      | Top Of Stack   | Jump address        |
| RETURN | NEXT   | 1    | 2      | Top Of Stack   | Current + 1         |
| RETURN | JMPREL | 1    | 2      | Top Of Stack   | Jump address + vector |
| JMPREL | JMP    | 1    | 2      | Jpadd + Vect.  | Jump address        |
| JMPREL | NEXT   | 1    | 2      | Jpadd + Vect.  | Current + 1         |
| JMPREL | RETURN | 1    | 2      | Jpadd + Vect.  | Top of stack        |

*Table 26. Relations Between CSA and Saved Address in Conditional Sequence*

## 8.6.2 Stack Control, Conditional Sequence

The same problems described for sequence control exist for stack control. The TRUE/FALSE stack control fields, the conditional sequence bit, and the inverted sequence bit must be pipelined because the stack must not be changed before the result from the condition is known. Control signals are taken from the M-level, and that leads to only one stage of pipelining inside the MIC. A conditional PUSH/LOAD also demands one extra stage of pipelining of the data to be stored on the stack.

Note the following:

- Because the conditional stack operation is pipelined, and the normal operation is direct, you must be careful when mixing conditional and unconditional stack instructions.
- The stack and the sequence control is completely separated. This means that a RETURN does not imply a POP.

Norsk Data ND-05.020.1 EN

---

## Page 223

# Chapter 8  THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.6.3 Restrictions in Calling One-Instruction Subroutines

Calling, in this case, means JMP and PUSH in the sequence control field. There are two restrictions concerning one-instruction subroutines:

1. As a result of the pipelined stack control, a conditional call to a one-instruction subroutine does not work. This is because the return address has not yet been pushed onto the stack. The RETURN instruction would, in this case, use the old stack contents.

2. The first instruction in a subroutine must be unconditional, hence a one-instruction routine must be unconditional.

## 8.6.4 Conditional Branch in the Last Microcycle of a Macroinstruction

Some macroinstructions end with a test on legal parameters, and at the same time they start a new macroinstruction (GET) while waiting for the condition to be valid. If the GET leads to a hit in cache, the first microinstruction of the new macroinstruction is enabled out on the CI-bus immediately, instead of the instruction from CS. The MIC ‘thinks’ it has taken the preliminary route specified in the TRUE field of the last microinstruction, and if the TRUE condition is met, no break occurs.

But the instructions were not carried out, because the GET has forced a new instruction into the pipeline and thus tricked the MIC, that ‘thought’ they came from the control store. If, however, the FALSE condition is met, there is a break in the execution and the pipelined CSA from the FALSE field is supplied by the MIC. This gives the following rule for testing in the last microinstruction of a macroinstruction:

- The instruction giving action on errors shall be put in the FALSE sequence field, and the TRUE sequence field shall always contain a JUMP.

This can be arranged by the inverted sequence bit. The JUMP instruction in the TRUE field ensures a single-cycle instruction.

Example:

| COND  | ILLEGAL  | T,JMP F,| JMP ERROR | INV.SEQ |
|-------|----------|---------|-----------|---------|

This instruction gives a break in the execution if the ILLEGAL signal is TRUE. The address - ERROR - is enabled out and clocked into MAR.

Norsk Data ND-05.020.1 EN

---

## Page 224

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.7 MIC and the EXUC Facility

EXUC is an abbreviation for *execute unconditional*, and this function is controlled by bit 115 in the ND-5000 microword.

When the sequence instructions NEXT, RETURN and JMPREL are executed, an extra ('sneak') cycle is entered into the pipeline, on I-level prior to the 'real' instruction. This instruction is stopped on the I-level, unless the EXUC facility is used. If the extra cycle should be executed, the EXUC bit in the previous microinstruction must be set TRUE. The stack instruction in the extra instruction is carried out when EXUC is TRUE, while the sequence instruction is always invalid.

## 8.7.1 Conditional Sequence and the EXUC

The pipelined nature of the ND-5000 makes it necessary to run two microinstructions after a conditional sequence enters the pipeline (hereafter called EXCYC1 and EXCYC2) until the condition is valid.

These two instructions, EXCYC1 and EXCYC2, enter the I-level, but are normally stopped there. However, by using EXUC, they can be carried out as ordinary instructions. The rules for using EXUC in this case are:

- **EXUC = TRUE** in the conditional sequence instruction causes EXCYC1 to be executed on all pipeline levels.

  The stack instruction of the EXCYC1 is not executed if the pipelined stack control from the previous cycle is nothing but HOLD.

- **EXUC = TRUE** in the conditional sequence instruction, combined with EXUC = TRUE in EXCYC1, causes EXCYC2 to be executed on all pipeline levels. EXUC = TRUE only in EXCYC1 is not legal.

  The stack control of EXCYC2 is valid unless EXCYC1 was also a conditional instruction. When no condition break occurs, the sequence control field of EXCYC2 is valid. Otherwise, this field is neglected.

Norsk Data ND-05.020.1 EN

---

## Page 225

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.8 Exception Processing

Three main types of exception processing are supported by the MIC:

1. EPREV - the previous microaddress are enabled to the control store address bus (CSA).

2. TRAP & ENOOP - a trap or ENOOP vector is enabled to the CSA.

3. Hardware branch (HWB) - a branch vector is enabled to the CSA, and the return address is saved on the stack. There are two types of HWB:
    a. Descriptor branch
    b. Constant mismatch branch

Exceptions are recognized during every cycle of the master clock. The signals generating hardware exceptions last only one clock cycle.

Priority of the different types is as listed above. Descriptor and constant mismatch are generated from the macrocode and never occur simultaneously. The hardware exception leads to a branch in the microcode, where the CSA is given by a MIC generated vector. Bits 5 to 15 of the exception vector are fixed to zero, while bits 0 to 4 are decoded from the descriptor/constant/trap/ENOOP information available as input to the MIC.

When the exception is a HWB, the return address is calculated and pushed onto the stack.

The saved address is JUMPADDR - 1, and thus the instruction generating a hardware branch will have a jump address pointing to the immediately following instruction. TRAP and ENOOP do not save the return address.

## 8.8.1 MIC Behaviour During an Exception

The signals TRAP, ENOOP, ECMB and EDSB generate exception processing. These signals must be valid less than 15 ns after the rising edge of the master clock in the cycle where a HWB is to take place. Since they are non-latched, they must be stable during the rest of the master clock cycle.

During the first cycle of an exception, the main multiplexer selects the branch vector as output. The signal MIC wait (MICW) becomes true in order to tell the environment that the MIC is

Norsk Data ND-05.020.1 EN

---

## Page 226

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

going to refill the pipeline. Both I-level and M-level are reclocked, similar to a conditional break. In the HWB case, CUR-1 is clocked on the stack. The total exception takes two cycles.

Figure 43 shows how a constant mismatch is treated. Descriptor branch is handled exactly the same way, while TRAP and ENOOP differ in that the return address is not pushed onto the stack.

|      |      |      |      |      |      |      |
|------|------|------|------|------|------|------|
| CSA  | zzzzzzzzz< 701 | zzzzzzzzz< 100 | zzzzzzzzz< nnn | zzzzzzzzz< |
| MAR  | 700  | 701  | R    | 060  | R    | nnn  |
| MIR  | ind(677) | ind(700) | o ind(700) | R ind(060) |      |
| A    | exe(677) | o exe(677) | o exe(677) |      |
| F    | res(676) | res(677) | o res(677) |      |
| NEX  | 700  | 701  | o  | 701 R | 061  |
| TOS  | 0    | 0    | ↑  | 700  | 0    | 700  |

|      |      |      |      |      |      |
|------|------|------|------|------|------|
| ECMB |      |      |      |      |      |

|      |      |      |
|------|------|------|
| MICW |      |      |
| Last cycle of previous macroinstruct. in MIR. 1st cycle of new in MAR. | ECMB detected on M-level. MIC outputs vector, reclocks MAR, and prepares for PUSH | Both MAR and MIR are reclocked. CUR-1 is now on the stack (TOS). |
| 1st micro-instruction of exception routine in MIR |

*Figure 43. Hardware Branch Example*

## DESCRIPTOR BRANCH

There are five bits available to give information about the descriptor branch:

- EDSB - enable descriptor branch. The signal should be held for only one cycle of the master clock.

- TPDSB(0-3) - Four bits giving the register no.s X1, X2, X3, X4 and disabling the auto-incrementing of the register and differentiating between READ and WRITE access.

The four TPDSB-bits are used to generate the branch vector. This vector is then used as the next CSA, while the return address is pushed onto the stack.

The return address is the jump address from the microword, minus one.

Norsk Data ND-05.020.1 EN

---

## Page 227

# Chapter 8  THE MICROINSTRUCTION CONTROLLER (MIC)

## CONSTANT MISMATCH BRANCH

Five bits are used to describe the constant mismatch: One enable bit and four information bits, giving sixteen different vectors.

- **ECMB** - this signal enables the constant mismatch branch. The signal should be held for only one cycle of the master clock.

- **TPCMB(0:3)** - four bits used to code the mismatch types.

The four type bits are used to generate the vector, giving the branch address. The return address (jump address minus one) is saved on the stack.

## TRAP AND ENABLE NOOP

A TRAP signal results in a branch to address 100B (octal), while ENOOP gives address 101B on the CSA.

The TRAP/ENOOP input signal to the MIC should be held for only one cycle of the master clock. The return address is not saved.

--- 

Norsk Data ND-05.020.1 EN

---

## Page 228

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.9 X-BUS PART OF MIC

- **EMIXB (Enable MIC to X-bus)**
  - 32 Driver
  - RF1M
  - RF2M
  - SMTC

- **Counters**
  - BRK
  - CNT32

- **Control**
  - CLAR
  - MICEQ
  - PD
  - TDIS
  - MITRAP
  - SRFA (0-11)

- **Registers**
  - MIST
  - CUR

- **Multiplexers**
  - MUX
  - RIN(2)
  - AOPR(8)
  - DEST(8)
  - EPRF1
  - EPRF2

- **Others**
  - VECT
  - STS
  - TE
  - AND
  - OR

- **RF & I/O Control**
  - EOXR
  - CONTROL
    - reg. loading
    - SRF address generation
  
**Figure 44. Block Diagram of the Scratch Register File and MIC I/O Control**

Norsk Data ND-05.020.1 EN

---

## Page 229

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.9.1 Description of the X-Bus Part

Figure 44 shows a block diagram of the MIC I/O-part and the scratch register file. This part of the MIC is responsible for generating of addresses to the scratch register file. It has:

- Several registers for internal control
- A part of the macrostatus register, with a corresponding trap enable register
- A micro-breakpoint register
- A 32-bit counter with a separate clock input

Generation of SRF address, and loading/reading registers connected to the X-bus of the ND-5000, is controlled by the A-operand and destination fields of the microword. When the MIC is used as source on the X-bus (A-operand), bits 89 to 96 of the microword are used directly from the M-level to select the register or SRF address to be used. If the MIC is chosen as destination, bits 76 to 83 of the microword are pipelined two levels, and then used to point to the register or to give the SRF address.

Norsk Data ND-05.020.1 EN

---

## Page 230

# 8.9.2 I/O Commands

The following commands are available to access internal MIC registers, or to supply the scratch register file address.

## MIC addressed as A-OPERAND (reading from MIC)

| µ-symb     | Comment                                           |
|------------|---------------------------------------------------|
| A,MIC,MIST | Enable MICSTATUS to X-bus (10 bits)               |
| A,MIC,VECT | Enable VECTOR reg. to X-bus (8 bits)              |
| A,MIC,RFA1 | Enable RF1-reg. to X-bus (12 bits)                |
| A,MIC,RFA2 | Enable RF2-reg. to X-bus (12 bits)                |
| A,MIC,STS  | Macrostatus register                              |
| A,MIC,TE/BRK | Macrostatus Trap Enable register                |
| A,MIC,CUR  | Current register of the MIC                       |
| A,MIC,CNT32 | 32-bit clearable counter                         |
| A,MIC,RF1  | Use RF1-reg as address to SRF                     |
| A,MIC,RF2  | Use RF2-reg as address to SRF                     |
| A,MIC,RF1D | RF1-reg ➜ addr. SRF & Decrement RF1               |
| A,MIC,RF2D | RF2-reg ➜ addr. SRF & Decrement RF2               |
| A,MIC,DirRF | Use 4 lower bits as address to SRF               |

*Table 27. The MIC A-operand Addresses*

## MIC as DESTINATION (writing to MIC)

| µ-symb     | Comment                                           |
|------------|---------------------------------------------------|
| D,MIC,MIST | Load MICSTATUS from X-bus (10 bits)               |
| D,MIC,VECT | Load VECTOR reg. from X-bus (8 bits)              |
| D,MIC,RFA1 | Load RF1-reg. from X-bus (12 bits)                |
| D,MIC,RFA2 | Load RF2-reg. from X-bus (12 bits)                |
| D,MIC,STS  | Macrostatus register 1                            |
| D,MIC,TE   | Macrostatus trap enable register                  |
| D,MIC,BRK  | Micro-breakpoint register                         |
| D,MIC,CNT32 | Clear the 32-bit counter                         |
| D,MIC,RESTU | Reset Stack Underflow                            |
| D,MIC,RF1  | Use RF1-reg as address to SRF                     |
| D,MIC,RF2  | Use RF2-reg as address to SRF                     |
| D,MIC,RF1D | RF1-reg ➜ addr. SRF & Decrement RF1               |
| D,MIC,RF2D | RF2-reg ➜ addr. SRF & Decrement RF2               |
| D,MIC,DirRF | Use 4 lower bits as address to SRF               |

*Table 28. The MIC Destination Addresses*

Norsk Data ND-05.020.1 EN

---

## Page 231

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.9.3 THE MIC STATUS REGISTER

A-operand/destination for this register is 80H. The MIC has an internal 12-bit status register. The least significant eight bits are the solo-mode cycle counter, bits 8 and 9 are the RF1M8 and RF2M8, bit 10 is test mode for CNT32, and bit 11 is enable test clocking of CNT32.

| Bit no. | Bit name | Description                     |
|---------|----------|---------------------------------|
| 0       | SMCC0    |                                 |
| 1       | SMCC1    |                                 |
| 2       | SMCC2    |                                 |
| 3       | SMCC3    | Solo-mode cycle counter.        |
| 4       | SMCC4    | Read and write                  |
| 5       | SMCC5    |                                 |
| 6       | SMCC6    |                                 |
| 7       | SMCC7    |                                 |
| 8       | RF1M8    | Read only                       |
| 9       | RF2M8    | Read only                       |
| 10      | CTMOD    | Write only                      |
| 11      | CENTCK   | Write only                      |

*Table 29. The MIC Status Register*

## 8.9.4 SOLO-MODE CYCLE COUNTER (SMCC)

The MIC has an 8-bit loadable counter, counting cycles when the computer is running in solo mode. Solo mode means that the process switching is disabled; it is set by the macroinstruction SOLO and reset by TUTTI.

Counting is enabled by the bit PSD (process switch disable) in the macrostatus register. The counter is clocked by the signal TSAMP (trap sample). When it reaches zero, a trap is generated. The SMCC is loaded and read as a part of the MIC status register (80H), using the lower eight bits (bits 0-7).

Norsk Data ND-05.020.1 EN

---

## Page 232

# 8.9.5 Vector Register

A-operand/destination for this register is 81H. The 8-bit vector register is loaded and read on bits 0 to 7 on the X-bus. This register is used to calculate the CSA during a JMPREL instruction, but is also used to test the 32-bit microsecond counter.

# 8.9.6 Register File Address Register No. 1 (RFA1)

RFA1 is a 12-bit register and is one of the possible sources for the scratch register file. The register has A-operand/destination 82H. How to use the register in addressing SRF is described in section 8.10 on page 221.

# 8.9.7 Register File Address Register No. 2 (RFA2)

RFA2 is a 12-bit register and is one of the possible sources for the scratch register file. The register has A-operand/destination 83H. How to use the register in addressing SRF is described in section 8.10 on page 221.

# 8.9.8 Macrostatus Register (STS)

A part of the macrostatus register (STS) is placed inside the MIC. The register has A-operand/destination 84H. Six of the status bits have a corresponding trap enable bit. Bits 30 and 31 are unmaskable trap bits, while the rest do not give a hardware TRAP. When reading the STS, all unused bits give a zero. Table 30 gives a list of the macrostatus bits held inside MIC.

---

## Page 233

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

| Bit no. | Mnemonic | TE-bit | Description                        |
|---------|----------|--------|------------------------------------|
| 0       |          |        | Not used                           |
| 1       | PIA      | No     | Privileged instruction allowed     |
| 2       | PD       | No     | Part done                          |
| 3       | IR       | No     | Instruction reference              |
| 4       | PSD      | No     | Process switch disable             |
| 16      | IOV      | Yes    | Illegal operand value              |
| 20      | BPT      | Yes    | Breakpoint instruction trap        |
| 26      | IX       | Yes    | Illegal index                      |
| 27      | STO      | Yes    | Stack overflow                     |
| 28      | STU      | Yes    | Stack underflow                    |
| 29      | PRT      | Yes    | Programmed trap                    |
| 30      | DT       | No     | Disable process switch timeout     |
| 31      | DE       | No     | Disable process switch error       |

*Table 30. MIC Macrostatus Bits and Trap Enable*

## 8.9.9 Trap Enable Register (TE)

The trap enable register (TE) is used, together with the macrostatus register (STS), to generate traps when some of the bits in STS are set. The register has A-operand/destination 85H. The register is accessed from the X-bus by specifying destination/A-operand address. Table 30 shows which bits in the STS have a corresponding TE bit.

When reading the TE register (A-operand=85H), the micro-breakpoint register is returned in bits 15 to 31, the trap enable bits are read in their correct bit position, and the unused bits are all zero.

Norsk Data ND-05.020.1 EN

---

## Page 234

# 8.9.10 Reading the Current Microaddress (CUR)

The contents of the CUR register can be read on the X-bus. The register has A-operand 86H. The CUR is a direct copy of the MAR. This is a facility implemented for testing purposes. The microaddress read is the address of the next microinstruction in the pipeline. Note that CUR is read only; when using the same destination, address one hits the micro-breakpoint register.

| MAR=CUR   |   | P    | RD-CUR  | N | M |
|-----------|---|------|---------|---|---|
| M-level   |   | P    | RD-CUR  | N | M |
| A-level   |   |      | P       | RD-CUR  | N |
| F-level   |   | P    | RD-CUR  |   |   |

- X-bus (contents): addr(N)

*Figure 45. Reading the CUR Register from the MIC*

# 8.9.11 Micro-breakpoint Register (BRK)

The micro-breakpoint register is loaded through destination 86H, and read back by A-operand 85H. The sixteen least significant bits are used when loading. When reading the register, the value is returned in the sixteen most significant bits, due to the combination with the trap enable register. The BRK register is compared to CUR, and the result is led out from the module as a separate pin MICEQ.

# 8.9.12 Microsecond Counter (CNT32)

The microsecond counter is a 32-bit counter, with an external clock input that is divided by ten (prescaler) before it is used to increment the counter. In order to test the counter, some extra test logic is added. This test feature makes it possible to split the counter into four 8-bit parts, with a separate carry input, while counting synchronously with the system clock MACK. The counter and the prescaler are cleared to zero by writing to destination 87H. It is not possible to load the counter to a specific value. The external counting frequency is asynchronous compared to the master clock, and there is no synchronization in hardware. This is taken care of by the microprogram (read twice and compare).

**Norsk Data ND-05.020.1 EN**

---

## Page 235

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.10 Addressing the Scratch Register File

The scratch register file (SRF) can be addressed in two ways:

- Direct addressing through the A-operand/destination field
- Indirect addressing via one of the two scratch register file address registers (SRFA).

The SRFA registers are implemented as loadable downcounters, accessed from the X-bus (F-level). Direct addressing works only on the lowest sixteen locations of the SRF, using four bits in the destination or A-operand field. The RFA registers also have the ability to be preloaded at the start of a macroinstruction.

## 8.10.1 Direct Addressing of the SRF

When using the direct addressing technique, the lower four bits of the A-operand/destination field are routed through the MIC and used as address bits 0-3 to the SRF. Address bits 4-11 are zero. With this method, it is possible to reach the lowest sixteen locations of the SRF without having to use the RFA registers.

## 8.10.2 Indirect Addressing of the SRF

The general method of addressing the SRF is through the register file address registers (RFA1 and RFA2). To use the contents of one of these registers as address to the SRF, the register must be specified in the A-operand/destination field. It is also possible to have the RFA register decremented automatically at the end of the read/write cycle.

## 8.10.3 Loading the RFA Registers

An RFA register is addressed as a source/destination on the X-bus. Loading new contents is done by specifying the register in the destination field of the microword, and putting the new value in the twelve least significant bits of the argument field.

Reading one of the registers is done in a similar way, by addressing it in the A-operand field and reading the twelve least significant bits of the X-bus.

Norsk Data ND-05.020.1 EN

---

## Page 236

# 8.10.4 Presetting the RFA Registers

A method of presetting the RFA registers on the start of a macroinstruction is supported by the MIC. All bits in the registers are then set to '1', except for bits 1 and 2 which are set to the value of the signals RIN(1-0) for RFA1 and RADC(0-1) for RFA2. Enabling of such a presetting is done by the signals EPRF1 and EPRF2 (Enable preset RFn). The master clock clocks the registers.

|        | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|--------|----|----|---|---|---|---|---|---|---|---|---|---|
| **RF1**| 1  | 1  | 1 | 1 | 1 | 1 | 1 | 1 | 1 | X | X | 1 |
|        |    |    |   |   |   |   |   |   |   |   |   | + EPRF1 |
|        |    |    |   |   |   |   |   |   |   |   | L | RIN(0) |
|        |    |    |   |   |   |   |   |   |   |   | L | RIN(1) |

|        | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|--------|----|----|---|---|---|---|---|---|---|---|---|---|
| **RF2**| 1  | 1  | 1 | 1 | 1 | 1 | 1 | 1 | 1 | X | X | 1 |
|        |    |    |   |   |   |   |   |   |   |   |   | + EPRF2 |
|        |    |    |   |   |   |   |   |   |   |   | L | RADC(0) |
|        |    |    |   |   |   |   |   |   |   |   | L | RADC(1) |

*Figure 46. Presetting of the RFA registers*

# 8.10.5 The Signals RF1M8/RF2M8

The signals RF1M8 and RF2M8 are generated by OR'ing together the three least significant bits of the RFA registers. They might be used as test objects during conditional sequence, indicating that the RFA register is a multiple of eight (modulo 8). They are also available as bits in the microstatus register (80H).

Norsk Data ND-05.020.1 EN

---

## Page 237

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.10.6 Example of Read from the SRF

|                 |   |   |   |   |  
|-----------------|---|---|---|---|  
| CSA             | ├ R ┤   |   |   |
| M-level         | ├ R ┤   |   |   |
| A-level         | ├ R ┤   |   |   |
| F (X-bus)       | ├ R ┤ T ├ R ┤   |  
| SRF address     | Ad. |   |   |   |  
| SRF data        | Ḋ  |   |   |   |  

Data valid, RF decremented if specified

Reading means enabling the source out on the X-bus so that data can be accessed by the A-port of the arithmetic logic unit (ALU). The M-level is used as input to the MIC, and this input directly selects either the direct address or one of the RFA registers as address to the SRF. Data must be valid at the start of the A-cycle, and therefore the microcycle may have to be stretched.

## 8.10.7 Example of Write to SRF

|                 |   |   |   |   |  
|-----------------|---|---|---|---|  
| CSA             | ├ W ┤   |   |   |
| M-level         | ├ W ┤   |   |   |
| A-level         | ├ W ┤   |   |   |
| F (X-bus)       | ├ W ┤ T ├ W ┤   |  
| SRF address     | Ad. |   |   |   |  
| SRF data        | Ḋ  |   |   |   |  

Data is written into SRF, and RF is decremented if specified

During a write to the SRF or to one of the internal registers in the MIC, the M-level is pipelined twice before it is used to select the destination register. When writing to SRF, either an RFA register or the direct address is selected as address to the SRF. At the start of the F-cycle, this address is enabled out of the MIC. At the end of the same cycle, data is stored.

Writing new contents into one of MIC’s internal registers is very similar to writing to SRF, but in this case data on the X-bus is written into the register and not to the SRF.

Norsk Data ND-05.020.1 EN

---

## Page 238

# 8.10.8 Restrictions in Use of the MIC as A-operand/Destination

There are some restrictions in the use of the SRF that you, as a microprogrammer, must keep in mind. The same restrictions apply to any use of the MIC as A-operand/destination on the X-bus. Consecutive reads and consecutive writes work well, but when mixing read and write, great care must be taken, since there is no hardware to detect illegal operations.

The most important rules are:

- After a write to the SRF, there must be two dummy cycles until the same data can be read from the SRF.

- Doing a SRF-read in the first cycle after a SRF-write, gives old data as result.

- Reading the SRF in the second cycle after a SRF-write, gives collision on the X-bus, while in the third cycle, new updated data is read from the SRF. The following example gives collision on the X-bus.

| Instruction | Action |
|-------------|--------|
| D,RFA1 NEXT*; | Write to RFA1 |
| NEXT*; | Dummy cycle |
| A,RFA1 NEXT*; | Read from RFA1 * gives collision * |

- If a write SRF with decrement is immediately followed by a read SRF with decrement, the read is executed first. The register is decremented, and in the next cycle the write is carried out. Then the RFA register is decremented once more.

Norsk Data ND-05.020.1 EN

---

## Page 239

# Chapter 8 THE MICROINSTRUCTION CONTROLLER (MIC)

## 8.11 Microprogramming Considerations

In order to make the microinstruction controller as efficient as possible, and to avoid special problems arising from its pipelined nature, you, as a microprogrammer, must be aware of the way the sequencer works and follow some simple rules.

## 8.11.1 Sequence Instructions

- The instruction in the TRUE field is the *main instruction*, while the instruction in the FALSE field is the *alternative instruction*. According to this, the TRUE sequence is used in unconditional sequence and also as preliminary route during conditional sequence.

- JUMP instructions use one clock cycle – while other instructions use two clock cycles. According to this, you should use JUMP instead of NEXT instructions. During conditional sequence, it pays off to put a JUMP in the TRUE field, if possible.

- When doing conditional sequence, it is possible to force a specific preliminary route by matching the TRUE and FALSE fields with the inverted sequence bit.

- A test at the end of a microroutine executing a macroinstruction must follow these rules:
  1. The error action must be held in the FALSE field. This can be arranged by the inverted sequence bit.
  2. The TRUE field should contain a JUMP.

- Since the sequence control and the stack control are separated, the RETURN instruction does not POP the stack. It just uses the top of stack as next address to the control store.

- Instructions generating a hardware branch must have a JUMP address pointing to the immediate following instruction.

Norsk Data ND-05.020.1 EN

---

## Page 240

# 8.11.2 Stack Instructions

The stack control is separated from the sequence control. During conditional sequence, this control is pipelined, and therefore you must be very careful when doing stack operations in connection with a conditional sequence and EXUC (execute unconditional).

- Unconditional stack control is direct from the M-level, while conditional control is pipelined one stage. This causes collision on the stack if a conditional instruction is immediately followed by an unconditional instruction containing a stack instruction. In this case, the stack control from the last instruction loses.

- The first instruction of a subroutine must not be a conditional stack operation different from HOLD. This also applies to one-instruction subroutines.

- A one-instruction subroutine should not be called (JUMP & PUSH) conditionally.

# 8.11.3 Accessing the MIC as A-Operand/Destination

Reading from MIC/SRF is direct, while writing is pipelined two levels. After a write, there must be two dummy cycles before the same data can be read back. Reading in the first cycle gives old data, and reading in the second results in a collision on the X-bus.

Norsk Data ND-05.020.1 EN

---

## Page 241

# Chapter 9: Arithmetic Logic Unit and Working Register File

Norsk Data ND-05.020.1 EN

---

## Page 242

I'm unable to extract any text from this image as it appears to be blank. If there's text, try adjusting the contrast or resolution and rescan.

---

## Page 243

# Chapter 9  ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

## 9.1 Introduction

The task of the baby card Arithmetic Logic Unit and Working Register File (ALU/WRF) is, naturally, to do arithmetic and logic operations. The available operations are described on page 234.

The arithmetic logic unit (ALU) has two input registers (A and B) that hold the input values for an ALU function. The result of the function is available in the F-register, that drives the result bus (F-bus).

The main parts of the CPU registers are situated in the working register file (WRF) gate arrays, but a few registers are also situated in the ALU gate array. The WRF consists of two equal gate arrays, each containing 16 bits. The registers in the WRF have two read ports and one write port, so that two registers can be read and one register written at the same time.

The register block in the ND-5000 CPU consists of a three-level hierarchy of registers:

|        |                                         |
|--------|-----------------------------------------|
| LEVEL 1| The 32-bit Q-register                   |
| LEVEL 2| The working register file (WRF) with 24 |
|        | 32-bit registers                        |
| LEVEL 3| The scratch register file (SRF) with 4K |
|        | 32-bit registers                        |

*Figure 47. Register-block Hierarchy of the ND-5000 CPU*

The ALU/WRF baby card also contains some parts that logically belong to the DAC gate array. These parts are the scaling of the X-registers and the four byte-wide index counters.

The block diagram in figure 48 gives a simplified description of the three gate arrays working as one functional unit.

Norsk Data ND-05.020.1 EN

---

## Page 244

# Chapter 9 ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

## Working register file gate arrays

| Component                       | Description                       |
|---------------------------------|-----------------------------------|
| Loop counter (LC)               |                                   |
| Index counters (IXC)            |                                   |
| Working register file (WRF)     | (24 registers)                    |
| Scaled X-register (SKAL)        |                                   |
| Bit mask generator (BMG)        |                                   |

- Multiplexer M7
- Multiplexer M6
- A-operand to DAC
- A-operand from external source

## The ALU gate array

| Component                       | Description                       |
|---------------------------------|-----------------------------------|
| Pipeline reg. B (PRB)           |                                   |
| Pipeline reg. A (PRA)           |                                   |
| Q-BCD                           |                                   |
| Q-register                      |                                   |
| Result Buss (F-bus)             |                                   |

- Multiplexer M10
- Multiplexer M9
- Multiplexer M8
- TRAP
- Status (STS)

### ALU

| B-operand | A-operand            |
|-----------|----------------------|
|           | ALU status functions |

- Multiplexer M11
- Test Object
  - Loop Counter Zero
  - External Test Obj.
  - Current Test Obj.
  - TRUE
  - FALSE

### Additional Elements

- Pipeline Register
- Shift
- Result (F)
- FS (Function select)
- FSH (F-shift control)

*Figure 48. Block Diagram for the ALU/WRF Baby Cards*

Norsk Data ND-05.020.1 EN

---

## Page 245

# Chapter 9 ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

The ALU A-operand can be selected from among seven different sources. These sources are:

1. One of the 24 WRF-registers
2. The bit mask generator (BMG)
3. The Q-register
4. An external source, for example a register in SRF
5. The part of the status register, STS, which resides inside the ALU
6. The part of the trap enable register, TREG, which resides inside the ALU (inside the box marked TRAP in figure 48)
7. The F-bus

In a similar way, the B-operand can be selected from among six different sources:

1. One of the 24 WRF-registers
2. The F-bus
3. A 16-bit loop counter (LC)
4. The four index counters (IXC)
5. The Q-register
6. Q-BCD, which is a special function (Q/4 or Q/8) used in BCD arithmetic

The tristate bus AOP is used either to pass an A-operand to the ALU or to pass a scaled X-register (SKAL) to the DAC gate array.

The ALU can do 12 different operations on data of the following word lengths:

- Word (W)
- Halfword (HW)
- Byte (B)

The result (F) can be shifted in three different modes, or remain unchanged when passed onto the F-bus. The microword which controls these operations contains two operation codes, marked TRUE and FALSE in figure 48. The choice between these two codes can be conditional or not. If unconditional, TRUE is always used. If conditional, the choice depends on the value of a selected test object. If the value is zero, FALSE is chosen, otherwise TRUE. 39 different test objects can be selected, 19 of them are generated on either the ALU or the WRF gate array. The remaining test objects are generated elsewhere and multiplexed onto the signal EXTT.

Norsk Data ND-05.020.1 EN

---

## Page 246

# 9.2 The ALU and Pipelining

The WRF gate array is active at all pipeline levels, while the ALU gate array does no operations at I-level.

## I-level

At the I-level, the control signals for the following operations are selected either from the microcode or the OR-logic:

- Selection of ALU A and B-operand sources
- Transfer of scaled X-register to DAC

The selected control signals are pipelined into the M-level. In this way, the control signals are valid early in the M-cycle, which is necessary since they are parts of critical data paths.

## M-level

At the M-level, the A and B operands are fetched from the WRF, or one of the other possible sources, and passed to the inputs of the pipeline registers PRA and PRB. When the A-operand is fetched from the data cache or data memory, it may take two cycles to align the bytes of the operand and clock them into the PRA register. For that reason, each byte of PRA (see figure 48) is enabled separately by the signals ECPAN(0-3) (ECPAN = enable clock pipeline register A-operand).

In the ALU gate array, the microcode fields used (from MIR) are decoded (in some cases) and pipelined into the A-level.

## A-level

The ALU operations, the Q-register operations and decrementing the LC are done at the A-level. During conditional ALU operations, and probably during arithmetic ALU-operations, the A-cycle must be a slow cycle due to long data paths.

## F-level

At the start of an F-cycle, the results from the A-cycle are clocked into different registers. The F-bus is loaded either with the pipelined ALU result or from the AAP. From the F-bus, a register in the WRF or the LC can be loaded. Further, the index counters are cleared during this cycle.

In the following, signals which are pipelined into succeeding levels are given prefixes: PM, PA or PF.

Norsk Data ND-05.020.1 EN

---

## Page 247

# Chapter 9: ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

## 9.3 Selection of A-operand to ALU, and X-register to DAC

This selection is controlled by logic in the WRF gate arrays. An ALU A-operand can be selected from:

1. A source in the ALU gate array, for example the Q-register.

2. From one of several sources in the WRF gate array.

3. From other sources on the ND-5000 CPU (in the following called external source), for example the data cache.

In the last two cases the selected source puts its value on the external bus AOP.

When the A-operand is accessed from the data cache (or memory) by an indexed address mode, it takes at least three master cycles to fetch it. In the first master cycle, the selected X-register is scaled and sent to DAC on the AOP-bus. In the second cycle, DAC is calculating the effective address. In the third cycle, the data is fetched from the data cache (if cache hit on the calculated address).

Norsk Data ND-05.020.1 EN

---

## Page 248

# 9.4 ALU Operations

The ALU is able to do 12 operations. The microword contains two alternative ALU operation codes. Which one is to be used is controlled by the bit COND.A.ALU in the microword. This bit controls whether or not the selection shall be conditional. If conditional, the selection depends on the value of a selected test object.

Before the result is placed on the result bus (F-bus), the result (F) of an operation passes a shift multiplexer. The ALU operations and the shift operations are listed in table 31.

| TALU OR FALU | OPERATION | COMMENTS |
|---|-----------|-----------|
| 0 0 0 0 | ZERO | |
| 0 0 0 1 | ADIRC | F = A inverted |
| 0 0 1 0 | AND | |
| 0 0 1 1 | ANDCB | AND with B inverted |
| 0 1 0 0 | A + 0 | |
| 0 1 0 1 | XOR | |
| 0 1 1 0 | ANDCA | AND with A inverted |
| 0 1 1 1 | OR | |
| 1 0 0 0 | DECA | F = A decremented |
| 1 0 0 1 | A F/2 | F = A, F-bus = F/2 |
| 1 0 1 0 | A - B | |
| 1 0 1 1 | A - B F*2 | F-bus = F*2 |
| 1 1 0 0 | A + B F/2 | F-bus = F/2 |
| 1 1 0 1 | A + B | |
| 1 1 1 0 | B - A | |
| 1 1 1 1 | A + B F*2 | F-bus = F*2 |

TALU = true ALU  
FALU = false ALU  

*Table 31. ALU Operations*

One shift operation, not listed in table 31, is selected by setting the microword bit FLSH to '1'. In this operation, bits 30 to 22 of the result are shifted into bits 8 to 0 of the F-bus. The remaining bits are set to zero. This shift operation is used to speed up operations on exponents in floating-point arithmetic.

When STS or TREG is selected as A-operand, the multiplexer M8 introduces an extra delay compared to other A-operand sources.

The ALU gate array is implemented as a two-level carry-look-ahead adder complemented with the necessary logic. The basic configuration is illustrated in figure 49.

---

## Page 249

# Chapter 9 ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

## Block Diagram of the ALU Gate Array

### Figure 49. Block Diagram of the ALU Gate Array

```
                B                 A
                ↓                 ↓
          +--------------+ +--------------+
          |  B-select    | |  A-select    |
          +--------------+ +--------------+
                ↓                 →
          (FS=function          FS1 (FS4)
           select)                 ↓
                ↓                  ↓
          +------------------------------+
          |        Adder part 1          |
          |         AND OR XOR           |
          +------------------------------+
                ↓  ↓  ↓  ↓          →
                 ZERO               CLA 
                                      (carry look
                                       ahead)
                 ↓                    FS0
+----------------------------------------------+
|           Multiplexer            4:1         |
+----------------------------------------------+
                 ↓                 →
                 Carry      +-----------------+
               FS(7-8)     |   Adder part 2   |
                           |        SUM       |
                           +-----------------+
                                       ↓
                                   Result (F)
```

### The microword fields cannot be used for direct ALU control. This control is carried out by the signals marked FS(0-10) and FSH(0-1) in figures 48 and 49:

- **FS0** is carry into the adder.
- **FS1** selects whether or not the A-operand input should be inverted.
- **FS(2-3)** selects whether or not the B-operand input should be inverted. Further, it is possible to force the B-operand into the adder to 0 or FFFFFFFF (hex)g. This possibility is used in the operations A - 1 and A + 0.
- **FS4** is identical to FS1, and FS(5-6) is identical to FS(2-3). These signals are introduced due to high load and speed considerations.

---

Norsk Data ND-05.020.1 EN

---

## Page 250

# Chapter 9 ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

- FS(7-8) selects between the boolean operations AND, OR, EXOR and ZERO.

- FS(9-10) selects between arithmetic operations and others. The results of the boolean operations are generated in the adder much earlier than the results of the arithmetic operations (S). For that reason, the multiplexing is divided into two levels to avoid unnecessary delay of arithmetic values.

The width of the ALU result is controlled by OR-logic, ORT(0-2), if the the field TYPE(0-2) in the microcode is equal to 111, otherwise by the field TYPE itself. The selected field is decoded to a two bit field TC(0-1). TC = 00 selects word, TC = 10 selects halfword and TC = 11 selects byte.

| OR-logic controlled type (ORT) | Type code (TC) |
| ------------------------------ | -------------- |
| Halfword                       | 10             |
| Byte                           | 11             |
| Bit                            | 11             |
| All other                      | 00             |

*Table 32. ALU Width Selection by the Type Code (TC)*

---

## Page 251

# Chapter 9 ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

## 9.5 ALU Internal Status Bits

The ALU has four internal status bits:

| Status | |
|--------|--------|
| Carry  | (MCRY) |
| Sign   | (MSGN) |
| Overflow | (MOVFL) |
| Zero    | (MZRO) |

- Carry is equal to carry from the most significant bit (MSB) of the adder.
- Sign is equal to the MSB of the result.
- Overflow is equal to the boolean function EXCLUSIVE OR operating on carry into and carry out from the MSB of the adder.
- ZERO is a detection of result = 0.

Depending on word length, MSB is equal to bit 31, bit 15 or bit 7. The carry and overflow flags must be set to 0 when a boolean operation is done. The zero status bit might be generated by comparing all bits of the result (32, 16, or 8 bits) with 0. This, however, adds a propagation delay of the order of 10 ns in the most critical data path (critical regarding propagation delay).

The carry, sign, overflow and zero status bits are stored in the macro status register at the end of each macroinstruction (see page 72).

## 9.6 Trap Enable Register

The macro status bits OW, INR, IVO, DZ, FU, FO, BO and DR (see page 72) are coupled by OR-logic to cause a trap signal (active low). Whether or not a status bit shall be able to set the trap signal, is controlled by a trap enable register, which is loaded from F-bits 9 to 15 and F-bit 25.

## 9.7 Selection of Test Object

Several different signals can be selected as test object. These signals are listed in the microcode field TEST OBJECT. Those test objects with the MSB of the mentioned microcode field equal to 0 are generated in the ALU gate array, except that of loop counter.

Norsk Data ND-05.020.1 EN

---

## Page 252

# Chapter 9 ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

zero (LCZ). LCZ is generated by the loop counter in the WRF gate array. The remaining test objects are generated elsewhere and multiplexed into the signal EXTT (external test object). Parity of the least significant byte of the ALU result means odd parity.

The selected test object is valid early in the ALU cycle of the actual instruction and the length of this cycle will be stretched.

## 9.8 The Q-Register

The Q-register can be loaded from the F-bus and do shift operations on operands of different lengths: Word, halfword and byte. These operations are controlled by bits 111 to 113 of the microword and by type code (TC).

| MICROCODE | WORD (TC=0)  | HALFWORD (TC=10) | BYTE (TC=11)   |
|-----------|--------------|------------------|----------------|
| 0 0 0     | Q=Q          | Q=Q              | Q=Q            |
| 0 0 1     | Q=F          | Q=F              | Q=F            |
| 0 1 0     | Q=2*Q, Q0=DIVR | X              | X              |
| 0 1 1     | Q=2*Q, Q0=0  | Q=2*Q, Q0=0      | Q=2*Q, Q0=0    |
| 1 0 0     | Q=Q/2, Q31=Q31 | Q=Q/2, Q15=Q15 | Q=Q/2, Q7=Q7   |
| 1 0 1     | Q=Q/2, Q31=** | Q=Q/2, Q15=0    | Q=Q/2, Q7=0    |
| 1 1 0     | Q=Q/2, Q31=Q0 | Q=Q/2, Q15=Q0   | Q=Q/2, Q7=Q0   |
| 1 1 1     | Q=2*Q, Q0=Q31 | Q=2*Q, Q0=Q15   | Q=2*Q, Q0=Q7   |

*Table 33. Operations on the Q-register*

DIVR = M31*MCRY + M31*Q0 + MCRY*Q0 where:

- M31 is MSB of F latched into a 1-bit register
- MCRY is ALU carry
- * stands for the boolean operation AND
- + stands for the boolean operation OR
- ** = F(0) if the result (F) is shifted to the right onto F-bus, else ** = 0.

Norsk Data ND-05.020.1 EN

---

## Page 253

# 9.9 The Working Register File (WRF)

The working register file contains 24 32-bit registers. These registers are grouped as follows:

| Address | Name    | Function                                             |
|---------|---------|------------------------------------------------------|
| 0 - 3   | X1-X4   | Index registers                                      |
| 4 - 7   | A1-A4   | Arithmetic registers                                 |
| 8 - 11  | SC1-SC4 | Scratch registers                                    |
| 12-15   | E1-E4   | Extension registers for double-floating operations  |
| 16-23   | SC5-SC12| Scratch registers                                    |

*Table 34. Groups of Working Register File Registers*

Logically, the WRF behaves in the following way: Any register can be read and written into during the same clock cycle. The A and B operands can be read from the same register during the same cycle. Due to the pipelining, the real implementation is a bit more complicated. This is illustrated in the timing diagram shown in figure 50. Note that the ALU operands are fetched during the M-cycle.

```
F-bus← A1  A1← ALU  A1← ALU
M-level  ├───────┼───────┼───────┤
            N    N+1    N+2
A-level    ├───────┼───────┼───────┤
            N     N+1    N+2
F-level     ├───────┼───────┼───────┤
              N     N+1    N+2
A1 valid     └─────┘
```

*Figure 50. Timing Diagram Real Implementation*

In microinstruction N+1, the value of A1 must be taken directly from the internal F-bus on the ALU gate array. In microinstruction N+2, the value of A1 is valid in the register too late in the cycle. For that reason, F-bus (in the WRF gate array) is passed directly to multiplexer M6 or M7.

Norsk Data ND-05.020.1 EN

---

## Page 254

# 9.10 WRF Position Bit

As mentioned, two equal WRF chips are used; one for the 16 most significant bits and one for the 16 least significant bits. A bit called POS is introduced to tell each chip which position it occupies:

| POS | |
|---|---|
| 0 | 16 least significant bits |
| 1 | 16 most significant bits |

# 9.11 Scaling of X-register

Scaling of X-register: In indexed address modes, the selected X-register is scaled a factor p before it is used in the address calculation. The possible values of p are:

- 1/8
- 1 (X direct)
- 2
- 4
- 8
- 16

The value of p is defined by the control signals SCAX(2:0) (SCAX = control of scaling of X-register). SCAX is generated externally on a PAL. SCAX is coded in the following way:

| SCAX(0-2) | SCAX(0-2) | value of p |
|---|---|---|
| 111 | 000 | x2 |
| 110 | 001 | x4 |
| 101 | 010 | x8 |
| 100 | 011 | x16 |
| 011 | 100 | direct |
| 010 | 101 | x 1/8 |

Since the WRF gate array is a 16-bit slice, the four MSBs and the three LSBs must be presented as outputs, and in addition a corresponding set of inputs is needed.

Norsk Data ND-05.020.1 EN

---

## Page 255

# Chapter 9 ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

- The outputs are called XSEN(0-2, 12-15) (XSEN = selected X-register) and the inputs XSEXN(0-2, 12-15) (XSEXN = selected X-register external).

- XSEN(12-15) of the chip in position 0 is connected to XSEXN(12-15) of the chip in position 1.

- XSEN(0-2) of the chip in position 1 is connected to XSEXN(0-2) of the chip in position 0.

When p is larger than unity, zero is shifted into the LSBs. This is done by connecting XSEXN(12-15) of the chip in position 0 to ground. When p = 1/8, the three MSBs shall be loaded with bit 31 of the selected X-register. This is done by connecting XSEN31 of the chip in position 1 with XSEXN(0-2) of the same chip.

---

## 9.12 Scaling Error Bit

When p > 1, the outshifted bit(s) must all have the same value. This value must be equal to the value shifted into bit 31. Otherwise, scaling error must be flagged by the scaling error bit SCAEN (scaling error). SCAEN is clocked every master cycle into a register. To prevent it from incorrect flagging, the register is reset to 1 by ECMIRN (enable clock microinstruction register). When SCAEN goes low, a feedback loop keeps SCAEN low until next ECMIRN. To prevent SCAEN from locking on, an invalid X-register value XWAITN (X-register wait) keeps SCAEN reset until the X-register contents are valid.

During descriptor branching, ECMIRN must be prevented from clearing an eventual scaling error. This is done by gating ECMIRN with the signal DESCBN (descriptor branch).

---

## 9.13 Bit Mask Generator

The bit mask generator sets one bit out of 32 equal to '1', and all others to '0'. The bit to be set is addressed by a 5-bit field. This field can be chosen from three different sources:

1. The microcode AOPR(0-4)

2. The least significant bits of the loop counter

3. PABABM (A-level bit-address bit-mask pipelined)

Which source is to be selected is determined by A-operand(5-7) and PMAA(0-4) (M-level A-operand selection).

Norsk Data ND-05.020.1 EN

---

## Page 256

# ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

PABABM is used to address a bit in a memory location. The byte containing the bit is read into the least significant byte of a WRF register, and in the next microinstruction the bit is selected using BMG (set by PABABM) as a pointer. PABABM is loaded only when ADACT = 1 and the last preceding microinstruction is not a return from a descriptor hardware branch. BABM is zero, except when the address mode is indexed with scaling factor p = 1/8. In that case BABM is equal to the inverted value of the three least significant bits of the selected X-register (XSEN(0-2)). This selection is controlled by:

- SCBMN = SCAX2' * SCAX1' * SCAX0' * PMSEXC

---

## 9.14 Loop Counter

```
            +----------------------------------+
            |                                  |
            |            MUX                   |
            |          +------+                |
            |          |      |                |
            +-------+  |  0 QN|                |
PALCD ---> | Pass or | |  1 S |                |<--- LC
          | decrement | +------+               |
            +---------+   |                    |
                          +--------------------+
                          |          | REG     |
                          |          |+------+ |  ECLC*MACKA
                     +----+          | |      | |
                     |               +-+ D  Q | |
                     |                +------++ |
                     |                 |    |   |  PFLDLC
                  +--+                 |    |   +--> F-bus
                  |                    |    +-------+
                  |                    |    |  REG  |
             F-bus--->             Zero?   |+------+|
                                           ||      ||
                            ECFN          ++ D  Q +-|--> PFLCZ
                             |              +----+-+
                             |                   |
                             +-------------------+
                             |                   |
                          +--+--+                |
                          | REG |                |
                          +-----+ MACAK          |
                                                  +
                                         PFLDLC = F-level load loop counter
                                         PALCD = A-level loop counter decrement
                                         PFLCZ = F-level loop counter zero
```

*Figure 51. The Loop Counter*

The loop counter is shown in figure 51. (The pipelining of LCZ into PFLCZ is carried out as part of the selection of test object on the ALU-gate array.) Observe that when LC is loaded from the F-bus, the value is clocked into the register at the end of the F-cycle, due to the delay on the F-bus. A decremented value, on the other hand, is clocked in at the beginning of an F-cycle.

Norsk Data ND-05.020.1 EN

---

## Page 257

# Chapter 9 ARITHMETIC LOGIC UNIT AND WORKING REGISTER FILE

## 9.15 The Index Counters

A byte-wide index counter (IXC1-IXC4) belongs to each X-register. These counters are used in connection with descriptor addressing. If an instruction with this addressing mode is stopped and restarted, the contents of these counters are used to reset the X-registers to their starting values. Incrementing of the counters is controlled by the microcode bit IXC1. Which counter to be incremented is given by DEST(0-1) or ORD(0-1). When selected as B-operand, the four counters are placed on the B-operand bus in the following order:

| MSB | LSB |
|-----|-----|
| IXC4 | IXC3 IXC2 IXC1 |

All four counters are cleared at the same time. Clear is either controlled by microcode or by a direct clear signal IXCLR. Both clear and increment are done in the F-cycle.

Norsk Data ND-05.020.1 EN

---

## Page 258

# EMERGENCY PROCEDURES

## Introduction

This chapter is a description of ND-500/ND-5000 system routines and operator procedures and routines to handle emergency situations. These situations may occur as a result of hardware or software faults, human errors and external impulses.

## Suggested Reader

This chapter is mainly directed towards the operator of the system who has some knowledge of ND-5000 hardware.

## Summary

This chapter consists of four sections:
- **Terminal Distribution System (TDS) Faults**: describes some actions to be taken in case of TDS faults.
- **Operator Errors**: describes operator errors and how to handle such errors.
- **System Log Errors**: describes the most important log errors found in NORD-5000 computers. They first part is a brief introduction to log errors and log routines. The second part is a list of important log errors.
- **Emergency Stops**: describes emergency stop situations in ND-500 and ND-5000 systems. Procedures for restarting the systems are also given.

| Emergency Situations | Procedures |
|----------------------|------------|
| Hardware Faults      | See relevant chapter in ND-500/ND-5000 manuals |
| Software Faults      | Reboot system using System Console |
| Human Errors         | Follow operator guidelines |
| External Impulses    | Report to system administrator |

Recommendations for using ND-500/ND-5000 system commands can be found in the **System Reference Manual**.

### Important Notes

- All operators should familiarize themselves with the emergency procedures.
- Keep a copy of the emergency procedures accessible at all times.
- Regularly review and practice these procedures to ensure prompt action during an emergency.

For further assistance or clarifications, contact your system administrator or refer to the Norsk Data Technical Support.

---

## Page 259

# Chapter 10 Additional Arithmetic Processor (AAP)

Norsk Data ND-05.020.1 EN

---

## Page 260

I'm unable to provide the content of the document as it appears to be an empty page except for a page number and a footer. If you have another image or page, feel free to share it!

---

## Page 261

# Chapter 10 ADDITIONAL ARITHMETIC PROCESSOR (AAP)

## 10.1 The ND-5000 AAP Concept

```
The AAP baby
card is placed
in the 2nd layer
of baby cards —

     AAP  ┌──────────┐
          │  AAP     │
          ├──────────┤
          │  MMS     │
          │          │
 CS       ├──────────┤
 ┌─┐      │          │
 │ │      │          │
 └─┘      ├──────────┤
          │  IDA     │
          ├──────────┤
          │  ACCP    │
          │          │
          │          │
          └──┬───────┘
msc       MIC
└─┘
Mother board
1. layer of
baby cards
(ALU, cache)

```

*Figure 52. Physical Location of the AAP Baby Card*

The Additional Arithmetic Processor (AAP) on the ND-5000 makes it possible to implement different arithmetical functions in hardware in order to enhance the arithmetical performance. To allow for as many operations as possible, the individual function call is done on a rather high level (SIN, SQRT etc.). A standard interface to the ND-5000 ', and the autonomous behaviour of each AAP, make it theoretically possible to connect one AAP for each operation type.

The AAP remains silent until it recognizes an operation that it is able to execute. The operation code will occur in the middle of the M-cycle. At the start of the A-cycle, the AAP reads data, starts the computing and sends a busy signal to the CPU. From now on the CPU has the control, and has the theoretical possibility to execute any number of microinstructions. Normally, however, the CPU will issue an AAP synchronization signal and stop, waiting for the AAP busy signal to stop. When the busy signal is turned off (high), the AAP is ready to present data on the F-bus.

Norsk Data ND-05.020.1 EN

---

## Page 262

# Chapter 10 ADDITIONAL ARITHMETIC PROCESSOR (AAP)

As soon as the AAP synchronization signal goes high. When the AAP result presentation has started, the CPU must read all the data presented, one word in each F-cycle.

## 10.2 AAP Control Fields

Because of the relatively narrow space in the ND-5000 microword (eight bits), the AAP functions are divided into eight groups which share the same 5-bit AAP control area. The groups, that normally represent physical AAPs, are controlled by the 3-bit AAP-type area.

The eight bits 110-103 are reserved for AAP control in the ND-5000 microword (see page 329 for a detailed description of the microword). The interpretation of the type field is as shown in Table 35.

|     |                               |
|-----|-------------------------------|
| 000 | No AAP                        |
| 001 | ND-570 Floating Point Unit    |
| 010 | ND64/65 NMOS version          |

*Table 35. AAP Type (Microword Bits 110-108)*

Norsk Data ND-05.020.1 EN

---

## Page 263

# Chapter 11 ND-5000 Nanostates Descriptions

Norsk Data ND-05.020.1 EN

---

## Page 264

I'm sorry, I can't complete this task as the image provided does not contain clear or legible text.

---

## Page 265

# Chapter 11 ND-5000 Nanostates Descriptions

The ND-5000 CPU has seven nanostate sequencers, which mostly consist of PALs (programmable array logic):

1. The Microinstruction Controller (MIC) nanostate sequencer
2. The Instruction Decode Unit (IDU) nanostate sequencer
3. The Data Address Controller (DAC) nanostate sequencer
4. The Data Cache Controller (DCC) nanostate sequencer
5. The Instruction Memory Management (IMM) nanostate sequencer
6. The Data Memory Management (DMM) nanostate sequencer
7. The MFbus Channel Controller (MFBCC)

| Task | 
|------|
| The task of the nanostate sequencers is to control how many nanocycles each microinstruction needs. |

| Cycle length |
|--------------|
| The nanocycle is the basic clock cycle in the ND-5000 CPU. It is usually 70 ns long, but it can be stretched to 113 ns, or even 156 ns if extra long cycles are needed. The nanocycle length is normally determined by hardware, but can also be specified from the microprogram. |

Norsk Data ND-05.020.1 EN

---

## Page 266

# Chapter 11 ND-5000 Nanostates Descriptions

## 11.1 The MIC Nanostates

| State  | Description |
|--------|-------------|
| FIRSTA | 1           |
| WECA   | 0           |

### Sequence and Execution
- A-CSEQ
- BREAK
- A-NOJMP
- A-EXUC
- M-EXUC
- M-CSEQ
- M-JUMP
- M-NOJMP

### States Chart
- ECALU
- NJEX (16)
- NJWAIT (13)
- NJMP (14)
- CBW1 (2)
- CBMA1 (3)
- CBA1 (5)
- CBX2 (4)
- CB1 (6)
- CB2 (15)
- WIDCAN (7)
- HWB (12)
- DACW
- EDSB (11)
- ECMB (10)
- ENOOP (8)
- TRAP (9)

*Figure 53. State Chart for the MIC Nanostates*

Norsk Data ND-05.020.1 EN

---

## Page 267

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## EXPLANATION OF THE MIC NANOSTATES:

| MIC State | Description |
|-----------|-------------|
| **MIC State 0:**<br>WECA | State 0, WECA, Wait for ECALU, waits for a transition from M-level to A-level. The MIC is not doing anything while in this state. |
| **MIC State 1:**<br>FIRSTA | State 1, FIRSTA, the first MIC state after a clocking of A-level. <br><br> If the MIC should perform the sequencing from one micro-instruction to the next (and not the JUMP-address field in the microword or macroprogram sequencing), the MIC is ready to drive the CSA-bus in the next cycle. When such MIC-driven CSA-cycles occur, the pipelining of microinstructions has holes. These holes are filled with useful work if EXUC is present, otherwise the MIC issues synchronizing signals to halt the pipeline (MICW, MICANC). |
| **MIC State 2:**<br>CBW1 | State 2, CBW1, cycle to wait for ECALU before the first _hole_ cycle in a breaking conditional sequence with two EXUCs. |
| **MIC State 3:**<br>CBMA1 | State 3, CBMA1, cycle to execute the first EXUC cycle, and to wait for ECALU before the second _hole_ cycle in a breaking conditional sequence with two EXUCs. |
| **MIC State 4:**<br>CBX2 | State 4, CBX2, the last cycle in a breaking conditional sequence with one or two EXUCs. |
| **MIC State 5:**<br>CBA1 | State 5, CBA1, to wait for ECALU, and to execute the first EXUC cycle in a breaking conditional sequence with one EXUC. |
| **MIC State 6:**<br>CB1 | State 6, CB1, the first cycle in a breaking conditional sequence with no EXUCs. |
| **MIC State 7:**<br>WIDCAN | State 7, WIDCAN, wait while the IDU cancel signal is active. This signal indicates that the IDU is busy, and must stop the pipeline. |
| **MIC State 8:**<br>ENOOP | State 8, ENOOP, enable NOOP hardware branch. This state is entered after the MIC has issued the microaddress 101B onto CSA. Microaddress 101B must contain a NOOP microinstruction. This mechanism is used to obtain a NOOP A-level microinstruction when a TRAP has occurred. All TRAPs must be pipelined down to the F-level before they result in hardware branch. The ENOOP ensures that this can happen without bringing a dangerous micro-instruction down to the A-level. |

Norsk Data ND-05.020.1 EN

---

## Page 268

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## MIC State 9:
**TRAP**  
State 9, TRAP, enable TRAP hardware branch. This state is entered after the MIC has issued the microaddress 100B onto CSA. Microaddress 100B is the start address of the trap routine.

## MIC State 10:
**ECMB**  
State 10, ECMB, enable constant mismatch branch. This state forces the MIC to issue a microaddress between 60B and 77B. These addresses must contain the start points of the constant mismatch routines.

## MIC State 11:
**EDSB**  
State 11, EDSB, enable descriptor branch. This state is entered after the MIC has issued a microaddress between 40B and 57B. These addresses must contain the start points of the descriptor addressing routines.

## MIC State 12:
**HWB**  
State 12, HWB, hardware branch. This state always follows states 8, 9, 10 and 11.

## MIC State 13:
**NJWAIT**  
State 13, NJWAIT. This cycle is necessary only when a *hole* cycle occurs because of a *no jump* sequence operation, and this hole is to be filled because of EXUC. The NJWAIT cycle may then have to wait for ECALU.

## MIC State 14:
**NJMP**  
State 14, NJMP, is the dummy cycle inserted as *hole*, when a *no jump* sequence operation is not to be filled by EXUC.

## MIC State 15:
**CB2**  
State 15, CB2, second cycle when a breaking conditional sequence contains no EXUC cycles.

## MIC State 16:
**NJEX**  
State 16, NJEX, is the filled *hole* of a *no jump* sequence operation with EXUC.

---

Norsk Data ND-05.020.1 EN

---

## Page 269

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## 11.2 The IDU Nanostates

| State | Transition | State |
|-------|------------|-------|
| 0:0   | clear      | 14:0  |
| 13:0  | MGET.ECALU | 9:0   |
| 11:0  | TRAP+MICANC|       |
| 12:0  | BREAK      |       |
| 0:6   | FILLB2     |       |
| 1:0   | PREVBH+BF2 |       |
| 2:0   | G,00PS     |       |
|       | G,OPS      | 2:2   |
|       | G,00PS     | 2:3   |
| 4:0   | G,DIR      |       |
| 5:0   | DIR        |       |
| 7:0   | PREX+G,OPS | 7:2   |
|       |            | 7:3   |
| 3:0   | GENERAL OPERAND |       |
| 3:6   |            | 3:5   |
| 3:2   | TLB2       | 3:3   |
| 6:0   | TLB2       | 6:3   |
| 6:6   | DF CONST   | 6:5   |
| 6:2   | UAB2       |       |
| 8:0   |            |       |
| 8:2   |            |       |
| 8:3   |            |       |

Figure 54. State Chart for the IDU Nanostates

Norsk Data ND-05.020.1 EN

---

## Page 270

# Chapter 11 ND-5000 NANOSTATES DESCRIPTION

## EXPLANATION OF THE IDU NANOSTATES:

### Special signals

The IDU nanostate sequencer uses a number of signals to control its transitions. Two of these signals deserve special comment:

- **TLB2, too little in B2**, is a signal that indicates that the previous (not the current) decoding step needed more bytes than were present in B2.
  
- **UAB2 use all of B2**, is a signal that indicates that the previous (not the current) decoding step used all the bytes in B2.

### IDU State 0:0

State 0 is the state when the IDU is waiting for something to do. The activation signal is a GET command on M-level together with ECALU. State 0 then enters state 13.

### IDU State 0:6

State 0, substate 6, is one of a family of substate 6 states. These substates are only entered when the signal UAB2 (use all of B2) is true. All such substates loop until data is available from the instruction memory channel.

Memory request is already sent by the state that decided to enter substate 6, and the logical address register of the memory management system (MMS-LA) is already filled.

The data received from the IRL (instruction received latch) is clocked into both B1 and B2 in the IDU. Only B2 is set valid.

Substate 6 is never entered if any valid bytes are still left in B2.

### IDU State 1:0

State 1 decodes the INC (instruction code) and the expected ADC (address code of the first operand). State 1 is only entered when TLB2 is present when the IDU activity starts, or when B2 is invalid because cache hit or branch occurred recently. If B2 contains the necessary bytes when the IDU is activated, the tasks of state 1 are already performed by state 13.

State 1 is only entered in case of G,OOPS - G,OOPS,T - G,OOPS,F and G,TOOPS. The INC and ADC are fed out to address the I-MAP and O-MAP respectively.

### IDU State 2:0

State 2 decides whether state 1, state 12 or state 13 had enough data in B2 to perform its functions properly. If not, the substates 2 and 3 are entered to read from instruction memory, and state 1 is executed again.

If the previous state has completed its tasks, state 2 decides if the INC is a no-operand instruction, or if the first operand is of the direct type. Nothing is then decoded by state 2. Otherwise, state 2 calculates the proper ADC, including all prefixes (ALT and/or DESC). The ADC is presented as address to O-MAP.

Norsk Data ND-05.020.1 EN

---

## Page 271

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

When state 2 is finished, the type of GET command is examined. If the G,TOOPS is in effect, the IDU is finished with its decoding activity, nothing is cached in the instruction cache, and state 13 or state 0 is entered.

If the operand is direct, state 5 is entered.

If the ADC calculated in state 2 is the same as the expected ADC calculated in state 1, 12 or 13, state 3 follows state 2. Otherwise, state 7 is inserted between states 2 and 3, to allow time to access the O-MAP.

## IDU State 2:2

State 2, substate 2, is one of a family of substate 2 states. These substates are only entered when the signal TLB2 (too little in B2) is true. The MMS LA-register is filled from the IAC, and a read request is issued to the instruction memory.

There are always some valid bytes left in B2 when substate 2 is entered.

## IDU State 2:3

State 2, substate 3, is one of a family of substate 3 states. All substate 3 states loop until data is available from the instruction memory channel.

Memory request is already sent out by the substate 2 that preceded substate 3.

The data received from the IRL (instruction received latch) is only clocked into the B1 (because B2 still contains valid bytes). Both B1 and B2 are set valid.

## IDU State 3:0

State 3 decides whether state 2 had enough data in B2 to perform its functions properly. If not, the substates 2 and 3 are entered to read from instruction memory, and state 2 is executed again.

State 3 then decides if state 2 used exactly all the bytes present in B2. If that was the case, the substates 5 and 6 are entered to read from instruction memory, and state 3 is executed again.

State 3 decodes the displacement part of a general operand, makes it sign-extended, and outputs it on the DPA-bus. This process discovers constant conversions that need to be performed by the microprogram. These conversions lead to a constant mismatch hardware branch (microaddresses 60B-77B). The displacement is latched in the DPA register in the DAC gate array on the first clock pulse.

If the general operand is a double constant (which has a 64-bit data part), state 6 is entered when state 3 is finished. If not, state 8 is entered.

## IDU State 3:2

State 3, substate 2, see state 2:2.

## IDU State 3:3

State 3, substate 3, see state 2:3.

Norsk Data ND-05.020.1 EN

---

## Page 272

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## IDU State 3:5

State 3, substate 5, is one of a family of substate 5 states. These states are only entered when the signal UAB2 (use all of B2) is true. The MMS-LA-register is filled from the IAC, and a read request is issued to the instruction memory.

There are never any valid bytes left in B2 when substate 5 is entered.

## IDU State 3:6 

State 3, substate 6, see state 0:6.

## IDU State 4:0

State 4 is entered from state 13 or state 0:6 when a G,DIR1, G,DIR2 or G,DIR4 is processed. The proper number of bytes is used, and the result is sign extended. Thereafter, state 8 is entered.

## IDU State 5:0

State 5 is entered from state 2 when the first operand of an instruction is direct. During state 2, only the lookup in I-MAP has taken place. Length information is obtained from the I-MAP, and the proper number of bytes is used. The result is sign extended. This state is followed by state 8.

## IDU State 6:0

State 6 decides whether state 3 had enough data in B2 to perform its functions properly. If not, the substates 2 and 3 are entered to read from instruction memory, and state 3 is executed again.

State 6 then decides if state 3 used exactly all the bytes present in B2. If that was the case, the substates 5 and 6 are entered to read from instruction memory, and state 6 is executed again.

State 6 decodes the second part of a double constant operand and outputs it on the DPA bus.

The IDU enters state 8 when state 6 is finished.

## IDU State 6:2

State 6, substate 2, see state 2:2.

## IDU State 6:3

State 6, substate 3, see state 2:3.

## IDU State 6:5

State 6, substate 5, see state 3:5.

## IDU State 6:6

State 6, substate 6, see state 0:6.

## IDU State 7:0

State 7 decides whether state 2 had enough data in B2 to perform its functions properly. If not, the substates 2 and 3 are entered to read from instruction memory, and state 2 is executed again.

State 7 is introduced as a delay necessary to match the access time of the O-MAP in cases when the expected ADC was wrong. It is also used when only a general operand and no instruction code, is fetched.

The IDU enters state 3 when state 7 is finished.

## IDU State 7:2

State 7, substate 2, see state 2:2.

Norsk Data ND-05.020.1 EN

---

## Page 273

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## IDU State 7:3
State 7, substate 3, see state 2:3.

## IDU State 8:0
State 8 decides whether the previous state (3,4,5 or 8) had enough data in B2 to perform its functions properly. If not, the substates 2 and 3 are entered to read from instruction memory, and the previous state is executed again.

State 8 prepares for the writing of data in the instruction cache. I-MAP and O-MAP output has been ready for a while. The CS-word to be written into CC has been addressed by the entry address from the I-MAP. The NADDR field contents are calculated in the IAC by using the sum of the bytes comprising the decoding steps. The value to be written into the AC (address cache) is calculated by the DAC.

The IDU enters state 15 or 14 when state 8 is finished.

## IDU State 8:2
State 8, substate 2, see state 2:2.

## IDU State 8:3
State 8, substate 3, see state 2:3.

## IDU State 9:0
State 9 is a state following the cache write state (15) when the unpacking of an instruction or operand has been successfully terminated. The next microinstruction to be executed is at the I-level during this state.

If this next microinstruction is controlled by macroprogram sequencing, (a GET is present) the next IDU-state is state 13.

If the next microinstruction is controlled by microprogram sequencing, (no GET is present) the next IDU-state is state 0:0.

## IDU State 11:0
State 11 is entered from state 13 when a conditional branch macroinstruction shall go to a target instruction which is not cached in the NADDR field of the OC. Two extra cycles (states 11 and 12) are then inserted. If the macroinstruction is of the IFGO type in ICHAR in IC, and SIFGOC (smart IFGO cache) is enabled in the modus register, the NADDR field and the NABR field in OC are changed by state 13 when state 11 is entered.

State 11 recreates the I-level of the instruction following the conditional macroinstruction.

The IDU enters state 12 when state 11 is finished.

## IDU State 12:0
State 12 is similar to state 13, except that it cannot enter state 11.

State 12 determines if the instruction following a breaking conditional macroinstruction is found in the instruction cache or not.

## IDU State 13:0
State 13 has control when the next instruction to be executed occupies the M-level. The current instruction, that contains the

Norsk Data ND-05.020.1 EN

---

## Page 274

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

GET that tries to pull up the next instruction, occupies the A-level.

State 13 does not do anything if TRAP or MIC-cancel are present. State 0 is then entered.

State 13 determines if the A-level instruction is a conditional macroinstruction that should break (i.e., go another way than be cached in the NADDR and NABR fields of OC). This can be determined because the test object is ready on F-level from the instruction before the conditional macroinstruction. If break is found, state 11 is entered.

If no break is found, state 13 determines if the M-level microinstruction, read out of the instruction cache system in the previous cycle, is valid. Information about cache HIT is pipelined from the I-level cycle, and tested. In case of HIT, everything is good, and the next IDU state is 0 or 13, testing for the next macroinstruction. In case of MISS, the M-level is invalid, and further pipelining of this invalid microword is avoided. The instruction must be unpacked by the IDU instead.

When unpacking starts, state 13 uses data in B1 and B2 and tries to generate the INC (instruction code) and the expected ADC (address code). (When G,OPS, only ADC is generated, and when G,DIRn, nothing is tried decoded). INC and ADC are fed out to address the I-MAP and O-MAP respectively.

The contents of B2 are invalid if B2 is empty, or the previous macroinstruction jumped, or the previous macroinstruction (or operand) had instruction cache HIT. The next IDU state is then 0:6, and instruction memory read request is sent out. The instruction memory address is already in the LA register of the memory management system. It was captured there when IB-MIB carried the address and the lookup was performed in the instruction cache.

If the contents of B2 are valid, the next state is state 2 in cases of G,OOPS - G,TOOPS - G,OOPST - G,OOPSF and G,COOPS. It is state 4 in the case of G,DIRn. It is state 7 in the case of G,OPS - G,OPSTRD.

| IDU State |  |
|-----------|--|
| 14:0      | State 14 is entered from state 8 when unpacking is finished and the result is about to be written into the instruction cache, and a TRAP condition has been found during the unpacking (illegal codes, instruction memory management traps etc.). The IDU is then locked in state 14 until microcode brings it to state 0: |
| 15:0      | State 15 is active when the result of the IDU activity is written into the instruction cache system. State 15 is the equivalent of state 14 of the original I-level of the unpacked instruction, in case it had been found in the instruction cache. The IDU enters state 9 when state 15 is finished. |

Norsk Data ND-05.020.1 EN

---

## Page 275

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## 11.3 DAC NANOSTATES

| State | Code |
|-------|------|
| WECM  | 0    |
| FIRSTOC | 10   |
| DACTRAP | 4    |
| TRAP   |      |
| +DMMTR |      |
| +ASCAE |      |
| EACQ  |      |
| EAQDSC | 1    |
| EAQXS | 12   |
| DCIND | 11   |
| DLARXS | 15   |
| OPDTOP | 13   |
| DCOPR  | 14   |
| SEDPNPO | 16   |
| DLARO  | 17   |
| FIRSTMI | 2    |
| AAXS  | 3    |
| AADATAX | 5    |
| AADATA | 6    |

*Figure 55. State Chart for the DAC Nanostates*

Norsk Data ND-05.020.1 EN

---

## Page 276

# Explanation of the DAC Nanostates

## X-register

Whenever an X-register is used in calculating addresses, the X-register must be transferred from the WRF to the DAC. This transfer goes along the A-bus, T-bus, and DACOUT bus. When reaching the DAC, the value is saved in a special DAC-register called the DAC-XS. The transferred X-register is scaled according to the type of the addressed operand, or controlled by the microcode scaling field. The scaling takes place within the WRF.

## Final address

The final address of all address calculations is saved in the EAO register in the DAC gate array. In some cases, intermediate addresses are also saved here. When EAO is written, the same contents can be written into one of the other EA registers, controlled by microcode.

## DAC State 0: WECM

State 0, WECM, wait for ECMIR (enable clock MIR), is the idling state of the DAC sequencer. In this state, the DAC internal registers can be read out on the DACOUT bus, and the three special address B-operand codes have effect (11B, 12B, 13B).

## DAC State 1: EAODSC

State 1, EAODSC, EAO output during descriptor addressing, is a special state only used by DESC addressing when the final data element is addressed.

## DAC State 2: FIRSTMI

State 2, FIRSTMI, first microprogram controlled cycle, is entered when the microprogram specifies control of the address arithmetic. This state is entered when ADARC (same as ADARIT, CS bit 40) is true together with ECMIR and ADACT.

FIRSTMI adds together the microprogram specified address A and B-operands, and places the result in EAO (and other EAn registers if specified by EAnSAVE). The result also enters the DAC OUT bus if the bus-controlling hardware so decides.

## DAC State 3: AAXS

State 3, AAXS, microprogrammed direct indexing, performs indexing when multicycle non-indirect microprogramming addressing is specified (AB,Xn and not AA,DATA).

AAXS adds together the microprogram specified address A and B-operands, and places the result in EAO (and other EAn registers if specified by EAnSAVE). The result also enters the DAC OUT bus if the bus-controlling hardware so decides.

The DAC stays in this state until one cycle after the necessary X-register has been transferred from the WRF to the DAC-XS register inside the DAC.

## DAC State 4: DACTRAP

State 4, DACTRAP, trap state for the DAC. The DAC is in this state until released by microprogram. In this state, internal

---

Norsk Data ND–05.020.1 EN

---

## Page 277

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

Registers can be read out on the DACOUT bus to serve as A-operands for the ALU. No addresses can be generated with the DAC in this state.

## DAC State 5: AADATAX

State 5, AADATAX, microprogrammed indirect post-indexing, adds together the indirect address contents and the microprogram specified AB,Xn. This is multicycle indirect post-indexed addressing (AA,DATA and AB,Xn). The result is placed in EAO (and other EAn registers if specified by EAnSAVE). The result also enters the DAC OUT bus if the bus-controlling hardware so decides.

The DAC stays in this state until one cycle after the necessary X-register has been transferred from the WRF to the DAC-XS register. This does not happen until after the indirect address has been read from memory.

## DAC State 6: AADATA

State 6, AADATA, microprogrammed indirect addressing, adds together the indirect address contents and the microprogram specified AB,dd (not AA,Xn). This is multicycle indirect addressing (AA,DATA and not AB,Xn). The result is placed in EAO (and other EAn registers if specified by EAnSAVE). The result also enters the DAC OUT bus, or the DPA bus if the bus-controlling hardware so decides.

The DAC stays in this state until the indirect access is finished being read from memory.

## DAC State 10: FIRSTOC

State 10, FIRSTOC, first operand cache controlled cycle, is entered when the operand cache specifies control of the address arithmetic. This state is entered when ADARC (same as ADARIT, CS bit 40) is false together with ECMIR and ADACT.

FIRSTOC adds together the operand cache specified address A and B-operands, and places the result in EAO (and other EAn registers if specified by EAnSAVE). The result also enters the DACOUT bus or the DPA bus if the bus-controlling hardware so decides.

## DAC State 11: DCIND

State 11, DCIND, is a NOOP DAC state necessary to synchronize with the DCC sequencer when an indirect operand should not use AC. This is the case when the O-MAP specifies it, as well as when the ATR or ATW traps are enabled. EACQ (effective address cache qualified) is then set false, and state 11 entered. When ATR or ARW are enabled, state 11 passes the indirect address via the DPA bus to the IDU for LL-HL comparison.

## DAC State 12: EAOXS

State 12, EAOXS, adds EAO and the internal DAC-XS register. The DAC stays in this state until one cycle after the necessary X-register has been transferred from the WRF to the DAC-XS register. The result is placed in EAO (and other EAn registers if specified by EAnSAVE). The result also enters the DACOUT bus or the DPA bus if the bus-controlling hardware so decides.

Norsk Data ND-05.020.1 EN

---

## Page 278

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

the DPA bus if the bus-controlling hardware so decides.

## DAC State 13: OPTODP

State 13, OPTODP, is a cycle to transfer the final address (except indirect not post-indexed) via the DPA bus to the IDU when the ATR or ATW traps are enabled. EACQ (effective address cache qualified) is then set false, and state 13 entered. When no address traps are enabled, this state never occurs.

## DAC State 14: DCOPR

State 14, DCOPR, is the final cycle in multicycle addressing, except when indirect not post-indexed addressing is used. When this state is entered, the final address is placed in EAO (and other EAn registers if specified by EAnSAVE). The result also enters the DAC OUT bus, and is clocked into the DACR register. During this cycle, the lookup in the data cache takes place.

## DAC State 15: DLARXS

State 15, DLARXS, is used in indirect post-indexed addressing to perform the post-indexing. The DAC stays in this state until one cycle after the necessary X-register has been transferred from the WRF to the DAC-XS register. This will not happen until the indirect address has been read.

This state adds together the indirect address contents and DAC-XS-register. The result is placed in EAO (and other EAn registers if specified by EAnSAVE).

## DAC State 16: SEDPNPO

State 16, SEDPNPO, is a cycle to transfer the final address (only when indirect not post-indexed) via the DPA bus to the IDU when ATR or ATW traps are enabled. The DAC sequencer stays in this state until the indirect address has been read. When no address traps are enabled, this state never occurs.

## DAC State 17: DLARO

State 17, DLARO, is the final cycle in indirect not post-indexed addressing. When this cycle is entered, the final address is placed in EAO (and other EAn registers if specified by EAnSAVE) and in the DACR register. The DAC sequencer stays in this state until the indirect address has been read. During this state the data cache lookup takes place.

Norsk Data ND-05.020.1 EN

---

## Page 279

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## 11.4 The DCC (Data Cache Controller) Nanostates

The DCC (Data Cache Control) nanostate sequencer is the most complex one in the ND-5000 CPU. The illustration of this nanostate sequencer is divided in three parts:

1. M-level main states  
2. A-level main states  
3. Substates

There are two DCC nanostate diagrams: Figure 56 shows the states in hexadecimal, while figure 57 shows the states in octal.

### M-level main states

1. The main states that are executed on the M-level of the instruction they serve. These generally take care of indirect addressing.

### A-level main states

2. The main states that are executed on the A-level of the instruction they serve. These generally take care of the proper data access of instructions that have been troubled with cache miss or AC-miss. Sequences of this type belong to the Data Clean-Up sequence (DACUS). All the states in the DACUS part of figures 56 (hex) and 57 (oct) belong to this category.

### Memory access states

3. These substates are used by the main states as *subroutines*.

### Read from memory

A. The subroutine to read from memory is used both from M-level (during indirect addressing) and from A-level (accessing final data). The read subroutine uses itself the *dump dirty* subroutine.

### Write to memory

B. The subroutine to write to memory is used only by the A-level. The write subroutine uses itself the *dump dirty* subroutine.

### Dump dirty

C. The subroutine to dump dirty cache addresses to memory is at the lowest level of the subroutine hierarchy. It is used by the main states directly, or by the read memory or write-memory substates.

### Other main states

Some of the main states do not easily fit into the scheme given above. They are all found in the M-level part of figures 56 (hex) and 57 (oct), and are states 0, 1, 17, 18 and 37.

### Nanostate numbering system

The actual hardware uses a different numbering system for the nanostates than described in the following sections. The numbers used by the hardware are indicated on the state charts in parentheses (hexadecimal in figure 56 and octal in figure 57).

* *Norsk Data ND-05.020.1 EN*

---

## Page 280

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

Some numbers in the state charts refer to connection lines instead of nanostate boxes. These numbers serve as references to program labels in the simulator program that describes the ND-5000 CPU.

## Example:

| WECA |
|------|
| 0 (0) |

- Used by hardware  
  Hex. in figure 56  
  Oct. in figure 57  
 
- Refers to description  
  on pages 269 to 277

Norsk Data ND-05.020.1 EN

---

## Page 281

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## NOTE! STATES IN HEXADECIMAL

### A-LEVEL MAIN STATES (DACUS)

| State           | Hexadecimal |
|-----------------|-------------|
| ACHMISS         |             |
| ACPMCS          | 27          |
| ACPMC2          | 25          |
| CCDO b DIRTY    |             |
| ACMISS          |             |
| ACSB2           |             |
| /DCMISS         |             |
| /AMX            |             |
| MEMCDK          | 25 (11D)    |
| MEMM            | 29 (28)     |

### M-LEVEL MAIN STATES

| State           | Hexadecimal |
|-----------------|-------------|
| ACMISS          |             |
| MACMPCK         | 21 (16)     |
| MCLOCK          | 32 (1F)     |
| MCCOLOUR        | 34 (1A1)    |
| MEMSM           | 26 (1F4)    |

### MEMORY ACCESS SUBSTATES

| State           | Hexadecimal |
|-----------------|-------------|
| WHENC           |             |
| WHENC           |             |
| WDIRT           |             |
| WHENMR          |             |
| WHENR           |             |
| WHENRT          | 1XX.04.051  |
| DURDDIRTY       |             |
| DURDDIRTC       |             |

---

*Figure 56. DCC State Chart (States in Hexadecimal)*

*Norsk Data ND-05.020.1 EN*

---

## Page 282

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

### NOTE! States in octal

```
[Diagram of states in octal]
```

#### A-LEVEL MAIN STATES (DACUS)

#### M-LEVEL MAIN STATES

#### MEMORY ACCESS SUBSTATES

- **Figure 57. DCC State Chart (States in Octal)**

- **Norsk Data ND-05.020.1 EN**

---

## Page 283

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## DCC MAIN STATES:

### DCC Main state 0: WECA

State 0, WECA, wait for ECALU (enable clock ALU) is the idle state of the DCC nanostate sequencer. This state waits for ECALU. It then enters state 1, FIALU.

### DCC Main state 1: FIALU

State 1, FIALU, first state after ECALU, does the checking of data cache miss (DCMISS) and address cache miss (ACMISS) for the proper data access of an instruction. The lookup in the data cache has been performed during the previous cycle, and the hit/miss information has been clocked across the M-level/A-level border. At the same time, the DAC has checked the AC-driven cache address against the correct address, and determined ACMISS or not.

If we do not have DCMISS, ACMISS, or any collision between buffered write data and needed source operands, and eventual data to be written can be handled by the write buffer mechanisms, no DACUS cycles are necessary.

If neither the IDU nor the MIC are busy, and no hole in the pipeline is needed to empty the write buffer, a test is done to see if the M-level instruction needs multiple DCC cycles. In cases of indexing without indirect addressing, the DCC waits until the needed (scaled) X-register has been transferred from the WRF to the DAC. When indirect addressing is specified, the DCC state sequencer enters a sequence of states (minimum one) to bring the contents of the indirect address into the DAC and the DACR register.

### DCC Main state 2: WDIRT

State 2, WDIRT, write dirty, is a main state using the dump dirty substates. It is entered when the MEM command *Clear Cache Dump Dirty* is used by the microcode, and the addressed cache entry is dirty. The WDIRT substates .DDIR - .DLA - .DRQ - .DWT - .DRDLA and .DEX are used.

### DCC Main state 3: AACMDC

State 3, AACMDC, A-level ACMiss new DC-lookup, is the cycle that performs the new reading of the data cache with new address from DACR in cases where the AC-contained address was wrong. At the same time, DACR is loaded from ACH or from DAC, to regenerate the address present in DACR when the AC-miss was notified.

### DCC Main state 4: AACMCK

State 4, AACMCK, A-level AC-miss check cycle, checks the status of the new data cache lookup, or if the address caused collisions with data in the write buffer system.

---

## Page 284

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## DCC Main state 6: RA

State 6, RA, memory read on the A-level, reads one 4-byte word from data memory. This is done by using the substates .RQ - .WT and .EX, and possibly the WDIRT substates mentioned in state 2.

## DCC Main state 7: ARWXINC

State 7, ARWXINC, A-level Read Word crossing INCrement, is a state that adds 4 to the DLAH register. This is done if the memory operand crosses a word boundary (unaligned data operands). The new address is generated in the DLAH register, which contains an incrementer.

## DCC Main state 8: ARWXCK

State 8, ARWXCK, A-level Read Word crossing CheCk cycle, checks if the cache lookup in state 50 was a data cache hit.

## DCC Main state 9: RAX

State 9, RAX, word cross read on the A-level, behaves exactly as state 6. It is used when operands cross 4-byte boundaries (are unaligned), and reads the last part.

## DCC Main state 11: WA

State 11, WA, memory write on the A-level, writes into data memory. This is done by using the substates .RQ - .WT and .EX, and possibly the WDIRT substates mentioned in state 2.

## DCC Main state 12: AWWXINC

State 12, AWWXINC, A-level Write Word crossing INCrement, is a state that adds 4 to the DLAH register. This is done if the memory operand crosses a word boundary (unaligned data operands). The new address is generated in the DLAH register, which contains an incrementer.

## DCC Main state 13: AWWXCK

State 13, AWWXCK, A-level Write Word crossing CheCk cycle, checks if the cache lookup in state 51 was a data cache hit.

## DCC Main state 14: WAX

State 14, WAX, memory word cross write on the A-level, behaves exactly as state 11. It is used when operands cross 4-byte boundaries (are unaligned), and writes the last part.

## DCC Main state 15: ADRDIRT

State 15, ADRDIRT, reads dirty directory and dirty status.

## DCC Main state 17: DCTRP

State 17, DCTRP, is the state entered when a trap is to be processed. The DCC state sequencer stays in this state until microcode releases it.

---

## Page 285

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## DCC Main state 18: WIDCAN

State 18, WIDCAN, is a state where the DCC state sequencer waits for the IDU or MIC to be finished with activities that hold the pipeline.

## DCC Main state 19: XWRFDAC

State 19, XWRFDAC, is a DCC waiting state to allow the X-register to be transferred from the WRF to the DAC during indexed non-indirect addressing.

## DCC Main state 20: MACMDC

State 20, MACMDC, M-level ACMiss new DC-lookup, is the cycle that performs the new reading of the indirect address from the data cache with new address from DACR in cases where the AC-contained address was wrong.

## DCC Main state 21: MACMCK

State 21, MACMCK, M-level ACMiss CheCk cycle, checks if the new data cache lookup had data cache miss, or if the address caused collisions with data in the write buffer system.

## DCC Main state 22: MCK

State 22, MCK, M-level ChecK cycle, determines if the cache lookup of the indirect address gave ACMISS, or if the address caused collisions with data in the write buffer system.

## DCC Main state 23: RM

State 23, RM, memory read on M-level, reads one 4-byte word from data memory. This is done by using the substates .RQ - .WT and .EX, and possibly the WDIRT substates mentioned in state 2.

## DCC Main state 24: MRWXINC

State 24, MRWXINC, M-level Read Word crossing INCrement, is a state that adds 4 to the DLAH register. This is done if the indirect address crosses a word boundary (unaligned indirect address). The new address is generated in the DLAH register, which contains an incrementer.

## DCC Main state 25: MRWXCK

State 25, MRWXCK, M-level Read Word crossing CheCk cycle, checks if the cache lookup in state 52 was a data cache hit.

## DCC Main state 26: RMX

State 26, RMX, word cross read on the M-level, behaves exactly as state 23. It is used when indirect addresses cross 4-byte boundaries (are unaligned), and reads the last part.

---

Norsk Data ND-05.020.1 EN

---

## Page 286

# ND-5000 NANOSTATES DESCRIPTIONS

## DCC Main State 28: XIWRFDAC

State 28, XIWRFDAC, is a DCC waiting state to allow the X-register to be transferred from the WRF to the DAC during indirect indexed addressing.

## DCC Main State 30: XCOLWR

State 30, XCOLWR. Address collision between an indirect address and the write buffer contents has forced the write buffer to be emptied. The emptying takes place in this cycle, the data cache is addressed by the write buffer address register (WBA).

## DCC Main State 31: XCOLRD

State 31, XCOLRD. After the colliding data have been written in state 30, this state reads them back.

## DCC Main State 32: XCOLCK

State 32, XCOLCK, is a state needed to check for data cache hit after state 31 has read the data. Even if data has just been written into this cache address by state 30, cache miss is possible. The comparison that caused collision does not compare the full 32-bit logical address, only the 16 bits that are used as cache address. This implies that cache miss can occur even if collision has been processed.

## DCC Main State 33: COLLWR

State 33, COLLWR. Address collision between data to use and write buffer contents has forced the write buffer to be emptied. The emptying takes place in this cycle, the data cache is addressed by the write buffer address register (WBA).

## DCC Main State 34: COLLRD

State 34, COLLRD. After the colliding data have been written in state 33, this state reads them back. (Alignment considerations make it difficult to short-cycle the data directly from WBD to A-operand without storing it in the data cache).

## DCC Main State 35: COLLCK

State 35, COLLCK, is a state needed to check for data cache hit after state 34 has read the data. Even if data has just been written into this cache address by state 33, cache miss is possible. The comparison that caused collision does not compare the full 32-bit logical address, only the 16 bits that are used as cache address. This implies that cache miss can occur even if collision has been processed.

## DCC Main State 36: ACML1

State 36, ACML1, A-level ACMiss for LADDR instructions, is the cycle that gives the correct address from the DAC in cases where the AC-contained address was wrong. DACR is used as A-operand in

Norsk Data ND-05.020.1 EN

---

## Page 287

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

273

this cycle.

## DCC Main state 37: WBDTODC

State 37, WBDTODC, WBD to Data Cache, is a state associated with the forced emptying of the write buffer into the data cache. This is necessary when the WBD is filled, and new data needs to be written into it. In most cases, the WBD can be emptied during a QVACC (Qualified VACant Cache Cycle) without inserting extra nanocycles. But sometimes a necessary FVACC (Forced VACC) occurs without a QVACC, and state 37 is necessary.

The actual emptying of WBD into DC takes place in the cycle before state 37. State 37 makes room for the M-level activity of the next microinstruction, since several of the necessary M-level resources were used by the emptying.

## DCC Main state 38: PXINGEX

State 38, PXINGEX, is the last state of the sequence started by state 39. State 38 is used to restore the original contents to the memory management address register.

the The contents were destroyed when the memory management processed PXING request.

## DCC Main state 39: PXINGRQ

State 39, PXINGRQ, is entered when we have a write command in the microcode, and the address is in the last part of a page so that the write data crosses a page border.

The purpose of this state sequence is to ensure that write is not initiated unless it is certain that the whole write can be performed without being aborted by page faults, protect violations, etc.

A special request type is sent to the memory management unit when this cycle is entered. It causes the memory management to check the next page for page faults and write protection.

## DCC Main state 40: PXINGWT

State 40, PXINGWT, is used to wait for the memory management to complete the processing of the request from state 39. If it is not possible to write into the next page, this state causes an MM-trap condition.

## DCC Main state 41: XCOLLWR

State 41, XCOLLWR. Address collision between word crossing data to use and write buffer contents has forced the write buffer to be emptied. This state behaves as state 33.

## DCC Main state 42: XCOLLRD

State 42, XCOLLRD. After the colliding data have been written in

Norsk Data ND-05.020.1 EN

---

## Page 288

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

state 41, this state reads them back. This state behaves as state 34.

## DCC Main state 43: XCOLLCK

State 43, XCOLLCK, is a state needed to check for data cache hit after state 42 has read the data. This state behaves as state 35.

## DCC Main state 44: XICOLWR

State 44, XICOLWR. Address collision between word crossing indirect address and write buffer contents has forced the write buffer to be emptied. This state behaves as state 33.

## DCC Main state 45: XICOLRD

State 45, XICOLRD. After the colliding data have been written in state 44, this state reads them back. This state behaves as state 34.

## DCC Main state 46: XICOLCK

State 46, XICOLCK, is a state needed to check for data cache hit after state 45 has read the data. This state behaves as state 35.

## DCC Main state 49: ACML2

State 49, ACML2, A-level ACMiss for LADDR instructions second cycle, is necessary to give space for the M-level activity of the instruction following the LADDR that had ACMISS. It also allows the ALU to execute the LADDR function.

## DCC Main state 50: ARWXDC

State 50, ARWXDC, A-level Read Word crossing Data Cache lookup, is a state that uses the incremented DLAH register to read from the data cache. This is done if the memory operand crosses a word boundary (unaligned data operands).

## DCC Main state 51: AWWXDC

State 51, AWWXDC, A-level Write Word crossing Data Cache lookup, is a state that uses the incremented DLAH register to address the data cache. This is done if the memory operand crosses a word boundary (unaligned data operands).

## DCC Main state 24: MRWXDC

State 24, MRWXDC, M-level Read Word crossing Data Cache lookup, is a state that uses the incremented DLAH register to read from the data cache. This is done if the indirect address crosses a word boundary (unaligned indirect address).

## DCC Main state 53: SDIRCK

State 53, SDIRCK, is the second extra state which is necessary when a cache entry is changed from RESRV to DIRTY.

Norsk Data ND-05.020.1 EN

---

## Page 289

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## DCC Main state 54: SETDIRT

State 54, SETDIRT, upgrades to dirty and rewrites the dirty directory read in state 15 ADRDIRT.

## DCC Main state 55: PXINGCK

State 55, PXINGCK, checks cache contents after page crossing check. Checks the status of the new data cache lookup, or if the address caused collisions with data in the write buffer system.

---

Norsk Data ND-05.020.1 EN

---

## Page 290

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## DCC WRITE SUBSTATES (WA.XXX AND WAX.XXX)

### DCC WRITE Substate 1

WDIRT, Write DIRTy, has several sub-substates, described later. They are called .DDIR - .DLA - .DRQ - .DWT - .DRDLA and .DEX.

### DCC WRITE Substate 3

RQ, cycle to send a write request to main memory.

### DCC WRITE Substate 4

WT, WaiTing cycle when the access is done. This cycle waits for the memory management system and the data memory to finish (waiting for memory is only necessary if the previous access is not finished).

### DCC WRITE Substate 5

EX, EXit cycle to restore the previous contents to the DLA bus.

### DCC WRITE Substate 6

WXHIT1, word crossing hit, hit on write (dirty or reserved). Reads dirty directory.

### DCC WRITE Substate 7

WXHIT2, word crossing hit, writes data and eventually upgrades to dirty. Also waits for terminate (F-cycle) directory.

## DCC READ SUBSTATES (RA.XXX, RAX.XXX, RM.XXX AND RMX.XXX)

### DCC READ Substate 1

WDIRT, Write DIRTy, has several sub-substates, described later. They are called .DDIR - .DLA - .DRQ - .DWT - .DRDLA and .DEX.

### DCC READ Substate 3

RQ, cycle to send a read request to main memory.

### DCC READ Substate 4

WT, WaiTing cycle when the access is done. This cycle waits for the memory management system and the data memory to finish.

### DCC READ Substate 5

EX, EXit cycle to restore the DLA bus to its previous content.

---

## Page 291

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## DCC Dump Dirty Substates (DD.xxx, WA.xxx, WAX.xxx, RA.xxx, RAX.xxx, RM.xxx and RMX.xxx)

### DCC Dump Dirty Substate 2
DDADR, address dirty to get dirty directory.

### DCC Dump Dirty Substate 3
DLA, dirty logical address is transferred from the DCC to the memory management.

### DCC Dump Dirty Substate 4
DRQ, dirty request is sent to the memory management to write the dirty cache entry to memory.

### DCC Dump Dirty Substate 5
DWT, dirty wait cycle while the memory management and the data memory are handling the request.

### DCC Dump Dirty Substate 6
DRDLA, dirty restore data logical address, is a state needed to restore the DLA bus to the original contents from the DLAH register.

### DCC Dump Dirty Substate 7
DEX, Dirty EXit cycle.

### DCC Dump Dirty Substate 8
DDIR, dirty directory cycle. The DOM and PS from the cache directory of the dirty address are transferred to the memory management.

---

Norsk Data ND-05.020.1 EN

---

## Page 292

# 11.5 MM (Memory Management) Nanostates

| IDLE 0       | MREQ               |                  | CTRAP         |
|--------------|--------------------|------------------|---------------|
|              | PXING              | TRAP 23          | OK            |
| MBUSY        |                    | TRAP             |               |
| PADD 1       | TRAP               |                  |               |
| TSB-MISS     | PHS-MISS           | PGU/WIP          |               |
| PSCAPA 2     | PHSA 9             | PUWPA1 16        |               |
| PSCAPR 3     | PHSR 10            | PUWPR 17         |               |
| TRAP         |                    | TRAP             |               |
| MBUSY        | MBUSY              | MBUSY            |               |
| PSCAPT 4     | PHST 11            | PUWPA2 18        |               |
| TRAP         |                    | PGU/WIP OK       |               |
| NO INDEXING  | NO INDEXING        |                  |               |
| CAPIR 5      | 1 INDEX            | PUWPW 19         |               |
| TRAP         | 2 INDEXES          | TRAP             |               |
| MBUSY        | IIXR 12            | MBUSY            |               |
| CAPIT 6      | TRAP               | PXING            |               |
| TRAP         | MBUSY              | PA 20            |               |
| CAPR 7       | IIXT 13            |                  |               |
| TRAP         | TRAP               |                  |               |
| MBUSY        |                    |                  |               |
| CAPT 8       | IXR 14             |                  |               |
| TRAP         | MBUSY              |                  |               |
|              | IXT 15             |                  |               |
|              | TRAP               |                  |               |

*Figure 58. State Chart for the MM Nanostates*

Norsk Data ND-05.020.1 EN

---

## Page 293

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## Explanation of the MM Nanostates:

### MM Baby Card

The memory management gate arrays (one for instructions and one for data) are associated with nanostate sequencers. Requests to main memory activate a nanosequence, which can be short or long depending on whether hit in the TSB (Translation Speedup Buffer) follows. When the MM baby card is engaged in a nanosequence, the requesting nanosequence of either the DCC (for data memory) or the IDU (for instructions) must wait until the MM nanosequence is finished.

### MM State 0: IDLE

State 0, IDLE, is the resting state of an MM nanosequencer. In this state A-operands can be read from the MM baby card, and destinations can be written. If a memory request is received, the next state is either PXING (state 21) if the request is a PXING request, or PADD (state 1). Otherwise:

If a dirty write request is to be issued, the dirty PS and the dirty DOM registers are loaded in this state.

If a PXING request is received, the LA register is incremented by 4000, to point to the next page of logical memory.

When a memory read/write request is to be sent to the MM baby card, the LA register is filled with the logical address, and a TSB address is generated by using a hash algorithm on some of the address bits. This happens in the nanocycle before the request. The request can be of different types:

| Type | Request |  
|------|---------|
| 1    | Logical read request | READ |
| 2    | Logical write request | WRITE |
| 3    | Logical page-crossing request | PXING |
| 4    | Read request in physical segment | RD_PHYS |
| 5    | Write request in physical segment | WR_PHYS |
| 6    | Physical read request | RD_POF |
| 7    | Physical write request | WR_POF |

### MM State 1: PADD

State 1, PADD, loops until the previous memory request has been finished. It then presents the physical address on DB (in case of data) or MIB (in case of instructions). The 11 least significant bits are the same as in the logical address, and the rest of the physical address bits are taken from the addressed entry in the TSB.

This physical address is the correct one if TSB-hit is the case. The test on TSB-hit/TSB-miss is performed in this nanocycle.

TSB-hit, together with indications that the WIP/PGU table is properly updated, cause the nanosequence to be finished, and the next state is IDLE. Final requests to memory are then issued.

Norsk Data ND-05.020.1 EN

---

## Page 294

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

If the WIP/PGU table needs to be updated, the next nanostate is 16, PUWPA1.

If the request is a logical read/write request with TSB-miss, the next state is state 2, PSCAPA.

If the request is a read/write of a physical segment location, and the single word TSB for such access gives PHS-miss, the next state is 9, PHSA.

A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Memory error

2. Memory timeout

3. Write protect violation

4. Alternative protect violation

## MM State 2: PSCAPA

State 2, PSCAPA, uses PSTP and PS to generate an address inside PST. A read request for this address is issued. The next state is state 3, PSCAPR.

## MM State 3: PSCAPR

State 3, PSCAPR, loops until data requested in state 2 is returned from memory. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Memory error

2. Memory timeout

The next state is 4, PSCAPT.

## MM State 4: PSCAPT

State 4, PSCAPT, tests the data read in state 3. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. The indexing for this physical segment has two levels. This is not allowed for a process segment.

2. The PST entry contains zero. Page fault.

If the PST entry indicated no indexing, the next state is number 7. A read request to fetch four bytes containing the capability is then sent to memory.

If single indexing is indicated, state 5 is entered. A read request to fetch the needed word from the index page is then sent to memory.

Norsk Data ND-05.020.1 EN

---

## Page 295

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## MM State 5: CAPIR

State 5, CAPIR, loops until data requested in state 4 is returned from memory. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Memory error
2. Memory timeout

The next state is number 6, CAPIT.

## MM State 6: CAPIT

State 6, CAPIT, tests the data read in state 5. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Index error. Bit 31 and bit 30 must be 0.
2. The index-entry contains zero. Page fault.

A read request to fetch four bytes containing the capability is then sent to memory. The next state is 7, CAPR.

## MM State 7: CAPR

State 7, CAPR, loops until data requested in state 4 or state 6 is returned from memory. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Memory error
2. Memory timeout

The next state is number 8, CAPT.

## MM State 8: CAPT

State 8, CAPT, tests the data read in state 7. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. The capability is indirect other computer
2. The capability is indirect other domain
3. The capability is 0, protect violation
4. Write protect violation
5. Alternative protect violation

A read request to fetch four bytes from the PST is then sent to memory. The next state is 10, PHSR.

## MM State 9: PHSA

State 9, PHSA, reads four bytes from the PST in requests that want to read or write in physical segments, when PHS miss occurs. The next state is state 10, PHSR.

Norsk Data ND-05.020.1 EN

---

## Page 296

# MM State 10: PHSR

State 10, PHSR, loops until data requested in state 8 or state 9 is returned from memory. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Memory error
2. Memory timeout

The next state is 11, PHST.

# MM State 11: PHST

State 11, PHST, tests the data read in state 10. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Indexing error. Three index levels are not allowed.
2. The PST entry contains zero. Page fault.

If the PST entry indicated no indexing, the next state is 16. The physical address has then been found.

If single indexing is indicated, state 14 is entered. A read request to fetch the needed word from the index page is then sent to memory.

If double indexing is indicated, state 12 is entered. A read request to fetch a word from the first index page is then sent to memory.

# MM State 12: IIXR

State 12, IIXR, loops until data requested in state 11 is returned from memory.

A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Memory error
2. Memory timeout

The next state is 13, IIXT.

# MM State 13: IIXT

State 13, IIXT, tests the data read in state 12. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Indexing error
2. The index entry contains zero. Page fault

The next state is 14, IXR. A read request to read an entry in the last index table is sent out to memory.


Norsk Data ND-05.020.1 EN

---

## Page 297

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## MM State 14: IXR

State 14, IXR, loops until data requested in state 13 or 11 is returned from memory. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Memory error
2. Memory timeout

The next state is 15, IXT.

## MM State 15: IXT

State 15, IXT, tests the data read in state 14. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Indexing error
2. The index entry contains zero. Page fault
3. The last index entry which was read indicates that the accessed page was write protected.

The next state is 16, PUWPA1.

## MM State 16: PUWPA1

State 16, PUWPA1, is entered when the WIP or the PGU table may need to be updated. This state generates a physical address using the PSTP pointer, and sends a read request with LOCK to memory to get hold of the WIP and PGU information for 16 pages of physical memory. The next state is 17, PUWPR.

## MM State 17: PUWPR

State 17, PUWPR, loops until data requested in state 16 is returned from memory. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Memory error
2. Memory timeout

The next state is 18, PUWPA2.

## MM State 18: PUWPA2

State 18, PUWPA2, checks the data read by state 17.

If WIP and PGU are correctly set for the physical page that is to be accessed, the next state is number 0, IDLE. The final physical address is then sent to memory. It is generated using the physical page number read in state 14 (IXR) or 10 (PHSR), and the displacement within page is taken from the LA register. The proper type of memory request is sent to memory. The type has been saved in the MM baby card during the nanosequence.

If WIP or PGU need to be updated, an address is generated, and a write request is sent to main memory to write the updated WIP/PGU information. The next state is then 19, PUWPW. 

Norsk Data ND-05.020.1 EN

---

## Page 298

# Chapter 11 ND-5000 NANOSTATES DESCRIPTION

## MM State 19: PUWPW

State 19, PUWPW, loops until memory is finished with the write request from state 18. A few conditions cause the next state to be 23, TRAP. These conditions are:

1. Memory error
2. Memory timeout

## MM State 20: PA

State 20, PA, sends the final physical address to memory. It is generated using the physical page number read in state 14 (IXR) or 10 (PHSR), and the displacement within page is taken from the LA register. The proper type of memory request is sent to memory. The type has been saved in the MM baby card during the nano-sequence. The next state is number 0, IDLE.

## MM State 21: PXING

State 21, PXING, is inserted between state 0 and state 1 when PXING requests are received by the MM. The LA register is incremented by 4000 when state 21 is entered from state 0. State 21 is needed to allow time for the new LA register to generate a TSB hash index.

## MM State 23: TRAP

State 23, TRAP, handles all exceptional conditions occurring during MM nanosequences. State 23 loops until it is released by the microcode command CTRAP (clear trap). While the MM nano-sequencer is in state 23, A-operands can be read and destinations can be written. No requests are processed by the nanosequencer. When state 23 is finished, state 0, IDLE is entered.

Norsk Data ND-05.020.1 EN

---

## Page 299

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## 11.6 MFBus Channel Controller (MFBCC) Nanostates

State descriptions follow on the next two pages.

## Clear State Chart

| State    | Condition              | Transition |
|----------|------------------------|------------|
| IIDLE    | IRREQ + IWREQ          | ILOCK      | 
| IADR     | DABUSY + DLOBSY        | IAWT 1     |
| MEMERR   |                        | IASYNC 6   |
| SDRY     |                        | MEMERR     |
| MEMERR   |                        | IDSYNC 2   |

| State    | Condition              | Transition |
|----------|------------------------|------------|
| DIDLE    | DREQST                 | DLOCST     |
| DADR     | IABUSY + ILOBSY        | DAWT 1     |
| MEMERR   |                        | DASYNC 6   |
| SDRY     |                        | MEMERR     |
| MEMERR   |                        | DDSYNC 2   |

### Symbols Legend

- `'` = not
- DABUSY = data channel address busy
- DLOBSY = data channel lock busy
- DLOCST = data channel lock start
- DREQST = data request start
- IABUSY = instruction channel address busy
- ILOBSY = instruction channel lock busy
- IRREQ = instruction channel read request
- IWREQ = instruction channel write request
- MEMERR = memory error
- SABSY = synchronous address busy
- SDRY = synchronized data ready

*Figure 59. State Chart for the MFBCC Nanostates*

Norsk Data ND-05.020.1 EN

---

## Page 300

# Explanation of the MFICC Nanostates:

## Instruction channel states:

| State    | Description |
|----------|-------------|
| I-channel State 0: IIDLE | State 0, instruction channel IDLE state. |
| I-channel State 1: IAWT | State 1, IAWT, instruction channel address wait. The data channel is in address state. |
| I-channel State 2: IDSYNC | State 2, IDSYNC, instruction channel data synchronization. Waits for DRY (data ready) from BADAP. |
| I-channel State 3: ILO | State 3, ILO, instruction channel lock state. Generates LOCK signal to BADAP. |
| I-channel State 4: IADR | State 4, IADR, instruction channel address state. Generates ARQ (address request) to BADAP. |
| I-channel State 5: IDWT | State 5, IDWT, instruction channel wait state. The data channel is in data state or synchronization. |
| I-channel State 6: IASYNC | State 6, IASYNC, instruction channel address synchronization. Waits for ARY (address ready) from BADAP. |

## Data channel states:

| State    | Description |
|----------|-------------|
| D-channel State 0: DIDLE | State 0, data channel IDLE state. |
| D-channel State 1: DAWT | State 1, DAWT, data channel address wait. The instruction channel is in address state. |
| D-channel State 2: DDSYNC | State 2, DDSYNC, data channel data synchronization. Waits for DRY (data ready) from BADAP. |
| D-channel State 3: DHOLD | State 3, DHOLD, hold state for the data channel. Used if a request occurs simultaneously on the instruction channel and the data channel. |

Norsk Data ND-05.020.1 EN

---

## Page 301

# Chapter 11 ND-5000 NANOSTATES DESCRIPTIONS

## D-channel

### State 4: DADR
State 4, DADR, data channel address state. Generates ARQ (address request) to BADAP.

## D-channel

### State 5: DDWT
State 5, DDWT, data channel wait state. The instruction channel is in data state or synchronization.

## D-channel

### State 6: DASYNC
State 6, DASYNC, data channel address synchronization. Waits for ARY (address ready) from BADAP.

## D-channel

### State 7: DLO
State 7, DLO, data channel lock state. Generates LOCK signal to BADAP.

---

## Page 302

I'm sorry, the page is blank except for a page number and document information at the bottom.

---

## Page 303

# Chapter 12 Data Address Booster (IDAC)

Norsk Data ND-05.020.1 EN

---

## Page 304

I'm unable to extract text from this image. If there's any way you can provide a clearer image or another format, I'd be happy to help!

---

## Page 305

# Chapter 12 Data Address Booster (IDAC)

## 12.1 General

The data address booster, also called I-level data address controller (IDAC), is provided as an option for the ND-5800 and ND-5900 models. It is an add-on unit to boost the speed of data address calculation on the ND-5000 CPU. Figure 60 shows the physical location of the data address booster baby card.

The most important target for increasing speed, is address calculation, specially with indexing. Less gainful, but still important, is improving the other exception addressing activities. The principal operation of the IDAC is to do the most important address calculations on the I-level of the pipeline, i.e., to act as an always-valid address cache as seen from the address-cache environment without the IDAC.

![Figure 60](https://i.imgur.com/1gKNPLIC.png)

*Figure 60. Physical Location of Data Address Booster (IDAC)*

Norsk Data ND-05.020.1 EN

---

## Page 306

# Chapter 12 Data Address Booster (IDAC)

The IDAC baby card is the same size as the cache baby card, i.e. 3/4 of the size of the mother card. It is placed as a third layer of baby cards on top of the small baby cards.

The IDAC hardware consists of:

- A 32-bit adder with carry look-ahead
- PALs to do three to two column reduction
- 4:1 multiplexers for X-scaling
- Devices for X, B and R-registers
- Transceivers to select direct I-level or M-level or values saved from both, and to return register contents for examination
- 8K by 9 bit RAM to carry I-level control of X-register selection, scaling and operation select
- PALs to carry control logic
- In addition, and independent of other logic, a fast implementation of the DLAH register

The data address booster is implemented as shown in figure 61.

Norsk Data ND-05.020.1 EN

---

## Page 307

# Chapter 12 Data Address Booster (IDAC)

![Figure 61. Data Address Booster (IDAC) Implementation](image_url)

| Keyword  | Description                                         |
|----------|-----------------------------------------------------|
| DACCO    | DACOUT bus                                          |
| DAL      | data alignment logic                                |
| DLA      | data logical address                                |
| TAT      | transfer bus to address bus transceiver             |
| TDACT    | transfer bus to DAC-out transceiver                 |

## 12.2 Need for Improved Speed on Address Calculation

Without the IDAC, the data address calculation is done by the data address controller (DAC) gate array. The address is primarily calculated during the instruction decoding process, and the final address (or the pointer to the indirect address) is stored in the address cache (AC). However, when post-indexing or pre-indexing (XING), the address cache is never used. And with record addressing (R), the AC content is more likely to be wrong (AC-miss). In such cases, the DAC is engaged to re-calculate the address, as for all types of AC-miss.

* *Norsk Data ND-05.020.1 EN*

---

## Page 308

# 12.3 Penalty for Exceptions on Load/Store One Operand

The *normal* cycle time is 70 ns, which is the cycle time for reading/writing one data operand directly from/to the cache. This is only true if:

- The address to the operand is valid in the address cache
- The data is valid/dirty in the data cache (DC)
- The registers in the DAC are valid
- Data is aligned
- No collisions occur
- There is no indexing

The following table shows the penalty in extra time if this is not true.

| Penalty for Exceptions on Load/Store One Operand                                    |     |
|-------------------------------------------------------------------------------------|-----|
| Simple DAC generation, not AC-qualified (address trace only)                        | 160 ns |
| Local post-indexing, act. X-reg. loaded 3 or more instructions before               | 270 ns |
| Local post-indexing, act. X-reg. loaded 2 instructions                              | 380 ns |
| Local post-indexing, act. X-reg. loaded 1 instruction before                        | 495 ns |
| Load B-reg. or R-reg, extra to ensure to be valid                                   | 425 ns |
| AC-miss                                                                             | 310 ns |
| Instruction cache miss (average)                                                    | 1400 ns |
| Data cache miss on read, no dump dirty                                              | 1030 ns |
| First memory write (without dump dirty)                                             | 580 ns |
| Second memory write (upgrade to dirty)                                              | 580 ns |
| Dump dirty (addition to read or write miss)                                         | 1075 ns |
| Read/write collision                                                                | 555 ns |
| Nonaligned but not word crossing on read                                            | 40 ns |
| Nonaligned and word crossing on read                                                | 470 ns |
| Nonaligned and word crossing on write, hit on both (dirty)                          | 1360 ns |
| Write but not whole word and not hit                                                | 580 ns |
| Indirect (+ eventually as for read when cache miss etc.)                            | 155 ns |

*Table 36. Penalty for Exceptions on Load/Store One Operand*

Norsk Data ND-05.020.1 EN

---

## Page 309

# 12.4 Improvements by the IDAC Hardware

The IDAC hardware provides the following improvements:

- Address calculations are done on the I-level of the pipeline when AC-miss is likely (R), or when indexing to avoid pipeline break.

- The need of passing X-registers from the working register file (WRF) is avoided by keeping copies outside.

- The value to be loaded into B, R or X-registers is picked up on the A-operand bus on the M-level (as opposed to the two cycles later F-level pickup without the IDAC) when the value is not to be modified by the ALU. This is always true when loading the B and R-registers and usually true for the X-registers.

- The following activities are speeded up by additional, faster components:

  - Re-addressing on the A-level (data clean-up sequence - DACUS) by the slow hold register

  - Indirect addressing when cache miss

  - Word crossing

  - Collision

- Improvements are made to the memory interface control to:
  
  - Shorten the time to request by one SLOW1 (113 ns) cycle
  
  - Respond on data ready by one normal (70 ns) cycle

Norsk Data ND-05.020.1 EN

---

## Page 310

# 12.5 Some Examples from Programs

As mentioned earlier, the most important target for increasing speed, is address calculation, specially with indexing. This is shown clearly in the examples below. Less gainful, but still important, is improving the other exception activities.

The following eight instructions, taken from a FORTRAN-compiled program, show a nice, smooth in-pipeline sequence without indexing, and with hit in all caches. This sequence is not improved by the IDAC.

| Instruction      | Cycle   | Time (ns) |
|------------------|---------|-----------|
| W1 + B.44B:S     | 1-      | 70        |
| W1 := B.130B:S   | 1-      | 70        |
| W2 := B.70B:S    | 1-      | 70        |
| W2 * 144B        | 1--1--  | 226       |
| W2 - 144B        | 1-      | 70        |
| W2 + B.54B:S     | 1-      | 70        |
| W2 * 226B        | 1--1--  | 226       |
| **SUM**          |         | **759 ns**|

On the other hand, the next sequence, taken from the same program and doing almost the same thing, shows a lot of off-pipeline activities because of indexing and wait for loading X-register situations. In this case, the IDAC gains more than three times in speed. Note that the execution times given for the instructions are for the time on A-level, while most of the delays are on M-level and, therefore, seem to show up on previous instructions.

| Instruction                   | Without the IDAC: | With the IDAC: |
|-------------------------------|-------------------|----------------|
| W3 := B.154B:S                | 1--o--o--         | 1-             |
|                              | 339               | 70             |
| W1 := B.2041200B(W2)          | 1---o--o--o--     | 452            |
|                              | 1-                | 70             |
| W1 * B.4453370B(W3)           | 1--1--            | 226            |
|                              | 1--1--            | 226            |
| W4 := B.1400B                 | 1--o--o--o--o--o--| 565            |
|                              | 1-                | 70             |
| W1 * B.37’777777030B(W4)      | 1--1--            | 226            |
|                              | 1--1--            | 226            |
| W2 = B.114B:S                 | 1--o--o--o--o--o--| 565            |
|                              | 1-                | 70             |
| W1 := B.2041200B(W2)          | 1—                | 70             |
|                              | 1-                | 70             |
| W1 := B.110B:S                | 1--o--o--o--o--   | 556            |
|                              | 1-                | 70             |
| **SUM**                       | **2999 ns**       | **872 ns**     |

1- 1-- 1--- means normal, slow1 and slow2 first pipeline cycles 
o-- o-- o-- means same nanocycles.

Norsk Data ND-05.020.1 EN

---

## Page 311

# Chapter 12 Data Address Booster (IDAC)

## 12.6 IDAC Principal Operation

The principal operation of the IDAC is to do the most important address calculations on I-level, i.e. to act as an always-valid address cache seen from the present environment of the address cache. This is made possible without modifying gate arrays by:

- Letting the DAC gate array be 'fooled' into seeing all actual address modes to be non-indexed and valid in the address cache. This prevents interference from the DAC in sequence and/or on the DACOUT bus

- Letting the WRF gate arrays be 'fooled' into seeing all actual address modes to be non-indexed. This prevents passing the X-register to the A-operand bus.

The following are implemented in existing hardware:

- Additional address arithmetic

- X-register copies

- B-register copy

- New R-register

- Logic to access and treat the necessary data buses, and to control the different operations

Norsk Data ND-05.020.1 EN

---

## Page 312

# 12.7 Address Calculations Done by the IDAC

The primary function of the IDAC is to calculate one of the following address formulas:

- B + d + S*X(n) (local post-indexed)
- I + S*X(n) (indirect post-indexed)
- R + d (record)
- X(n) + d (pre-indexed)
- d + S*X(n) (absolute post-indexed)

Where:

- B = copy of B-register or new value to be loaded into it
- R = R-register or new value to be loaded into it
- d = value of DPA-bus direct I-level, or clocked to M-level
- I = value of XT-bus direct or clocked M-level
- S = scaling 1, 2, 4 or 8 for byte, HW, W/F or DF respectively. Address calculations with scaling 1/8 (bit) are not performed by the IDAC.
- X(n) = X-register 1, 2, 3 or 4 or new value to be loaded

Other address-mode calculations are not performed by the IDAC.

# 12.8 Microprogram Implications

Changes in the microprogram definition make it possible to use the R-register on the IDAC differently than the one in DAC, and to access the copies of B and X-registers for test purposes.

## 12.8.1 R-Register and EXR-Register

The R-register on the IDAC is called EXR, and has the destination code D,DAC,EXR with the octal value 375, while the R-register in DAC is the same. This is to make it possible to do R::= in one cycle and still allow R:: in the next instruction. Microprogram

Norsk Data ND-05.020.1 EN

---

## Page 313

# Chapter 12 Data Address Booster (IDAC)

for loading and storing the R-register is changed to use the new mnemonic and to skip the three dummy instructions in load R. The R-register in the DAC must be used for microprogrammed address calculations in the DAC.

## 12.8.2 Use of B-register

The main B-register is found in the DAC. The B-register used in the IDAC is only a copy.

---

Norsk Data ND-05.020.1 EN

---

## Page 314

I'm sorry, but the page you provided is blank. Could you please provide another page that contains text or data?

---

## Page 315

# Chapter 13 Hardware Trace Module

Norsk Data ND-05.020.1 EN

---

## Page 316

I'm sorry, I can't assist with this image.

---

## Page 317

# Chapter 13 Hardware Trace Module

## 13.1 Trace Module Memory

The trace memory of the ND-5000 CPU is 160-bit wide and 4K deep static RAM. It covers:

- The three most important buses (MIB, DB, AOP)
- The microprogram address
- All nanostate identifiers
- The pipeline WAIT signal
- A wired spare signal
- The signal TRIGD

All these signals are stored into the trace memory every micro or nanocycle for 4K cycles, depending of the specified setup of the tracer.

The memory is accessible from microprogram (only for read) in five 32-bit partitions. The contents can be read consecutively from address zero after clearing the Trace Address Counter. One of the five read actions, read C-trace, increments the address counter. To locate the trigger in middle-trace mode, a signal TRIGD (triggered) is available in the C-trace word.

## 13.1.1 MIB Trace (ITACE)

The MIB bus shows instruction memory activities. On hit in the instruction cache, only logical byte addresses for instructions and operands are shown and can be stored into trace memory. When the IDU (Instruction Decode Unit) is active to update the cache, after cache miss or when no cache is in use or present, the physical address and instruction data are also available on the MIB bus. If there is no TSB hit on the IMM (Instruction Memory Management), all addresses and data during IMM activities are available to be stored in the ITRACE part of the trace memory.

Norsk Data ND-05.020.1 EN

---

## Page 318

# 13.1.2 DB Trace (DTRACE)

The DB bus (Data Bus) shows data memory activities. As with ITRACE, only the logical address is shown, normally when hit in the data cache. In other case, like on the instruction side, both physical address, data eventually DMM (Data Memory Management) activities are available on the DB bus to be stored into the DTRACE part of the trace memory.

# 13.1.3 AOP Trace (ATRACE)

On the AOP bus, all A-operand data is available to be stored into the ATRACE part, whether data cache hit or not.

# 13.1.4 Microprogram Address and Control Signals (CTRACE)

On the CTRACE part of the trace memory, the 16 least significant bits contain: the microprogram address (MAR 0:15). The upper 16 bits contain the DCC (Data Cache Controller) nano-sequence states; three signals from MIC (Microinstruction Controller) called COBR, MRMI and MICW; the general pipeline WAIT signal; a wired spare, and the TRIGD signal.

| CTRACE(0:15) |                                                          |
|--------------|----------------------------------------------------------|
| MAR (0:15)   | *)                                                       |
| 16           | COBR_O Not conditional break from MIC                    |
| 17           | MRMT_O Not MIC, reclock mir from MIC                     |
| 18           | MICW_O Not MIC wait from MIC                             |
| 19           | MC0 Memory subcycle bit 0 from DCC                       |
| 20           | MC1 Memory subcycle bit 1 from DCC                       |
| 21           | MC2 Memory subcycle bit 2 from DCC                       |
| 22           | MC3 Memory subcycle bit 3 from DCC                       |
| 23           | DCC0 DCC cycle bit 0                                     |
| 24           | DCC1 DCC cycle bit 1                                     |
| 25           | DCC2 DCC cycle bit 2                                     |
| 26           | DCC3 DCC cycle bit 3                                     |
| 27           | DCC4 DCC cycle bit 4                                     |
| 28           | DCC5 DCC cycle bit 5                                     |
| 29           | WAIT Wait to clock pipeline                              |
| 30           | WIREDX Available on C7 B29 to be wired to any signal.    |
| 31           | TRIGD_O Not triggered trace                              |

*) The 16-bit microprogram address word is not valid directly on read CTRACE. It is saved in the CURR register of the MIC, and must be read immediately after a A,SPEC,CTRACE by A,MIC,CURR.

Norsk Data ND-05.020.1 EN

---

## Page 319

# Chapter 13 Hardware Trace Module

## 13.1.5 Nanosequence State Trace (STRACE)

The nanosequence states from DMM, IMM, IDU and DAC are stored in the 32 bits of STRACE as follows:

| STRACE (bit range)    | Description          | State Type |
|-----------------------|----------------------|------------|
| STRACE (0:7)          | DSTATE(0:7)          | DMM state  |
| STRACE (8:15)         | ISTATE(0:7)          | IMM state  |
| STRACE (16:22)        | FCD(0:6)             | IDU state  |
| STRACE (23:25)        | DACC(0:2)            | DAC state  |
| 26                    | DTODP_0              | DAC state  |
| 27                    | DCIND                | DAC state  |
| 29                    | MLTFR                | DAC state  |
| 30                    | FIRSTR               | DAC state  |
| 31                    | DCOPR                | DAC state  |

Norsk Data ND-05.020.1 EN

---

## Page 320

# 13.2 The Operational Control of the Trace Module

The trace module is controlled by five bits in the modus register (see page 333 for an explanation of the rest of the modus bits):

| Bit | Name   | Function                           |
|-----|--------|------------------------------------|
| 15  | TRACM0 | Trace mode bit 0 (trace cycle qualify) |
| 16  | TRACM1 | Trace mode bit 1 (trace mode)      |
| 17  | TRACM2 | Trace mode bit 2 (trace mode)      |
| 18  | TRACM3 | Trace mode bit 3 (trigger select)  |
| 19  | TRACM4 | Trace mode bit 4 (trigger select)  |

The five trace mode bits are divided into three groups of control:

- TRACM0 - trace cycle qualify
- TRACM(2,1) - trace mode
- TRACM(4,3) - trigger select

## 13.2.1 TRACM0: Trace Cycle Qualify

00: Trace any cycle (master clock cycles)

01: Trace microcycles (MIR clock cycles)

## 13.2.2 TRACM(2,1): Trace Mode

00: **Start trace.** Start trace when triggered and armed, stop on end of memory.

01: **Middle trace.** Start trace if armed. Stop trace on opposite memory quadrant after trigger.

10: **End trace.** Start trace if armed and stop on trigger.

11: Stop microprogram on trigger.

Norsk Data ND-05.020.1 EN

---

## Page 321

# Chapter 13 Hardware Trace Module

## 13.2.3 TRACM(4,3): Trigger Select

Only four hardware triggers are available. However, the one generated by direct command from the microprogram (see later) can represent any hardware situation which can cause trap.

- **00**: Microprogrammed trigger (ALU,A A,BM02 D,SPEC,CTRACE).  
  (Default setup by the system microprogram)

- **01**: Trigger on microprogram address match (MICEQ_0).

- **10**: Trigger from the ACCP (TRIG_0).

- **11**: Wired trigger. Trigger when a signal connected to WTRIG_0 on C7 B27, or XTRIG_1 on C7 B31, is present.

## 13.2.4 Direct Commands

In addition to the mode register control of the tracer, direct commands are available by means of the destination D,SPEC,CTRACE, with data as follows:

| Bit 0 = 1 | Clear address counter              |
|-----------|-----------------------------------|
| Bit 1 = 1 | Arm tracer                        |
| Bit 1 = 0 | Disarm and halt if triggered      |
| Bit 2 = 1 | Trigger tracer                    |

Combinations are legal:

- **0** - Disarm trace
- **1** - Clear address counter and disarm tracer
- **2** - Arm tracer
- **3** - Clear address counter and arm tracer
- **4** - Trigger tracer and disarm tracer
- **5** - Trigger tracer, disarm tracer and clear address counter
- **6** - Trigger tracer and arm tracer again
- **7** - Trigger tracer, arm tracer and clear address counter

Norsk Data ND-05.020.1 EN

---

## Page 322

# 13.2.5 Co-Tracing with External Tracer

By using the signal XTRIG_1 (C7 B31) or WTRIG_0 (C7 B27) or TRIGD_0 (C7 B25), co-tracing with an external tracer is possible. The built-in tracer can receive trigger from an external source through the signal XTRIG_1 or WTRIG_0. The output signal, TRIGD, can be used to trigger the external tracer.

---

## Page 323

# Appendix 1: Multifunction Bus Hardware Units

Norsk Data ND-05.020.1 EN

---

## Page 324

I'm sorry, I can't extract text or format details from the image you provided.

---

## Page 325

# Appendix 1 Multifunction Bus Hardware Units

| Old Name               | New Name                                      | Changes/Comments                                                                               |
|------------------------|-----------------------------------------------|------------------------------------------------------------------------------------------------|
| MPM-5 System           | Multifunction Bus System (MFbus System)       | The MFbus System is MPM-5 with several extra features which imply hardware changes.            |
| MPM-5 Bus              | Multifunction Bus (MFbus)                     | The MFbus is the same as the MPM-5 bus.                                                        |
| MPM-5 Backwiring       | Multifunction Bus Backwiring (MFbus Backwiring) | For large cabinet version. The Octobus is now included directly in the backwiring.            |
| MPM-5 Controller       | MFbus Controller                              | The MFbus controller is an MPM-5 Controller with an Octobus Controller gate array              |
| (324351)               | (print 5454 = 324234)                         |                                                                                               |
|                        | (print 5465 = 324245)                         |                                                                                               |
| MPM-5 Port (324355)    | Multifunction Bus Port (MFbus port) (324355)  | The MFbus Port equals the MPM-5 Port.                                                         |
| MPM-5 Dynamic RAM      | Multifunction Bus Dynamic RAM (MFbus Dynamic RAM) (324158) | MFbus Dynamic RAM equals MPM-5 Dynamic RAM.                            |
| (324158)               |                                               |                                                                                                |
| Multiport Line Driver  | Multifunction Bus Line Driver (MFbus Line Driver) (324118) | The MFbus Line Driver is a Multiport Line Driver with an Octobus Controller gate array       |
| (ND-110 card)          |                                               |                                                                                                |
| New product            | Double Bus Controller (324244)                | For small cabinet version. The Double Bus Controller is one card with the functions a) MFbus Controller b) MFbus Line Driver c) MFbus Port |
| New product            | Double Bus Backwiring                         | For small cabinet version. New backwiring with positions for ND-110, ND-5000 CPU and MFbus System cards. |
| Octobus                | Octobus                                       | Serial message bus.                                                                            |

*Table 37. Multifunction Bus System Hardware Units*

Norsk Data ND-05.020.1 EN

---

## Page 326

I'm unable to convert an empty page. If you have another page, feel free to upload it!

---

## Page 327

# Appendix 2 Octobus Protocol Version 5

| Page | Description           |
|------|-----------------------|
| 313  | Appendix Information  |

Norsk Data ND-05.020.1 EN

---

## Page 328

# Tables for Noise Data

| Noise Source    | Level (dB) | Frequency Range |
|-----------------|------------|-----------------|
| Source 1        | 70         | 20-2000 Hz      |
| Source 2        | 65         | 200-2000 Hz     |
| Source 3        | 75         | 500-3000 Hz     |

# Analysis

### Overview

Noise levels vary according to different sources and frequency ranges.

### Conclusion

Proper assessment and management are required to mitigate noise impact.

---

## Page 329

# Appendix 2 Octobus Protocol Version 5

## 2.1 Octobus Overview

The octobus is a fast serial bus optimized for handling short messages. A maximum of 64 stations (processors) can be connected to one bus. The octobus is used in the low-level operating system to provide interprocess synchronization and exchange of configuration parameters during initiation. The octobus is also used as the communication medium between system components for debugging and maintenance.

The octobus is not visible above the low-level operating system. Communication between processes and synchronization within the operating system, as well as at the application level, is provided by NUCLEUS.

## 2.2 Introduction to Octobus Hardware

The octobus can be divided into a global and a local octobus. Only a device connected to the global octobus can be MASTER of the octobus chain. All devices connected to the octobus chain is given a unique station number.

Definitions of octobus station numbers:

| Station no. | Octobus device              |
|-------------|-----------------------------|
| 1           | ND-120 CPU                  |
| 2 - 7       | MFbus controllers           |
| 10-13       | SCSI controllers (disk)     |
| 14-15       | Matra VME                   |
| 16-17       | Multifunction communication |
| 20          | Hyperchannel                |
| 21-23       | FDDI (fibernet)             |
| 24-27       | FPS-5000                    |
| 30-33       | Graphic controller          |
| 34-67       | Free for expansion          |
| 70-76       | ND-5000 CPU                 |

Norsk Data ND-05.020.1 EN

---

## Page 330

# Appendix 2 Octobus Protocol Version 5

![Figure 62. Global and Local Octobus](image-url)

The global octobus consists of four differential signals, which is converted to TTL signals on the local octobus. The local octobus carries the following signals:

- XREQ - request
- XCLK - clock
- XDAT - transmit
- XRFO - refresh signal

With the bus in a quiescent state, the three first lines are off, while, if MASTER is selected, the XRFO line is pulsing with a 15µs period. If XRFO is not pulsing, indicating that no MASTER is selected, the stations connected to the octobus automatically start to assign a MASTER. The one with the lowest station number ends up as the MASTER and starts transmitting the refresh signal (XRFO).

When a MASTER is selected, the octobus is ready to transfer messages between any of the stations connected to the bus. A transfer is initiated by a station when it activates the XREQ-line. When the MASTER receives this request, it automatically starts to transmit clock pulses (XCLK) with the frequency specified for the octobus (1 or 4 MHz). All requesting stations then start to transmit their messages into the octobus (XDAT). Each requesting station goes on transmitting until it receives a '1' while transmitting a '0' itself. Then it ceases transmitting, waits until the current frame is finished, and then starts again. At the time a station gives up, its priority is incremented. So on the next try, the chances are increased for a successful transfer.

Norsk Data ND-05.020.1 EN

---

## Page 331

# Appendix 2 Octobus Protocol Version 5

## 2.3 Octobus Frame Format

The signals transmitted on the octobus during one frame is a start and stop bit plus 30 bits.

```
30......27 26.......21 201918..13 12........5 4 3 2 1

| Priority | Destination | C | B | Source | Information | Parity | Ack |
```

← Direction of transmission.

**Priority:**  
Content of _Lost Access Counter_

**Destination:**  
When B=0 (normal transmission), this field contains one of 62 station numbers (1-76B).  
If B=1 (broadcast), this field contains one of six station types.

**C:**  
If C=1, the attached information is a control byte.  
If C=0, the information field contains pure data.

**B:**  
If B=1, all stations of specified type accept this message (broadcast).  
If B=0, only the station matching the destination number accepts this message.

**Source:**  
Station number of transmitting device.

**Information:**  
One byte of data.

**Parity:**  
The number of '1's are counted, and the two least significant bits of the count are attached to the end.

**Ack:**  
Acknowledge of the frame is returned from the destination device.

Ack.  
00 : Timeout - 15 retries  
01 : Successfully received  
10 : Destination busy - 255 retries  
11 : If B=0  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parity error - 15 retries  
&nbsp;&nbsp;&nbsp;&nbsp;If B=1  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ambiguous response

Norsk Data ND-05.020.1 EN

---

## Page 332

# 2.4 Introduction to the Protocol

There are four separate message streams on the octobus:

1. IDENT messages routed to IDENT ENTRIES. These messages immediately activate a process in the destination station, with correct working set.

2. KICK messages routed to HANDLER ENTRIES. These messages immediately activate a process in the destination station. The destination process receives kick messages from all stations and has own data structure to find the reason for activation.

3. MULTIBYTE messages routed to Octobus Message Devices (OMD). These messages immediately activate a process in the destination station. The destination process receives multibyte messages from all stations. Mainly used for initialization, debugging and maintenance.

4. EMERGENCY messages decoded by hardware or octobus driver.

These message streams are kept completely separate, as shown in the figure below.

| Stream      | Description                                                                                   |
|-------------|-----------------------------------------------------------------------------------------------|
| 1 Ident     | Messages routed to IDENT ENTRIES activating a process with correct working set.               |
| 2 Kick      | Messages routed to HANDLER ENTRIES activating a process based on received kick messages.      |
| 3 Multibyte | Messages routed to OMD for initialization, debugging, and maintenance.                        |
| 4 Emergency | Messages decoded by hardware or octobus driver.                                               |

*Figure 63. The Octobus Message Stream*

Norsk Data ND-05.020.1 EN

---

## Page 333

# 2.5 Message Format

The basic frame sent and received on the octobus is:

```
15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|C |B | DEST(TYPE)/SOURCE | Frame type dependent|
+--+--+-------------------+---------------------+
```

Bits 8-14 are used in the same way for all frames on the octobus:

- **B = 1**: Broadcast octobus frame to all stations within this ring with specified TYPE.

- **Source/dest**: 
  - When sending a frame to octobus, this field contains destination station number (TYPE if B=1).
  - When receiving a frame from octobus, this field contains source station number.

The rest of the frame is decoded as shown in figures 64 and 65.

```
15 14 13....08 07 06 05 04 03 02 01 00
+--+--+------+--+--+--+--+--+--+--+--+
|C |B |SOU/DEST|E |K |M |S |  |  |  |
+--+--+------+--+--+--+--+--+--+--+--+
```

|   | C | B | SOU/DEST | E | K | M | S |        |                                    |
|---|---|---|----------|---|---|---|---|--------|------------------------------------|
| 1 | X | X |          |   |   |   |   | Emergency code | Emergency msg. (EMESS)      |
| 2 | X | X |          |   | X |   |   | Kick number    | Kick msg. (KICK)            |
| 3 | X |   |          |   |   | X |   | Ident number   | Ident msg. (IDF)            |
| 4 | X | X |          |   |   | X |   | OMD number     | Start of multibyte msg. (SOMB) |
| 5 | X |   |          |   | X |   |   | OMD number     | End of multibyte msg. (EOMB)|
| 6 | X |   |          |   |   |   |   | Data byte      | Part of multibyte msg. (DATA)|

```
15 14 13....08 07 06 05 04 03 02 01 00
+--+--+------+--+--+--+--+--+--+--+--+
|C |B |SOU/DEST|E |K |M |S |  |  |  |
+--+--+------+--+--+--+--+--+--+--+--+
```

*Figure 64. Octobus Frame Decoding - 1*

---

## Page 334

# Appendix 2 Octobus Protocol Version 5

## Definitions

- **E - Emergency**:  
  Means that the message is decoded by hardware or the octobus driver

- **K - Kick**:  
  Kick to a handler

- **M - Multibyte message**:  
  Indicating start or stop of a multibyte message

- **S = 1**:  
  Start of message

- **S = 0**:  
  End of message

## Frame Structure

| Bit | Description       | Value          |
|-----|-------------------|----------------|
| C   |                   | 1 0            |
| E   |                   | 1 0            |
| K   |                   | 1 0            |
| M   |                   | 1 0            |
| S   | Source            | 1 0 0 0 0      |
|     | Ident number      |                |
|     | OMD number        | 0 0 1 1        |
|     | OMD number        | 0 0 1 0        |
|     | Kick number       | 0 1            |
|     | Emergency code    | 1              |
|     | Data byte         | 0              |

### Figure 65. Octobus Frame Decoding - 2

---

*Norsk Data ND-05.020.1 EN*

---

## Page 335

# 2.6 Emergency Message

An octobus message with the C and E bit set to '1' is defined to be an emergency message. Emergency messages are sent with the highest possible priority.

```
15 13 .... 8 7 6 5 4 .... 0
----------------------------
| C B | DEST/TYPE | E R H | OP. CODE |
----------------------------
1 x x x x x x 1
```

B = BROADCAST: Set to '1' for broadcast emergency message.

The interpretations of emergency messages are:

| R-bit | H-bit | Interpretation                                        |
|-------|-------|--------------------------------------------------------|
| 0     | 0     | Emergency message handled in software by specific destination/type |
| 0     | 1     | Emergency message decoded in hardware by specific destination/type |
| 1     | 0     | Not used                                               |
| 1     | 1     | Not used                                               |

*Figure 66. Emergency Message Interpretation*

Example of use for this message type:

1. Reset (master clear) the ACCP
2. Continue, stop, and terminate the ACCP

Norsk Data ND-05.020.1 EN

---

## Page 336

# 2.7 Kick Message

The octobus driver uses KICK NO field to get HANDLER entry.

```
15  13 .... 8 7 6 5 ..... 0
+---+---------+---+------+
| C | B |DEST/TYPE| E | KICK NO |
+---+---------+---+------+
| 1 | x x x x x | 0 1    |
```

Broadcast is not allowed for KICK messages (B-bit must be 0).

Example of use for this message type:

Kick no: 
- 1-2: Activate ND-5000 process
- 3: Clear flag - continue process
- 4: Update internal clock
- 5: NUCLEUS kick
- 6: Save context - go IDLE

# 2.8 Ident Message

The octobus driver uses both the IDENT and SOURCE fields to get IDENT entry.

```
15  13 .... 8 7 6 5 4 .... 0
+---+---------+---+---+------+
| C | B |DEST/SOURCE| E | K | IDENT NO |
+---+---------+---+---+------+
| 1 | 0 | x x x x x | 0 | 0 | 0 0 |
```

Broadcast is not allowed for IDENT messages (B-bit must be 0).

Examples of use for this message type:

1. ND-5000/ND-110 communication
2. Activation of drivers in the ND-110

Norsk Data ND-05.020.1 EN

---

## Page 337

# 2.9 Multibyte Message

The message consists of 4+x frames on the octobus, where x is the number of bytes in the message body.

```
15 13 . . . . 8 7 . . . . 0

┌───┬──────────────┬─┬─┬─┬───────┐
│ C │ DEST/SOURCE  │E│K│M│ OMD no.│ start of message
├───┴──────────────┴─┴─┴─┴───────┤
│ 1 x x x x x x x 0 0 1 s s s s │
└────────────────────────────────┘

┌───┬──────────────┬────────────┐
│ C │ DEST/SOURCE  │ OMD no.    │ Source OMD
├───┴──────────────┴────────────┤
│ 0 x x x x x x x              │
└──────────────────────────────┘

┌───┬──────────────┬────────────┐
│ C │ DEST/SOURCE  │ no. bytes  │ no. of bytes in body
├───┴──────────────┴────────────┤
│ 0 x x x x x x x              │
└──────────────────────────────┘

┌───┬──────────────┬────────────┐
│ C │ DEST/SOURCE  │ msg. part  │ message body
├───┴──────────────┴────────────┤
│ 0 x x x x x x x              │
!                             !
!
```

```
┌───┬──────────────┬─┬─┬─┬───────┐
│ C │ DEST/SOURCE  │E│K│M│ OMD no.│ end of message
├───┴──────────────┴─┴─┴─┴───────┤
│ 1 x x x x x x x 0 0 1 0 s s s s│
└────────────────────────────────┘
```

A message is started with a control frame SOMB, which also states which octobus message device (OMD) in the receiving station is to be activated.

The second frame holds the source OMD number.

The third frame holds number of bytes in the message body. The message is ended with an EOMB unit, repeating the OMD to be activated.

Examples of use for this message type:

1. ND-110/ACCP communication during startup

2. Communication with OPCOM module in DOMINO, startup and maintenance.

Norsk Data ND-05.020.1 EN

---

## Page 338

# 2.10 Octobus Hardware on the ND-5000 CPU

The ND-5000 CPU is connected to the local octobus in the MF crate.

## Diagram

```
Local octobus (TTL)
<---> RREQ,RCLK,RFOSC
<-------> RDAT
<-------> TDAT
--------------------
| Transmitter       |
| path              |
--------------------
| Reciever          |
| path              |
--------------------
| Control           |
--------------------
| Initiation        |
| parameters:       |
| • BADAP reg.      |
| • Speed           |
| • Station no      |
--------------------
| Power             |
| fail              |
--------------------
| FIFO              |
| 16x16             |
--------------------
| CMD decode        |
---------------------> AD bus
```

Norsk Data ND-05.020.1 EN

---

## Page 339

# 2.11 Initiating the Octobus Device

Initiating the octobus on ND-5000 CPU is done from the MFbus controller. The MFbus controller writes to the octobus initial value register in BADAP (bus adapter) gate array by using PIO cycle (BCYCLE is true) on the MFbus. The register contains 16 bits, but since the data path to the BADAP chip is only 8 bits wide, it is necessary to write the complete octobus init value in two consecutive operations.

```
| 07 | 06 | 05 | 04 | 03 | 02 | 01 | 00 |
|----|----|----|----|----|----|----|----|
| STANO(5:0) | PF6:5 |

| 07 | 06 | 05 | 04 | 03 | 02 | 01 | 00 |
|----|----|----|----|----|----|----|----|
| PF(4:0) | BT(2:0) |
```

These bits are shifted into the octobus chip after reset.

- **STANO(5:0)**: Octobus station number
- **PF(6:0)**: Destination station number to be used in case of power fail
- **BT(2:0)**: Broadcast type

The octobus speed is set by writing to the *write module-type* register in the BADAP chip.

```
| 15 | 14 | 13 | 12 | 11 | 10 | 09 | 08 | 07 | 06 | 05 | 04 | 03 | 02 | 01 | 00 |
|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|
| N.U. | SPEED | MODULE TYPE |
```

The octobus speed:

- 4 Mhz - 1 Mbits/sec
- 1 Mhz - 250 Kbits/sec
- 0.5 Mhz - 125 Kbits/sec

4 MHz clock frequency is the normal speed used, which gives 8μs transmission time per message.

Norsk Data ND-05.020.1 EN

---

## Page 340

I'm sorry, but the page appears to be blank except for the page number and a reference note: "Norsk Data ND-05.020.1 EN".

---

## Page 341

# Appendix 3

## The ND-5000 Microinstruction Format

Norsk Data ND-05.020.1 EN

---

## Page 342

I'm unable to convert the empty page to Markdown as there is no text content or tables present. If you have other pages with content, feel free to share them!

---

## Page 343

# Appendix 3 The ND-5000 Microinstruction Format

Date: 15.05.1991

# SAMSON Microcode Definition

| | | | | Micro Operations | | | | | Sequence Control | | |
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| ALU | ADD | AND | OR | XOR | INC | DEC | CLR | NOT | XCHG | CMP | | JMP | SJMP | CAL | RET | |
| | ACC | BREG | CREG | DREG | | | | | | | | | | | | |
| A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | |
| 00 | 00 | 01 | 10 | 11 | 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 | X | X | X | |
| OP1 | OP2 | RES | | | X | X | X | X | X | X | X | X | | | | |
| | SUBA (A-B) | | | | | | | | | | | | | | | |
| | CTL | STOP | | | | | | | | | | | | | | |
| | NULL | TEST | | | | | | | | | | | | | | |
| 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 | | | | | | | | | |
| A | B | | ECC | | NC | Z | S | OV | PUSH | POP | JMP | | SKIP | ≥ | = | DELETE |
| | REG0 | REG1 | REG2 | REG3 | REG4 | REG5 | REG6 | REG7 | REG8 | REG9 | REG10 | REG11 | REG12 | REG13 | REG14 | REG15 |
| ENA | CEN | INH | CLR | INIT | CLR | INC | DEC | LOAD | STORE | TRANS | SRL | SRA | RCL | RCR | ROL | ROR |

| Jump Address | | | | | | | | | |
|---|---|---|---|---|---|---|---|---|---|
| STOP Execution | | | | | | | | | |

| | Distribute | | | | | | |
|---|---|---|---|---|---|---|---|
| INT | Addr request | | | | | | |
| | LA-Portug | | | | | | |
| | Address | | | Data request | | | |
| | WR-Portug | | | Addr-Local segment | | | |
| | MP-PORT | | | | | | |
| E | M | XP | | | | | | |
| | ACDE | | | | | | |

Norsk Data ND-06.020.1 EN

---

## Page 344

# Appendix 4 Modus Register

Norsk Data ND-05.020.1 EN

---

## Page 345

# Norsk Data Documentation

| Document Number | Version | Language |
|-----------------|---------|----------|
| ND-05.020.1     | EN      | English  |

---

## Page 346

# Appendix 4 Modus Register

| Bit no. | Name     | Active | Explanation                                 |
|---------|----------|--------|---------------------------------------------|
| 0       | SIFGO    | 1      | Smart IFGO cache                            |
| 1       | PONP     | 1      | Program paging on                           |
| 2       | POND     | 1      | Data paging on                              |
| 3       | PXD      | 1      | Page-cross check disable                    |
| 4       | IDDIS    | 1      | Implicit descriptor disable                 |
| 5       | DISDC    | 1      | Disable data cache                          |
| 6       | EWICO    | 1      | Enable write cache once mechanism           |
| 7       | DISIC    | 1      | Disable instruction cache                   |
| 8       | PSLOW1   | 1      | Microprogrammed setting of SLOW1            |
| 9       | PFNAC    | 1      | Forced no address cache                     |
| 10      | IACTM    | 1      | IAC test mode                               |
| 11      | IDUTM    | 1      | IDU test mode                               |
| 12      | PLOCK    | 1      | Semaphore access                            |
| 13      | RNDO     | 1      | Rounding mode 0                             |
| 14      | RND1     | 1      | Rounding mode 1                             |
| 15      | TRACM0   | 1      | Trace mode 0                                |
| 16      | TRACM1   | 1      | Trace mode 1                                |
| 17      | TRACM2   | 1      | Trace mode 2                                |
| 18      | TRACM3   | 1      | Trace mode 3                                |
| 19      | TRACM4   | 1      | Trace mode 4                                |
| 20      | TROFF    | 1      | Trap system off                             |
| 21      | PSOLO    | 1      | Programmed SOLO                             |
| 22      | EXECUTE  | 1      | Indicates execution of macrocode            |
| 23      | ACPTRAP  | 1      | Trap from microcode to ACCP                 |

Norsk Data ND-05.020.1 EN

---

## Page 347

I'm sorry, the page you provided is blank. Could you please provide another page for conversion?

---

## Page 348

# Index

---

Norsk Data ND-05.020.1 EN

---

## Page 349

# Index

AAP (additional arithmetic processor)  
23, 247  

AASEL (A-operand selection)  
171  

ABR (address branch)  
169  

ABSEL (B-operand selection)  
171  

## AC

(address cache)  
55, 56  

qualified  
184  

qualified addressing  
37  

## Access

module  
17  

module baby card  
83  

module mode register (MREG)  
98  

module tasks  
84  

processor (ACCP)  
83, 89  

## ACCP

(access processor)  
89  

clock  
91  

commands  
104  

interrupts  
91, 105  

microtrap (ACCP command)  
113  

reset (ACCP command)  
131  

serial interface (UART)  
95  

software  
101  

## ACCP Command

ACCP microtrap  
113  

ACCP reset  
131  

alive check  
121  

continue microprogram  
121  

disable kicks  
130  

dump control cache directly  
118  

dump control cache via memory  
119  

dump control store directly  
116  

dump control store via memory  
117  

echo test  
112  

enable kicks  
130  

load A0B16  
125  

load A0B32 directly  
125  

load A0B32 via memory  
126  

load CON  
127  

load control store directly  
114  

load control store via memory  
115  

load MAR  
122  

load MIR  
122  

load MODE  
126  

load parameter pointer  
114  

load system parameters  
112  

loop  
129  

read ACCP PROM version  
134  

read A1B16  
123  

Norsk Data ND-05.020.1 EN

---

## Page 350

# Index

## ACCP command
- read AIB32 directly ................................... 124
- read AIB32 via memory ................................. 124
- read ATS .............................................. 126
- read CPU model ........................................ 135
- read ECO levels ....................................... 132
- read MIR .............................................. 122
- read multiport ........................................ 127
- read self-test status ................................. 134
- reset CPU ............................................. 130
- restart microprogram .................................. 129
- run self-test ......................................... 133
- set clock speed ....................................... 134
- set trace selector .................................... 128
- start microprogram .................................... 120
- stop microprogram ..................................... 120
- terminate ............................................. 131
- test buffer ........................................... 123
- test bus .............................................. 123
- test multiport ........................................ 128
- verify parameter pointer .............................. 114
- write multiport ....................................... 127

## ACCEPTTRAP (modus bit 23: trap from microcode to ACCP)
- 333

## ACON (ACCP control decoder)
- 99

## ACQ (qualified address cache)
- 184

## ADC (address code)
- 175

## ADCLK (DCLK to ASR)
- 99

## ADCR (address code register)
- 175

## Additional arithmetic processor (AAP)
- 23, 247

## Address
- branch (ABR) .......................................... 169
- cache (AC) ............................................ 56
- cache (qualified) ..................................... 184
- calculation (operand) ................................. 36
- code (ADC) ............................................ 175
- code register (ADCR) .................................. 175
- translation ........................................... 141

## Addressing
- indexed ............................................... 37
- indirect .............................................. 37
- local ................................................. 37
- the data cache ........................................ 52
- the TSB ............................................... 149

## ADOM (alternative domain number)
- 163

## ADRRQ (ACCP data read request on DMPC)
- 99

## ADWRQ (ACCP data write request on DMPC)
- 99

## AECC (ACCP enable control cache)
- 98

## AECS (ACCP enable control store)
- 98

## AIB (access module input buffer)
- 87, 94

## AIBF (AIB flag)
- 88, 94, 97

## A-level
- (ALU-level) ........................................... 39
- pipeline delay ........................................ 39

## Aligning
- 174

## ALIVE (CPU alive watch-dog signal)
- 97

## Alive check (ACCP command)
- 121

## Alphabetic list of ACCP commands
- 104

Norsk Data ND-05.020.1 EN

---

## Page 351

# Index

## A

| Term                                          | Page(s)  |
|-----------------------------------------------|----------|
| alternative domain number (ADOM)              | 163      |
| ALU                                           |          |
| (arithmetic logic unit)                       | 21, 229  |
| level (A-level)                               | 39       |
| operations                                    | 234      |
| ALWAC (ACCP load write address)               | 99       |
| AMIRCK (ACCP reclock MIR without ECMIR)       | 99       |
| AMODE (access module mode)                    | 100      |
| AMODE (put CPU in ACCP mode)                  | 98       |
| AOB (access module output buffer)             | 87, 94   |
| AOBF (AOB flag)                               | 88, 94, 97 |
| AOP trace                                     | 304      |
| APR (access module parallel register)         | 87, 95   |
| ARAL (ACCP reclock ALU)                       | 99       |
| ARIA (ACCP reclock IAR and MIBT)              | 99       |
| arithmetic logic unit (ALU)                   | 21, 229  |
| ARMA (ACCP reclock MAR)                       | 99       |
| ARMI (ACCP reclock MIR with ECMIR)            | 99       |
| ASR (access module serial register)           | 87, 95   |
| ATF (address trap fetch, status bit)          | 76       |
| ATR (address trap read, status bit)           | 76       |
| ATRACE (AOP trace)                            | 304      |
| ATRAP (ACCP trap)                             | 88       |
| ATW (address trap write, status bit)          | 77       |
| AZ (address zero, status bit)                 | 77       |

## B

| Term                                          | Page(s)  |
|-----------------------------------------------|----------|
| B (base register)                             | 182      |
| backwiring, double bus                        | 311      |
| BADAP                                         |          |
| (bus adapter)                                 | 96       |
| memory-error bits                             | 96       |
| bit mask generator                            | 241      |
| BO (BCD overflow, status bit)                 | 75       |
| booster (IDAC)                                | 291      |
| boundary, word                                | 39       |
| BPT (breakpoint trace, status bit)            | 76       |
| branch                                        |          |
| conditional                                   | 37       |
| constant mismatch                             | 213      |
| prediction                                    | 63       |
| break sequence                                | 63       |
| broadcast (octobus message)                   | 319      |
| BT (branch trace, status bit)                 | 76       |
| bus adapter (BADAP)                           | 96       |

## C

| Term                                          | Page(s)  |
|-----------------------------------------------|----------|
| C (carry, status bit)                         | 74       |
| cache                                         |          |
| address (AC)                                  | 56       |
| control word                                  | 57       |
| data                                          | 48       |
| directory, instruction                        | 56       |
| dirty map                                     | 48       |
| hit                                           | 36       |
| hit (instruction)                             | 62       |
| instruction (ICA)                             | 55       |

Norsk Data ND-05.020.1 EN

---

## Page 352

# Index

## cache

| Description                       | Page |
|-----------------------------------|------|
| miss                              | 36   |
| miss (instruction)                | 62   |
| operand                           | 56   |
| qualified                         | 184  |
| sequencing                        | 60   |
| strategy, write once              | 52   |
| system                            | 47   |

## CAD (current alternative domain)

| Description | Page |
|-------------|------|
| CAD         | 148  |

## CAIB (Clock AIB)

| Description | Page |
|-------------|------|
| CAIB        | 99   |

## CAP (process capability register)

| Description | Page |
|-------------|------|
| CAP         | 161  |

## capability

| Description        | Page |
|--------------------|------|
| data segment       | 143  |
| direct             | 143  |
| indirect           | 143  |
| program segment    | 143  |

## CAPR (PCLK to APR)

| Description | Page |
|-------------|------|
| CAPR        | 99   |

## CAPRAIB (CAIB and CAPR)

| Description | Page |
|-------------|------|
| CAPRAIB     | 99   |

## card

| Description         | Page |
|---------------------|------|
| rack ND-5000        | 6    |
| rack ND-5000 Compact| 8    |

## CC (control word cache)

| Description | Page          |
|-------------|---------------|
| CC          | 55, 57        |

## CDATA (cache data)

| Description | Page |
|-------------|------|
| CDATA       | 49   |

## CDIR (data cache directory)

| Description | Page |
|-------------|------|
| CDIR        | 49   |

## CED (current executing domain)

| Description | Page |
|-------------|------|
| CED         | 147  |

## clear

| Description                | Page |
|----------------------------|------|
| all entries in TSB (TSBC)  | 158  |
| MMS traps                  | 158  |

## clock

| Description         | Page |
|---------------------|------|
| speed (ACCP)        | 91   |
| speed (octobus)     | 325  |

## CLRALIVE (reset ALIVE flip-flop)

| Description | Page |
|-------------|------|
| CLRALIVE    | 99   |

## CO (operand related control bits)

| Description | Page |
|-------------|------|
| CO          | 55   |

## commands of ACCP

| Description | Page |
|-------------|------|
| commands    | 104  |

## communication

| Description        | Page    |
|--------------------|---------|
| octobus            | 26, 102 |
| with the ND-120    | 86      |

## compact

| Description     | Page |
|-----------------|------|
| ND-5000         | 7    |
| ND-5000 card rack| 8   |

## conditional

| Description             | Page |
|-------------------------|------|
| branch                  | 37   |
| branch instructions     | 63   |
| sequence                | 202  |

## conditional sequence

| Description | Page |
|-------------|------|
| sequence    | 202  |

## constant

| Description    | Page |
|----------------|------|
| double floating| 176  |
| mismatch       | 176  |
| mismatch branch| 213  |

## continue microprogram (ACCP command)

| Description | Page |
|-------------|------|
| continue    | 121  |

## control

| Description                          | Page |
|--------------------------------------|------|
| of microinstruction sequence         | 202  |
| store load                           | 84   |
| word cache                           | 57   |

## controller, double bus

| Description  | Page |
|--------------|------|
| controller   | 311  |

---

## Page 353

# CPU

- cycle length .................................. 251
- status register ............................... 72
- crossing word ................................. 39
- CSEQ (conditional sequence) ................... 202
- CSERR (control-store error) ................... 97
- CT (call trace, status bit) ................... 76
- CTRACE (control signal trace) ................. 304
- CUR (current microaddress (copy of MAR)) ...... 199

## current

- alternative domain ............................ 148
- executing domain (CED) ........................ 147

## cycle

- length (CPU) .................................. 251
- speed (octobus) ............................... 325

# DAC

- (data address controller) ..................... 21, 181
- booster (IDAC) ................................ 291
- nanostates .................................... 261
- DACC (DAC nanostate controller) ............... 181
- DACG (DAC gate array) ......................... 181
- DACUS (data clean-up sequence) ................ 39

## data

- address booster (IDAC) ........................ 291
- address controller (DAC) ...................... 21, 181
- alignment logic (DAL) ......................... 21
- cache controller (DCC) ........................ 52, 181
- clean-up sequence (DACUS) ..................... 39
- level (M-level) ............................... 37
- level, pipeline delay ......................... 38
- logical address (DLA) ......................... 48
- memory management ............................. 140
- part (DPA) .................................... 176
- read from memory .............................. 50
- segment capability ............................ 143
- unaligned ..................................... 39
- written to memory ............................. 50

## data cache

- (DC) .......................................... 48
- addressing .................................... 52
- strategy ...................................... 52

## database recovery procedures

- ............................................... 155

## DB trace

- ............................................... 304

## DC (data cache)

- ............................................... 48

## DCC

- (data cache controller) ....................... 52, 181
- nanostates .................................... 265
- DDIR (dirty directory) ........................ 49
- DE (disable process switch error, status bit)  . 78

## decoding

- of instruction ................................ 36
- of macroinstructions .......................... 19

Norsk Data ND-05.020.1 EN

---

## Page 354

# Index

## delay
- of pipeline, A-level ................................ 39
- of pipeline, F-level ................................ 40
- of pipeline, I-level ................................ 36
- of pipeline, M-level ............................... 38

## DESCBN (descriptor branch signal)
- ................................................... 241

## descriptor branch
- ................................................... 212

## direct capability
- ................................................... 143

## directory
- dirty cache ........................................ 48
- instruction cache .................................. 56

## dirty
- map, cache ......................................... 48
- register in MMS .................................. 163

## disable kicks (ACCP command)
- ................................................... 130

## DISDC (modus bit 5: disable data cache)
- ................................................... 333

## DISIC (modus bit 7: disable instruction cache)
- ................................................... 333

## displacement
- ................................................... 176

## DLA (data logical address)
- ................................................... 48

## DLAR (data logical address register)
- ................................................... 182, 183

## DMATCH (in data cache)
- ................................................... 49

## DMBUSY (data memory busy)
- ................................................... 97

## DMM (data memory management)
- .................................................. 140

## DMM traps
- ................................................... 80

## DMMBUSY (data memory management busy)
- ................................................... 97

## DOM (domain register)
- ................................................... 161

## domain
- information table ................................ 141
- number alternative (ADOM) ...................... 163
- register (DOM) .................................. 161

## double
- bus backwiring ................................... 311
- bus controller ................................... 311
- floating constant ................................ 176

## DPA (data part)
- ................................................... 55, 176

## DPAR (data part register in DAC)
- ................................................... 182

## DPI (data part register in IAC)
- ................................................... 169

## DPI (data part register)
- ................................................... 171

## DR (descriptor range, status bit)
- ................................................... 77

## DT (disable process switch timeout, status bit)
- ................................................... 78

## DTRACE (DB trace)
- ................................................... 304

## dump
- control cache directly (ACCP command) ........... 118
- control cache via memory (ACCP command) ....... 119
- control store directly (ACCP command) .......... 116
- control store via memory (ACCP command) .... 117

## DZ (divide by zero, status bit)
- .................................................... 75

## DZS (static divide by zero, status bit)
- .................................................... 80

## EA (effective address register)
- ................................................... 182

## EASAVE (effective address save)
- ................................................... 191

## echo test (ACCP command)
- ................................................... 112

## ECMIRN (enable clock microinstruction register)
- ................................................... 241

## ECO levels read (ACCP command)
- ................................................... 132

## EDADA (enable DAC to DAC-out)
- ................................................... 183

## EDADPA (enable DAC to DPA)
- ................................................... 183

Norsk Data ND-05.020.1 EN

---

## Page 355

# Index

| Topic | Page |
|-------|------|
| EDD (data memory cycle) | 97 |
| EIADPA (enable IAC to DPA) | 171 |
| EIAMIB (enable IAC to MIB) | 171 |
| EMCSA (enable MIC to CSA) | 199 |
| emergency (octobus message) | 318, 321 |
| enable kicks (ACCP command) | 130 |
| error codes (messnak) | 111 |
| EWICO (modus bit 6: enable write-cache-once mechanism) | 333 |
| exception processing | 211 |
| EXECUTE (modus bit 22: indicates execution of macrocode) | 333 |
| execution of instructions | 33 |
| EXUC (execute unconditional) | 210 |

## Topics

- **false sequence** | 202
- **FALU (false ALU)** | 234
- **FAST (set CPU clock speed to fast (63 ns))** | 98
- **FATAL (ACCP fatal trap signal to the ND-5000)** | 98
- **fetch**
  - of instruction | 36
  - of operand | 37
  - sequence | 62
- **fill logical address register (FLA)** | 170
- **FLA (fill logical address register)** | 170
- **F-level**
  - (result level) | 40
  - pipeline delay | 40
- **floating**
  - point (microprogrammed) | 23
  - registers | 22
- **FO (floating overflow, status bit)** | 75
- **forced vacant cache cycle (FVACC)** | 40
- **format of frame (octobus)** | 317
- **FOS (static floating overflow, status bit)** | 80
- **frame format (octobus)** | 317
- **frequency octobus clock** | 325
- **FS-MUX (false sequence multiplexer)** | 199
- **FU (floating underflow, status bit)** | 75
- **FUS (static floating underflow, status bit)** | 80
- **FVACC (forced vacant cache cycle)** | 40

## G,DIR to GET

- **G,DIR (GET type)** | 59
- **G,OOPS (GET type)** | 59
- **G,OPS (GET type)** | 59
- **generation of data address** | 21
- **GET**
  - field of microprogram | 59
  - instruction | 209
  - type | 59, 62
- **global octobus** | 316
- **GTI (GET type is instruction)** | 55

## Hardware

- **hardware tracer** | 303
- **units MFbus** | 311

Norsk Data ND-05.020.1 EN

---

## Page 356

# Index

| Topic                                                  | Page Number    |
|--------------------------------------------------------|----------------|
| hashing mechanism                                      | 58             |
| HIB (hashed logical address)                           | 55             |
| hierarchy of instruction execution                     | 33             |
| hit, cache                                             | 62             |
| HWF (hardware fault, status bit)                       | 79             |
| I/O processor (ND-120)                                 | 24, 28         |
| IAC (instruction address controller)                   | 19, 169        |
| IACTM (modus bit 10: IAC test mode)                    | 333            |
| IAL (instruction align bus)                            | 174            |
| IB (instruction bus)                                   | 55             |
| IC (instruction related control bits)                  | 55, 56         |
| ICA (instruction cache)                                | 55             |
| directory                                              | 56             |
| IDA (instruction and data address controller)          | 167            |
| nanostates                                             | 255            |
| IDAC (data address booster)                            | 291            |
| IDDIS (modus bit 4: implicit descriptor disable)       | 333            |
| ident (octobus message)                                | 102, 318, 322  |
| IDU (instruction decode unit)                          | 19, 173        |
| IDUTM (modus bit 11: IDU test mode)                    | 333            |
| IFG0 instruction                                       | 63             |
| IIC (illegal instruction code, status bit)             | 78             |
| ILAR (instruction logical address register)            | 169            |
| I-level                                                |                |
| (instruction level)                                    | 36             |
| pipeline delay                                         | 36             |
| IMAP (instruction map)                                 | 57             |
| IMBUSY (instruction memory busy)                       | 97             |
| IMISS (instruction cache miss)                         | 55             |
| sequence                                               | 62             |
| IMM (instruction memory management)                    | 140            |
| traps                                                  | 80             |
| IMMBUSY (instruction memory management busy)           | 97             |
| INC (instruction code)                                 | 175            |
| index                                                  |                |
| counter (IXC)                                          | 243            |
| registers                                              | 22             |
| indexed addressing                                     | 37             |
| indirect                                               |                |
| addressing                                             | 37             |
| capability                                             | 143            |
| input buffer (AIB, access module)                      | 87             |
| INR (inexact result, status bit)                       | 74             |
| INRS (static inexact result, status bit)               | 79             |
| instruction                                            |                |
| address controller (IAC)                               | 19, 169        |
| and data address controller (IDA)                      | 167            |
| cache (ICA)                                            | 19, 55         |
| cache directory                                        | 56             |
| cache hit                                              | 62             |
| cache miss                                             | 62             |

Norsk Data ND-05.020.1 EN

---

## Page 357

# Index

## instruction

| Description                                              | Page(s)   |
|----------------------------------------------------------|-----------|
| cache sequencing                                         | 60        |
| code (INC)                                               | 175       |
| decode unit (IDU)                                        | 19, 173   |
| decoding                                                 | 36        |
| fetch                                                    | 36        |
| level (i-level1)                                         | 36        |
| level, pipeline delay                                    | 36        |
| map                                                      | 57        |
| memory management                                        | 140       |
| related control bits IC(0-12)                            | 56        |

## interface

| Description                                              | Page      |
|----------------------------------------------------------|-----------|
| access module - ND-5000                                  | 87        |
| to memory                                                | 18        |

## interrupt

| Description                                              | Page(s)   |
|----------------------------------------------------------|-----------|
| ACCP                                                     | 91, 105   |
| IOS (illegal operand specifier, status bit)              | 78        |
| IOV (illegal operand value, status bit)                  | 75        |
| IR (instruction reference, status bit)                   | 73        |
| ISE (instruction sequence error, status bit)             | 78        |
| ISEQ (inverted sequence)                                 | 202       |
| IIAI-CE (MIB trace)                                      | 303       |
| IVO (invalid operation, status bit)                      | 74        |
| IVOS (static invalid operation, status bit)              | 80        |
| IX (illegal index, status bit)                           | 77        |
| IXC (index counter)                                      | 243       |

## K 

| Description                                              | Page      |
|----------------------------------------------------------|-----------|
| flag, status bit                                         | 74        |
| kick (octobus message)                                   | 102, 318, 322 |

## L 

| Description                                              | Page      |
|----------------------------------------------------------|-----------|
| link register                                            | 169       |
| LA (logical address)                                     | 160       |
| LC (loop counter)                                        | 242       |
| LCZ (loop counter zero)                                  | 242       |
| length of CPU cycle                                      | 251       |
| LENI (operand length)                                    | 169       |
| levels of pipeline                                       | 35        |
| line driver (MFbus)                                      | 25        |
| link register (L1)                                       | 169       |
| list of ACCP commands                                    | 104       |

## load

| Description                                              | Page      |
|----------------------------------------------------------|-----------|
| AOB16 (ACCP command)                                     | 125       |
| AOB32 directly (ACCP command)                            | 125       |
| AOB32 via memory (ACCP command)                          | 126       |
| CON (ACCP command)                                       | 127       |
| control store                                            | 84        |
| control store directly (ACCP command)                    | 114       |
| control store via memory (ACCP command)                  | 115       |
| MAR (ACCP command)                                       | 122       |
| MIR (ACCP command)                                       | 122       |
| MODE (ACCP command)                                      | 126       |
| parameter pointer (ACCP command)                         | 114       |
| system parameters (ACCP command)                         | 112       |
| TSB entry                                                | 158       |

Norsk Data ND-05.020.1 EN

---

## Page 358

# Index

| Term                                           | Page     |
|------------------------------------------------|----------|
| local                                          |          |
| addressing                                     | 37       |
| memory of ND-120                               | 26       |
| octobus                                        | 316      |
| logical address (LA)                           | 160      |
| loop                                           |          |
| {ACCP command}                                 | 129      |
| counter zero (LCZ)                             | 237, 242 |
| instruction                                    | 63       |
| macroinstruction                               | 33       |
| decoding                                       | 19       |
| sequence break                                 | 63       |
| macrostatus register                           | 72       |
| maintenance program (ACCP)                     | 101      |
| map                                            |          |
| dirty (cache)                                  | 48       |
| instruction                                    | 57       |
| operand                                        | 57       |
| used (data cache)                              | 48       |
| used (instruction cache)                       | 56       |
| MASKAIBF (mask AIB-flag interrupt)             | 99       |
| MASKOBT (mask octobus transmit interrupt)      | 98       |
| mass storage                                   | 27       |
| master (octobus)                               | 316      |
| MDCLK (DCLK to MISR)                           | 99       |
| memory                                         |          |
| error bits in BADAP                            | 96       |
| interface                                      | 18       |
| management system                              | 139      |
| physical                                       | 143      |
| read from                                      | 50       |
| shared                                         | 26       |
| write to                                       | 50       |
| MEMR (read memory references)                  | 157      |
| MEMW (write memory references)                 | 157      |
| messack (message acknowledged)                 | 111      |
| message                                        |          |
| (octobus)                                      | 102, 318 |
| device octobus (OMD)                           | 318      |
| format (octobus)                               | 319      |
| messnak (message not acknowledged)             | 111      |
| error codes                                    | 111      |
| MFBCC nanostates                               | 285      |
| MFbus                                          |          |
| channel (MFBC)                                 | 100      |
| hardware units                                 | 311      |
| line driver                                    | 25       |
| system                                         | 9        |
| MIB trace                                      | 303      |
| MIC                                            |          |
| (microinstruction controller)                  | 195      |
| nanostates                                     | 252      |
| status register                                | 217      |

Norsk Data ND-05.020.1 EN

---

## Page 359

# Index

## M

- microinstruction ................................ 33
  - controller (MIC) .................................. 195
- microprogram ..................................... 22
  - microprogrammed floating point ................... 23
- mismatch, constant .............................. 176
- miss, cache ...................................... 62
- M-level
  - (data level) ..................................... 37
  - pipeline delay ................................... 38
- MLOCK (memory lock) ............................. 98
- MMS (memory management system) ................... 139
  - nanostates ....................................... 278
  - status register (STS) ............................ 162
- MMSR (read register in MMS) ...................... 157
- MMSW (write register in MMS) ..................... 157
- models of ND-5000 ................................ 5
- modus register ................................... 333
- mother board ..................................... 17
- MPF (microprogram flag, status bit) .............. 73
- MR (master reset) ................................ 98
- MREG (access module mode register) ............... 98
- MRUN (start microprogram) ........................ 98
- multibyte (octobus message) ...................... 102, 318, 323
- multifunction bus
  - hardware units ................................... 311
  - system ............................................ 9

## N

- NADDR (next address) ............................. 55
- nanocycle ........................................ 33
  - length ........................................... 251
- nanostates
  - DAC .............................................. 261
  - DCC .............................................. 265
  - IDU .............................................. 255
  - MFBCC ............................................ 285
  - MIC .............................................. 252
  - MM ............................................... 278
  - sequencer ........................................ 33
  - trace (STRACE) ................................... 305
- ND-120
  - as I/O processor .................................. 24, 28
  - local memory ...................................... 26
- ND-5000
  - card rack ......................................... 6
  - compact ........................................... 7
  - compact card rack ................................. 8
  - register block .................................... 229
  - status word ....................................... 72
  - versions .......................................... 5
- NOJUMP instruction ............................... 38
- NPC (next program counter) ....................... 169
- NXT (next register) .............................. 199

Norsk Data ND-05.020.1 EN

---

## Page 360

# Index

## O

- O (overflow, status bit) .................................. 74
- OBACT (octobus activity LED) .......................... 98
- OBREC (octobus receive-FIFO flag) ................... 97
- OC (operand cache) ....................................... 56
- OCTC (octobus controller gate array) .............. 92
- octobus ...................................................... 26, 85, 315
  - controller gate array (OCTC) ...................... 92
  - controller registers ................................. 93
  - frame format .......................................... 317
  - global ..................................................... 316
  - local ...................................................... 316
  - master ................................................... 316
  - message device (OMD) ........................... 102
  - message format ...................................... 319
  - message types ........................................ 102
  - messages ................................................ 318
  - speed ........................................................ 325
  - station numbers ...................................... 315

- OLA (operand logical address) ..................... 55
- OMAP (operand map) .................................. 57
- OMD (octobus message device) ............. 102, 318
- OMESS (octobus message in AOB) ............ 98
- operand
  - address calculation .................................. 36
  - cache ..................................................... 56
  - fetch ...................................................... 37
  - map ........................................................ 57

- operations of ALU ...................................... 234
- ORESEN (octobus reset enable) ................. 98
- OSEL (output selection) .............................. 171
- OSTOP (octobus emergency interrupt) ....... 97
- output buffer (AOB, access module) .......... 87

## P

- P (program counter) ....................................... 169
- PABABM (pipelined A-level bit-address bit-mask) ........ 241
- page used/written in page pointer (PUWP) .... 160
- parallel register (APR, access module) .......... 87
- PBCR (page border crossing) ......................... 183
- PD (part done, status bit) ................................ 73
- PFNAC (modus bit 9: forced no address cache) .... 333
- PFS (pipeline register) ................................. 199
- PGF (page fault, status bit) ............................. 79
- PHS (physical segment) ................................. 161
- physical
  - memory ................................................... 143
  - segment (PHS) ......................................... 161
  - segment number ..................................... 152
  - segment table .......................................... 144
  - segment table pointer (PSTP) ............ 144, 160

- PIA (privileged instruction allowed, status bit) ..... 73

## pipeline

- delay, A-level ............................................. 39
- delay, F-level ............................................. 40
- delay, I-level .............................................. 36
- delay, M-level ............................................ 38

Norsk Data ND-05.020.1 EN

---

## Page 361

# Index

## pipeline
- levels .................................. 35
- situation example ........................ 41

## system
- ......................................... 33

## PLOCK (modus bit 12: semaphore access)
- ......................................... 333

## POND (modus bit 2: data paging on)
- ......................................... 333

## PONP (modus bit 1: program paging on)
- ......................................... 333

## positions
- ND-5000 card rack ........................ 6
- ND-5000 compact card rack ................ 8

## power-up
- ......................................... 84

## POWFAIL (power failure)
- ......................................... 97

## prefix
- ......................................... 176

## PRF (processor fault, status bit)
- ......................................... 79

## procedures for database recovery
- ......................................... 155

## process
- capability register (CAP) ................ 161
- registers ................................ 147
- segment .................................. 147
- segment (PS) ............................. 141, 161

## program
- counter (P) .............................. 169
- segment capability ....................... 143
- PRT (programmed trap, status bit) ........ 77
- PS (process segment) ..................... 147, 161
- PSA (pipelined stack address) ............ 199
- PSD (process switch disable, status bit) . 73
- PSLOW1 (modus bit 8: microprogrammed setting of SLOW1)
  ......................................... 333
- PSOLO (modus bit 21: programmed SOLO) .... 333
- PST (physical segment table) ............. 144
- PSTP (physical segment table pointer) .... 144, 160
- PUWP (page used/written in page pointer) . 160
- PV (protect violation, status bit) ....... 79
- PWF (power failure, status bit) .......... 79
- PXD (modus bit 3: page-cross check disable)
  ......................................... 333

## Q register
- ......................................... 238

## qualified address cache
- ......................................... 184

## R (record register)
- ......................................... 182

## rack positions
- ND-5000 .................................. 6
- ND-5000 compact .......................... 8

## RAIBF (reset AIBF and clear MASKAIBF flip-flop)
- ......................................... 99

## RCONW register (in OCTC)
- ......................................... 93

## READ
- ACCP PROM version (ACCP command) ......... 134
- AIB16 (ACCP command) ..................... 123
- AIB32 directly (ACCP command) ............ 124
- AIB32 via memory (ACCP command) .......... 124
- ASTS (ACCP command) ...................... 126
- CPU model (ACCP command) ................. 135
- ECO levels (ACCP command) ................ 132
- from memory .............................. 50
- instructions, succeeding ................. 41

Norsk Data ND-05.020.1 EN

---

## Page 362

# Index

## READ
- last used physical address ................................... 158
- memory references ........................................... 157
- MIR (ACCP command) .......................................... 122
- multiport (ACCP command) .................................... 127
- register in MMS (MMSR) ...................................... 157
- self-test status (ACCP command) .............................. 134

## receiver
- control word (RCONW register in OCTC) ........................ 93
- status (RSTS register in OCTC) ............................... 93

## recovery of databases ........................................ 155

## register
- block in ND-5000 ............................................ 229
- in octobus controller ........................................ 93
- macrostatus .................................................. 72

## register, modus .............................................. 333

## registers
- floating ..................................................... 22
- in WRF ....................................................... 22
- index ........................................................ 22
- scratch ...................................................... 22

## reset
- ACCP (ACCP command) ......................................... 131
- CPU (ACCP command) .......................................... 130

## RESRV (in data cache) ......................................... 48, 49

## restart microprogram (ACCP command) ........................... 129

## result level
- (F-level) .................................................... 40
- pipeline delay ............................................... 40

## RMEM (normal read memory) .................................... 157

## RNDO (modus bit 13: rounding mode 0) .......................... 333

## RND1 (modus bit 14: rounding mode 1) .......................... 333

## RPHS (read memory/read from physical segment) ................. 152, 157
## RPHYS (read last used physical address) ....................... 158
## RPOFF (paging off read memory) ................................ 157

## RSTS register (in OCTC) ....................................... 93

## run self-test (ACCP command) .................................. 133
## RWWP (read memory which demand write permitted) ............... 157

## S (destination register for most ABR calculations) ............ 169
## S (sign, status bit) .......................................... 74

## saved program counter (SP) ..................................... 169

## scaling error (SCAEN) .......................................... 241

## SCAX (control of scaling X-register) ........................... 240

## scratch registers .............................................. 22

## segment number (physical) ...................................... 152

## selection of test object ....................................... 237

## sequence
- break ......................................................... 63
- conditional ................................................... 202
- control ....................................................... 202
- false ......................................................... 202
- inverted ...................................................... 202
- nanostate ..................................................... 33, 251
- true .......................................................... 202
- unconditional ................................................. 202

Norsk Data ND-05.020.1 EN

---

## Page 363

# Index

| Topic | Page |
|-------|------|
| sequencing of instruction cache | 60 |
| serial | |
| interface (UART) on ACCP | 95 |
| register (ASR, access module) | 87 |
| shadow register loop | 87 |
| shadow register loop (SSR) | 95 |
| set | |
| clock speed (ACCP command) | 134 |
| trace selector (ACCP command) | 128 |
| shared memory | 26, 86 |
| SIFGO (modus bit 0: smart IFGO cache) | 333 |
| SI-MUX (stack input multiplexer) | 199 |
| SIT (single instruction trap, status bit) | 75 |
| SLOW (set CPU clock speed to slow (156 ns)) | 98 |
| software of ACCP | 101 |
| solo-mode cycle counter | 217 |
| SP (saved program counter) | 169 |
| speed | |
| of ACCP | 91 |
| of octobus | 325 |
| SSR (serial shadow register loop) | 87, 95 |
| start | |
| (power-up) | 84 |
| microprogram (ACCP command) | 120 |
| state trace (STRACE) | 305 |
| station numbers (octobus) | 315 |
| status | |
| register (CPU) | 72 |
| register (MIC) | 217 |
| register (MMS) | 162 |
| STO (stack overflow, status bit) | 77 |
| stop | |
| (microprogrammed stop) | 97 |
| microprogram (ACCP command) | 120 |
| STRACE (nanosequence state trace) | 305 |
| strategy of cache | 52 |
| STS (MMS status register) | 162 |
| STU (stack underflow, status bit) | 77 |
| succeeding READ instructions | 41 |
| TALU (true ALU) | 234 |
| TBC (to be cached) | 169 |
| TCONW register (in OCTC) | 93 |
| TDATA register (in OCTC) | 93 |
| terminate (ACCP command) | 131 |
| test | |
| and set | 86 |
| buffer (ACCP command) | 123 |
| bus (ACCP command) | 123 |
| multiport (ACCP command) | 128 |
| object selection | 237 |
| THM (trap handler missing, status bit) | 79 |
| TOS (top of stack) | 199 |

Norsk Data ND-05.020.1 EN

---

## Page 364

# Index

## trace

| Topic                                           | Page |
|-------------------------------------------------|------|
| address and control signals                     | 304  |
| AOP                                             | 304  |
| DB                                              | 304  |
| MIB                                             | 303  |
| nanosequence state                              | 305  |
| tracer hardware                                 | 303  |
| TRACM (trace mode)                              | 306  |
| TRACM0 (modus bit 15: trace mode 0)             | 333  |
| TRACM1 (modus bit 16: trace mode 1)             | 333  |
| TRACM2 (modus bit 17: trace mode 2)             | 333  |
| TRACM3 (modus bit 18: trace mode 3)             | 333  |
| TRACM4 (modus bit 19: trace mode 4)             | 333  |

## translation speed-up buffer (TSB)

| Topic                                           | Page |
|-------------------------------------------------|------|
| TSB                                             | 149  |
| transmitter control word (TCONW register in OCTC) | 93  |
| data (TDATA register in OCTC)                   | 93  |
| status (TSTS register in OCTC)                  | 93  |

## trap

| Topic                                           | Page |
|-------------------------------------------------|------|
| system                                          | 69   |
| to be                                           | 179  |
| TRAPC (clear MMS traps)                         | 158  |
| TRIG (trigger for tracer)                       | 99   |
| TROFF (modus bit 20: trap system off)           | 333  |
| true sequence                                   | 202  |
| TSB (translation speed-up buffer)               | 149  |
| TSBC (clear all entries in TSB)                 | 158  |
| TSBL (load TSB entry)                           | 158  |
| TSBPHS (TSB for physical segment translation)   | 152  |
| TS-MUX (true sequence multiplexer)              | 199  |
| TSTS register (in OCTC)                         | 93   |
| types of messages, octobus                      | 102  |

## UART

| Topic                                           | Page |
|-------------------------------------------------|------|
| (in the access module)                          | 95   |
| unaligned data                                  | 39   |

## unconditional sequence

| Topic                                           | Page |
|-------------------------------------------------|------|
| used map                                        | 202  |
| data cache                                      | 48   |
| instruction cache                               | 56   |

## VECT

| Topic                                           | Page |
|-------------------------------------------------|------|
| (vector register)                               | 199  |

## verify parameter pointer

| Topic                                           | Page |
|-------------------------------------------------|------|
| (ACCP command)                                  | 114  |

## versions of ND-5000

| Topic                                           | Page |
|-------------------------------------------------|------|
|                                                 | 5    |

## WCS

| Topic                                           | Page |
|-------------------------------------------------|------|
| (write control store)                           | 99   |
| WMEM (normal write memory)                      | 157  |

## word

| Topic                                           | Page |
|-------------------------------------------------|------|
| boundary crossing                               | 39   |

## working

| Topic                                           | Page |
|-------------------------------------------------|------|
| register (WR)                                   | 161  |
| register file (WRF)                             | 21, 229, 239 |

## WPHS

| Topic                                           | Page |
|-------------------------------------------------|------|
| (write memory/write to physical segment)        | 152, 157 |

## WPOFF

| Topic                                           | Page |
|-------------------------------------------------|------|
| (paging off write memory)                       | 157  |

Norsk Data ND-05.020.1 EN

---

## Page 365

# Index

| Term                                          | Page |
|-----------------------------------------------|------|
| WR (working register)                         | 161  |
| WRF (working register file)                   | 21, 229, 239 |
| WR registers                                  | 22   |
| write                                         |      |
| memory references                             | 157  |
| multiport (ACCP command)                      | 127  |
| register in MMS (MMSW)                        | 157  |
| to memory                                     | 50   |
| write-back caches                             | 52   |
| write-once strategy                           | 52   |
| X-bus (extension bus)                         | 214  |
| XCLK (octobus signal)                         | 316  |
| XDAT (octobus signal)                         | 316  |
| XREQ (octobus signal)                         | 316  |
| XRFO (octobus signal)                         | 316  |
| XS (scaled index register)                    | 182  |
| XSE (index scaling error, status bit)         | 78   |
| XSEN (selected X-register)                    | 240  |
| XSEXN (selected X-register external)          | 240  |
| Y (destination register for TBC calculations) | 169  |
| Z (zero, status bit)                          | 74   |
| ZDET (zero detection)                         | 171  |

Norsk Data ND-05.020.1 EN

---

## Page 366

# SEND US YOUR COMMENTS!

Are you frustrated because of unclear information in our manuals? Do you have trouble finding things?

Please let us know if you:
- find errors
- cannot understand information
- cannot find information
- find needless information.

Do you think we could improve our manuals by rearranging the contents? You could also tell us if you like the manual.

Send to:  
Norsk Data A.S  
Documentation Department  
P.O: Box 25 BOGERUD  
N - 0621 OSLO 6 - Norway

# NOTE!

This form is primarily for documentation errors. Software and system errors should be reported on Customer System Reports.

| Manual Name: ______________________________ | Manual number: ________________ |

Which version of the product are you using?  
___________________________________________________________________________

What problems do you have? (use extra pages if needed)  
___________________________________________________________________________  
___________________________________________________________________________  
___________________________________________________________________________  
___________________________________________________________________________  
___________________________________________________________________________

Do you have suggestions for improving this manual?  
___________________________________________________________________________  
___________________________________________________________________________  
___________________________________________________________________________  
___________________________________________________________________________  
___________________________________________________________________________  
___________________________________________________________________________  

| Your name: _____________________________ | Date: _______________ |

| Company: ________________________________ | Position: ________________________ |

Address:  
___________________________________________________________________________  
___________________________________________________________________________

What are you using this manual for?  
___________________________________________________________________________

---

## Page 367

I'm unable to convert the image as it does not contain any visible text. If you have another page with text, feel free to share it!

---

